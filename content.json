{"meta":{"title":"THINK TWICE","subtitle":"YZC BLOG","description":"YZC BLOG","author":"yzc","url":"https://blog.yzcthinktwice.com"},"pages":[{"title":"","date":"2019-11-29T10:10:03.862Z","updated":"2019-11-29T10:10:03.712Z","comments":true,"path":"baidu_verify_wsImRP7m3r.html","permalink":"https://blog.yzcthinktwice.com/baidu_verify_wsImRP7m3r.html","excerpt":"","text":"wsImRP7m3r"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-10-23T16:29:35.816Z","comments":false,"path":"client/index.html","permalink":"https://blog.yzcthinktwice.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-23T16:29:35.816Z","comments":true,"path":"comment/index.html","permalink":"https://blog.yzcthinktwice.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-23T16:29:35.817Z","comments":false,"path":"donate/index.html","permalink":"https://blog.yzcthinktwice.com/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-23T16:29:35.817Z","comments":false,"path":"lab/index.html","permalink":"https://blog.yzcthinktwice.com/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-23T16:29:35.820Z","comments":true,"path":"rss/index.html","permalink":"https://blog.yzcthinktwice.com/rss/index.html","excerpt":"","text":""},{"title":"links","date":"2019-10-27T15:11:06.000Z","updated":"2019-10-27T14:44:38.022Z","comments":true,"path":"links/index.html","permalink":"https://blog.yzcthinktwice.com/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-23T16:29:35.821Z","comments":true,"path":"tags/index.html","permalink":"https://blog.yzcthinktwice.com/tags/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-12-01T01:49:42.139Z","comments":false,"path":"bangumi/index.html","permalink":"https://blog.yzcthinktwice.com/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-23T16:29:35.814Z","comments":false,"path":"about/index.html","permalink":"https://blog.yzcthinktwice.com/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-23T14:31:23.679Z","comments":false,"path":"music/index.html","permalink":"https://blog.yzcthinktwice.com/music/index.html","excerpt":"","text":"我的收藏 天气之子海上钢琴师","keywords":"喜欢的音乐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-23T16:29:35.822Z","comments":false,"path":"video/index.html","permalink":"https://blog.yzcthinktwice.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-23T16:29:35.822Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://blog.yzcthinktwice.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"FLOW15 汽车加油驾驶问题","slug":"FLOW15 汽车加油驾驶问题","date":"2019-12-03T12:49:15.000Z","updated":"2019-12-03T12:50:20.741Z","comments":true,"path":"2019/12/03/FLOW15 汽车加油驾驶问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW15 汽车加油驾驶问题/","excerpt":"","text":"FLOW15 汽车加油驾驶问题 模型：分层图最短路径-&gt;最短路径 题意：给定一个 $N×N$ 的方形网格，设其左上角为起点，坐标为 $(1,1)$ ，X 轴向右为正， Y 轴向下为正，每个方格边长为 1 。 一辆汽车从起点出发驶向右下角终点 $(N,N)$ 。 在若干个网格交叉点处，设置了油库。汽车在行驶过程中应遵守如下规则：汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边；出发时汽车已装满油，在起点与终点处不设油库； 汽车经过一条网格边时，若其 X 坐标或 Y 坐标减小，则应付费用 $B$ ，否则免付费用； 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$；在需要时可在网格点处增设油库，并付增设油库费用 $C$ (不含加油费用 $A$ )。 求出汽车从起点出发到达终点的一条所付费用最少的行驶路线。 题解：又是一道假网络流题 一道分层图最短路题 对于k步的条件，我们将原图拆成k+1层图，从下到上第i层表示此时的油够走k-i+1步 对于每个格子 都要从下往上将自己的每一层都连起来，代价为0 向下向右连边没有代价，向上向左连边代价为$B$ 对于加油站 这格上的每一层都要向第一层连边，代价为$A$ 向四周连边时，都是从自己的第一层，到目标的第二层，因为从自己这出去肯定是满油的 对于普通格 自己的每一层i都要向四周的更高层i+1连边，因为剩余多少步数都是有可能的 还要从自己的每一层向自己的第一层连边，代价为$A+C$，意思是建个加油站加满油 跑一遍最短路，再从每一层的终点处搜集最小的答案即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=2e5+5; int n,k,a,b,c,dis[N],h[N],en,ans=0x3f3f3f3f; struct edge{ int n,v,w; }e[60*N]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } int calc(int x,int y,int lv){ return n*n*(lv-1)+(x-1)*n+y; } struct node{ int x,v; inline bool operator &lt; (const node &amp;nt) const { return v&gt;nt.v; } }; void dij(int s){ priority_queue&lt;node&gt; q; memset(dis,0x3f,sizeof dis); dis[s]=0; q.push((node){s,0}); while(!q.empty()){ node x=q.top(); q.pop(); if(dis[x.x]!=x.v) continue; for(int i=h[x.x];i;i=e[i].n){ int y=e[i].v; if(dis[x.x]+e[i].w&lt;dis[y]){ dis[y]=dis[x.x]+e[i].w; q.push((node){y,dis[y]}); } } } } signed main(){ read(n);read(k);read(a);read(b);read(c); for(int i=1,x;i&lt;=n;i++) for(int j=1;j&lt;=n;j++){ read(x); for(int l=1;l&lt;=k;l++) add(calc(i,j,l),calc(i,j,l+1),0); if(x){ for(int l=2;l&lt;=k+1;l++) add(calc(i,j,l),calc(i,j,1),a); if(i&lt;n) add(calc(i,j,1),calc(i+1,j,2),0); if(j&lt;n) add(calc(i,j,1),calc(i,j+1,2),0); if(i&gt;1) add(calc(i,j,1),calc(i-1,j,2),b); if(j&gt;1) add(calc(i,j,1),calc(i,j-1,2),b); } else{ for(int l=1;l&lt;=k;l++){ if(i&lt;n) add(calc(i,j,l),calc(i+1,j,l+1),0); if(j&lt;n) add(calc(i,j,l),calc(i,j+1,l+1),0); if(i&gt;1) add(calc(i,j,l),calc(i-1,j,l+1),b); if(j&gt;1) add(calc(i,j,l),calc(i,j-1,l+1),b); } for(int l=2;l&lt;=k+1;l++) add(calc(i,j,l),calc(i,j,1),a+c); } } dij(calc(1,1,1)); for(int i=1;i&lt;=k+1;i++) ans=min(ans,dis[calc(n,n,i)]); write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://blog.yzcthinktwice.com/tags/最短路/"},{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW14 孤岛营救问题","slug":"FLOW14 孤岛营救问题","date":"2019-12-03T12:49:14.000Z","updated":"2019-12-03T12:49:34.417Z","comments":true,"path":"2019/12/03/FLOW14 孤岛营救问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW14 孤岛营救问题/","excerpt":"","text":"FLOW14 孤岛营救问题 模型：分层图最短路径-&gt;最短路径 题意：迷宫的外形是一个长方形，其南北方向被划分为 $n$ 行，东西方向被划分为 $m$ 列， 于是整个迷宫被划分为 $n×m$ 个单元。南北或东西方向相邻的 2 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成 $p$ 类， 打开同一类的门的钥匙相同，不同类门的钥匙不同。 大兵瑞恩被关押在 $(n,m)$ 单元里，并已经昏迷。迷宫只有一个入口， 在 $(1,1)$ 单元。麦克从一个单元移动到另一个 相邻单元的时间为 1，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。 试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。 题解：又是一道假网络流题 一道经典的状压bfs 把钥匙压成二进制，从(1,1)开始向四周bfs，对每个点的每个状态记个v数组，记录有没有走过 如果走到(n,m)就输出步数 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=12,S=1&lt;&lt;11; const int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1}; int loc[N][N][N][N],key[N][N],n,m,k; bool v[N][N][S]; struct situ{ int x,y,s,step; }; int bfs(){ queue&lt;situ&gt; q; q.push((situ){1,1,key[1][1],0}); v[1][1][key[1][1]]=1; while(!q.empty()){ situ now=q.front(); q.pop(); int x=now.x,y=now.y; if(x==n&amp;&amp;y==m) return now.step; for(int i=0;i&lt;4;i++){ int nx=x+dx[i],ny=y+dy[i]; if(nx&lt;1||ny&lt;1||nx&gt;n||ny&gt;m) continue; if(loc[x][y][nx][ny]==-1) continue; if(loc[x][y][nx][ny]!=(loc[x][y][nx][ny]&amp;now.s)) continue; int ns=now.s|key[nx][ny]; if(v[nx][ny][ns]) continue; v[nx][ny][ns]=1; q.push((situ){nx,ny,ns,now.step+1}); } } return -1; } signed main(){ read(n);read(m);read(k);read(k); while(k--){ int x,y,xx,yy; read(x);read(y);read(xx);read(yy); read(loc[x][y][xx][yy]); if(!loc[x][y][xx][yy]) loc[x][y][xx][yy]=-1; else loc[x][y][xx][yy]=1&lt;&lt;loc[x][y][xx][yy]-1; loc[xx][yy][x][y]=loc[x][y][xx][yy]; } read(k); while(k--){ int x,y,z; read(x);read(y);read(z); key[x][y]|=1&lt;&lt;z-1; } write(bfs()); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://blog.yzcthinktwice.com/tags/状态压缩/"},{"name":"BFS","slug":"BFS","permalink":"https://blog.yzcthinktwice.com/tags/BFS/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW12 软件补丁问题","slug":"FLOW12 软件补丁问题","date":"2019-12-03T12:48:12.000Z","updated":"2019-12-03T12:48:29.166Z","comments":true,"path":"2019/12/03/FLOW12 软件补丁问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW12 软件补丁问题/","excerpt":"","text":"FLOW12 软件补丁问题 模型：最小转移代价-&gt;最短路径 题意：某公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了一批共 $m$ 个补丁程序。对于每一个补丁 $i$ ，都有 2 个与之相应的错误集合 $B_1(i)$ 和 $B_2(i)$ ，使得仅当软件包含 $B_1(i)$ 中的所有错误，而不包含 $B_2(i)$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误 $F_1(i)$ ，而同时加入另一些错误 $F_2(i)$。另外，每个补丁都耗费一定的时间。 试设计一个算法，利用公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。 题解：又是一道假网络流题 一道巧妙的状压最短路 将每一种是否存在的状态各自看做一个节点 预处理出题面所说的四个集合$B_1$,$B_2$,$F_1$,$F_2$压缩后的状态 看看对于每种状态在使用了某个补丁后，会演变出什么新状态，据此连上一条边 由于边数会很多，所以可以在做最短路的同时对于当前状态，枚举每个补丁，看看会产生哪些新边，逐一处理 显然的，最短路起点为全1状态，终点为全0状态 最短路距离即答案 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=25,M=105,S=1&lt;&lt;20; int dis[S],n,m,cost[M],f1[M],f2[M],b1[M],b2[M]; char a[N],b[N]; struct node{ int x,v; inline bool operator &lt; (const node &amp;nt) const { return v&gt;nt.v; } }; void dij(int s){ memset(dis,0x3f,sizeof dis); dis[s]=0; priority_queue&lt;node&gt; q; q.push((node){s,0}); while(!q.empty()){ node x=q.top(); q.pop(); if(dis[x.x]!=x.v) continue; for(int i=1;i&lt;=m;i++) if((b1[i]&amp;x.x)==b1[i]&amp;&amp;(b2[i]&amp;x.x)==0){ int y=((x.x|f1[i])^f1[i])|f2[i]; if(dis[x.x]+cost[i]&lt;dis[y]){ dis[y]=dis[x.x]+cost[i]; q.push((node){y,dis[y]}); } } } } signed main(){ read(n);read(m); for(int i=1;i&lt;=m;i++){ read(cost[i]); scanf(&quot;%s%s&quot;,a,b); for(int j=0;j&lt;n;j++){ if(a[j]==&#39;+&#39;) b1[i]|=1&lt;&lt;j; if(a[j]==&#39;-&#39;) b2[i]|=1&lt;&lt;j; if(b[j]==&#39;-&#39;) f1[i]|=1&lt;&lt;j; if(b[j]==&#39;+&#39;) f2[i]|=1&lt;&lt;j; } } dij((1&lt;&lt;n)-1); if(dis[0]==0x3f3f3f3f) dis[0]=0; write(dis[0]); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://blog.yzcthinktwice.com/tags/最短路/"},{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://blog.yzcthinktwice.com/tags/状态压缩/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW7 试题库问题","slug":"FLOW7 试题库问题","date":"2019-12-03T12:45:07.000Z","updated":"2019-12-03T12:47:35.732Z","comments":true,"path":"2019/12/03/FLOW7 试题库问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW7 试题库问题/","excerpt":"","text":"FLOW7 试题库问题 模型：二分图多重匹配-&gt;网络最大流 题意：假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。 题解： 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x3f3f3f3f; const int N=2050,M=1e6+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans,tot; bool v[N]; struct edge{ int n,v,f; }e[N+M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void exadd(int x,int y,int z){ add(x,y,z); add(y,x,0); } bool bfs(int s,int aim){ memset(d,0,sizeof d); memcpy(cur,h,sizeof cur); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].f){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].f){ int flow=dfs(y,min(rest,e[i].f),aim); rest-=flow; e[i].f-=flow; e[i^1].f+=flow; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(m);read(n); s=1,t=n+m+2; for(int i=1,x;i&lt;=m;i++) exadd(i+s+n,t,read(x)),tot+=x; for(int i=1,nm;i&lt;=n;i++){ exadd(s,i+s,1); read(nm); for(int j=1,x;j&lt;=nm;j++) exadd(i+s,read(x)+s+n,1); } if(dinic(s,t)^tot){ printf(&quot;No Solution!&quot;); return 0; } for(int i=1;i&lt;=m;i++){ if(i^1) puts(&quot;&quot;); write(i);putchar(&#39;:&#39;); int x=i+s+n; for(int i=h[x];i;i=e[i].n) if(e[i].f){ putchar(&#39; &#39;); write(e[i].v-s); } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"https://blog.yzcthinktwice.com/tags/二分图匹配/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW6 最长不下降子序列问题","slug":"FLOW6 最长不下降子序列问题","date":"2019-12-03T12:45:06.000Z","updated":"2019-12-03T12:45:10.755Z","comments":true,"path":"2019/12/03/FLOW6 最长不下降子序列问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW6 最长不下降子序列问题/","excerpt":"","text":"FLOW6 最长不下降子序列问题 模型：最多不相交路径-&gt;网络最大流 题意：给定正整数序列$x_1 \\sim x_n$ ， 计算其最长不下降子序列的长度 $s$。 计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。 如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为 $s$ 的不下降子序列。 题解：将“与之关联的不下降子序列的数量”看成本问题中的“流” 自然的，先拆点，拆成出点和入点 Q1：第一问设f[i]表示以i结尾的最长不下降子序列的长度，$O(n^2)$DP，轻松解决 设此问答案为ans1 Q2：第二问采用网络最大流 因为一个点只能有一次出入，所以此问中的所有边的容量都是为1的 首先，常规操作，在每个点内部（也就是从入点向出点）连边 考虑水流的源点，其f[i]必然是等于ans1的，于是从超级源点向所有源点连边 考虑水流的汇点，其f[i]必然是等于1的，于是从所有汇点向超级汇点连边 考虑水流的存在需满足的要求，对于可以存在水流的点i和j(i&lt;j)，$f[i]+1==f[j]$且$a[i]&lt;=a[j]$，然后对于所有的i,j关系连边 跑一遍最大流，即可得出ans2 Q3：因为1和n能用多次，所以在Q2网络图的基础上将与1或n相关联的边的容量修改为inf 重新跑一遍最大流，即可得出ans3 注意特判ans1==1的情况 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x3f3f3f3f; const int N=1050,M=3e3+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans,ma,ans1,ans2,ans3,f[N],a[N]; bool v[N]; struct edge{ int n,v,f; }e[N+M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void exadd(int x,int y,int z){ add(x,y,z); add(y,x,0); } bool bfs(int s,int aim){ memset(d,0,sizeof d); memcpy(cur,h,sizeof cur); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].f){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].f){ int flow=dfs(y,min(rest,e[i].f),aim); rest-=flow; e[i].f-=flow; e[i^1].f+=flow; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(n); s=1,t=n+n+2; for(int i=1;i&lt;=n;i++){ read(a[i]); f[i]=1; for(int j=1;j&lt;i;j++) if(a[j]&lt;=a[i]) f[i]=max(f[i],f[j]+1); ans1=max(ans1,f[i]); } if(ans1==1){ write(1);puts(&quot;&quot;); write(n);puts(&quot;&quot;); write(n); return 0; } for(int i=1;i&lt;=n;i++){ exadd(i+s,i+s+n,1); if(f[i]==1) exadd(s,i+s,1); if(f[i]==ans1) exadd(i+s+n,t,1); for(int j=i+1;j&lt;=n;j++) if(f[j]==f[i]+1&amp;&amp;a[j]&gt;=a[i]) exadd(i+s+n,j+s,1); } ans2=dinic(s,t); exadd(1+s,1+s+n,oo); exadd(s,1+s,oo); for(int i=2;i&lt;=en;i+=2) e[i].f+=e[i^1].f,e[i^1].f=0; if(f[n]==ans1){ exadd(n+s,n+s+n,oo); exadd(n+s+n,t,oo); } ans3=dinic(s,t); write(ans1);puts(&quot;&quot;); write(ans2);puts(&quot;&quot;); write(ans3); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW5 圆桌问题","slug":"FLOW5 圆桌问题","date":"2019-12-03T12:43:05.000Z","updated":"2019-12-03T12:44:14.874Z","comments":true,"path":"2019/12/03/FLOW5 圆桌问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW5 圆桌问题/","excerpt":"","text":"FLOW5 圆桌问题 模型：二分图多重匹配-&gt;网络最大流 题意：假设有来自 $n$ 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 $r_i$ 。会议餐厅共有 $m$ 张餐桌，每张餐桌可容纳 $c_i$ 个代表就餐。 为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。 试给出满足要求的代表就餐方案。 题解：将“人”看成本问题中的“流” 显然的，“人”是从“单位”流出，在一张餐桌上汇合的 因此从源点向每个单位连条容量为单位人数的边，从每张桌子向汇点连条容量为桌子容量的边 而桌子与对应单位的边的容量为1（因为一张桌子一个单位至多一人） 跑一遍最大流，用超级汇点统计一下能放的人数，不等于餐桌可容纳人数总数的话就代表是不合法的 然后在残量网络里继续处理 枚举桌子，再依次枚举单位，看看对应的边上有无流量，这对应着这张桌子上有没有这个单位的人 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x3f3f3f3f; const int N=505,M=1e5+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans,ma; bool v[N]; struct edge{ int n,v,f; }e[N+M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void exadd(int x,int y,int z){ add(x,y,z); add(y,x,0); } bool bfs(int s,int aim){ memset(d,0,sizeof d); memcpy(cur,h,sizeof cur); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].f){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].f){ int flow=dfs(y,min(rest,e[i].f),aim); rest-=flow; e[i].f-=flow; e[i^1].f+=flow; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(m);read(n); s=1,t=m+n+2; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) exadd(i+s,j+s+n,1); for(int i=1,x;i&lt;=m;i++) exadd(i+s+n,t,read(x)),ma+=x; for(int i=1,x;i&lt;=n;i++) exadd(s,i+s,read(x)); if(dinic(s,t)^ma){ write(0); return 0; } write(1); for(int i=1;i&lt;=m;i++){ puts(&quot;&quot;); int x=i+s+n; for(int i=h[x];i;i=e[i].n) if(e[i].f) write(e[i].v-s),putchar(&#39; &#39;); } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW4 魔术球问题","slug":"FLOW4 魔术球问题","date":"2019-12-03T12:32:04.000Z","updated":"2019-12-03T12:43:08.751Z","comments":true,"path":"2019/12/03/FLOW4 魔术球问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW4 魔术球问题/","excerpt":"","text":"FLOW4 魔术球问题 模型：有向无环图最小路径覆盖-&gt;网络最大流 题意：假设有 n 根柱子，按下述规则在这 n 根柱子中依次放入编号为 1,2,3,4,⋯ 的球：每次只能在某根柱子的最上面放球；在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。 试计算出在 n 根柱子上最多能放多少个球。 题解：又是一道假网络流题 如果是网络流做法的话，应该是将每个球看成点，把符合条件的“关系”看成有向边，跑一遍有向无环图最小路径覆盖（方法见FLOW3 最小路径覆盖问题） 但我选择了贪心来解决这题（主要是代码方便，懒得去搞网络流了。。。） 假设能放m个球，贪心思路就是对于1..m每个球，枚举每根柱子，能放就放，不能放新开一个，直到柱子开完为止 显然的，复杂度$O(nm)$ 贪心正确性不会证，暂时也看不懂，但可以先放出两个版本的证明： 版本一，版本二 另外，其实m的值也是可以$O(1)$计算的 具体的通项公式可以见OEIS A047838（反正我也不会证。。。） 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } vector&lt;int&gt; ans[60]; int n,m; bool check(int x){ return (int)sqrt(x)*(int)sqrt(x)==x; } signed main(){ read(n); m=(n+1)*(n+1)/2-1; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) if(ans[j].empty()||check(ans[j][ans[j].size()-1]+i)){ ans[j].push_back(i); break; } write(m); for(int i=1;i&lt;=n;i++){ puts(&quot;&quot;); for(int j=0;j&lt;ans[i].size();j++){ write(ans[i][j]); if(j!=ans[i].size()-1) putchar(&#39; &#39;); } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://blog.yzcthinktwice.com/tags/贪心/"},{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW3 最小路径覆盖问题","slug":"FLOW3 最小路径覆盖问题","date":"2019-12-03T12:31:03.000Z","updated":"2019-12-03T12:31:20.398Z","comments":true,"path":"2019/12/03/FLOW3 最小路径覆盖问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW3 最小路径覆盖问题/","excerpt":"","text":"FLOW3 最小路径覆盖问题 模型：有向无环图最小路径覆盖-&gt;网络最大流 题意：给定有向图 $G=(V,E)$。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个顶点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。$P$ 中路径可以从 $V$ 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。$G$ 的最小路径覆盖是 $G$ 的所含路径条数最少的路径覆盖。 求一个有向无环图 $G$ 的最小路径覆盖。 题解：将“一条路径”看成本问题中的“流” 自然的，对图进行拆点操作，拆成进点和出点 题目要求两条路径无交点，也就是说每个点只有一个进或一个出，每条边也都只能经过一次 因此从源点向每个进点连条容量1的边，从每个出点向汇点连条容量1的边 对于每条读入的边$(u,v)$，从u的出点向v的进点连条容量1的边 跑遍最大流 最小路径覆盖数=点数-最大流 证明略去，个人认为这与“无环图中森林数=点数-边数”基本是一个道理 对于方案的输出，因为一条边只有选和不选两种选择，所以只需要在残量网络上跑一遍，将在同一个联通块中的点一起输出即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x3f3f3f3f; const int N=405,M=6e3+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans; bool v[N]; struct edge{ int n,v,f; }e[N+M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void exadd(int x,int y,int z){ add(x,y,z); add(y,x,0); } bool bfs(int s,int aim){ memset(d,0,sizeof d); memcpy(cur,h,sizeof cur); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].f){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].f){ int flow=dfs(y,min(rest,e[i].f),aim); rest-=flow; e[i].f-=flow; e[i^1].f+=flow; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } void print(int x){ for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==s||y==t) continue; if(e[i].f) continue; v[y-n-1]=1; putchar(&#39; &#39;);write(y-n-1); print(y-n); } } signed main(){ read(n);read(m); s=1,t=n*2+2; for(int i=1,x,y;i&lt;=m;i++){ read(x);read(y); exadd(x+s,y+s+n,1); } for(int i=1;i&lt;=n;i++) exadd(s,i+1,1),exadd(i+n+s,t,1); ans=n-dinic(s,t); for(int i=1;i&lt;=n;i++) if(!v[i]){ write(i); print(i+s); puts(&quot;&quot;); } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW2 太空飞行计划问题","slug":"FLOW2 太空飞行计划问题","date":"2019-12-03T12:30:02.000Z","updated":"2019-12-03T12:30:20.710Z","comments":true,"path":"2019/12/03/FLOW2 太空飞行计划问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW2 太空飞行计划问题/","excerpt":"","text":"FLOW2 太空飞行计划问题 模型：最大权闭合图-&gt;网络最小割 题意：现已确定了一个可供选择的实验集合 $E = \\{ E_1, E_2, \\cdots, E_m \\}$，和进行这些实验需要使用的全部仪器的集合 $I = \\{ I_1, I_2, \\cdots, I_n \\}$。实验 $E_j$ 需要用到的仪器是 $I$ 的子集 $R_j \\subseteq I$。 配置仪器 $I_k$ 的费用为 $c_k$ 美元。实验 $E_j$ 的赞助商已同意为该实验结果支付 $p_j$ 美元。对于给定的实验和仪器配置情况，找出净收益最大的试验计划。 题解：最大权闭合子图例题 可以从 $S$ 向每个实验连一条容量为 $p_i$ 的边，每个实验向所需要的仪器连一条容量为 $inf$ 的边，每个仪器向 $T$ 连一条容量为 $c_i$ 的边 假设所有实验都做，再计算出网络图的最小割，最小割就是要花费的钱 答案就是总的能赚的钱减去花费的钱 为什么要看做最小割呢？因为如果某个实验的收益为负数，但是它用到的仪器能为别的实验所用，那么就相当于你花了这个实验的赞助商给你的钱为别的实验买仪器，具象化在网络图上，就是仪器那个点给这个实验一个流，把这个实验流出去的抵消掉了。当然，也会存在那种无论怎么买仪器都不划算的实验，这样的实验有一个特点，因为它不能供给仪器的需求，所以源点到它的残流一定是0，就是说不管是正向边还是反向边都是0，同样的那些可以供给的，源点到它的残留一定大于0，也就是正向边或者反向边大于0，说明做这个实验能赚钱。 然后来看所选择实验和仪器的输出 考虑用dinic跑网络流，注意到最后一遍跑完分层图后的有“存在”点都是最“邻近”超级源点和超级汇点的，也就是采取最小割后，这些点都是与两个超级点在同一集合中的 所以在网络流后枚举一遍每个点在分层图中的深度，有深度（存在）就表示要选择，输出即可 代码：#include &lt;bits/stdc++.h&gt; #define fill(x,y) memset(x,y,sizeof x) #define copy(x,y) memcpy(x,y,sizeof x) using namespace std; inline int read(int &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } inline void write(int x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x7fffffff; const int N=100+5,M=N*N+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans; struct edge{int n,v,w;}e[M&lt;&lt;1]; inline void add(int x,int y,int z){e[++en]=(edge){h[x],y,z};h[x]=en;} inline void exadd(int x,int y,int z){add(x,y,z);add(y,x,0);} bool bfs(int s,int aim){ fill(d,0); copy(cur,h); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].w){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].w){ int tp=dfs(y,min(rest,e[i].w),aim); rest-=tp; e[i].w-=tp; e[i^1].w+=tp; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(n);read(m); s=0;t=n+m+1; for(int i=1,x;i&lt;=n;i++){ read(x); ans+=x; exadd(s,i,x); for(;;){ char c; scanf(&quot;%d%c&quot;,&amp;x,&amp;c); exadd(i,n+x,oo); if(c==&#39;\\n&#39;||c==&#39;\\r&#39;) break; } } for(int i=1,x;i&lt;=m;i++){ read(x); exadd(n+i,t,x); } ans-=dinic(s,t); for(int i=1;i&lt;=n;i++) if(d[i]) write(i),putchar(&#39; &#39;); puts(&quot;&quot;); for(int i=1;i&lt;=m;i++) if(d[i+n]) write(i),putchar(&#39; &#39;); puts(&quot;&quot;); write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW1 飞行员配对方案问题","slug":"FLOW1 飞行员配对方案问题","date":"2019-12-03T12:29:01.000Z","updated":"2019-12-03T12:29:30.614Z","comments":true,"path":"2019/12/03/FLOW1 飞行员配对方案问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW1 飞行员配对方案问题/","excerpt":"","text":"FLOW1 飞行员配对方案问题 模型：二分图最大匹配-&gt;网络最大流 题意：每架飞机需要两个驾驶员，一个正驾驶员和一个副驾驶员。由于种种原因，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。两个正驾驶员或两个副驾驶员都不能同机飞行。 题解：二分图匹配裸题 代码：#include &lt;bits/stdc++.h&gt; #define fill(x,y) memset(x,y,sizeof x) #define copy(x,y) memcpy(x,y,sizeof x) using namespace std; inline int read(int &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } inline void write(int x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x7fffffff; const int N=2000+5,M=N*N+5; int en=1,h[N],d[N],na,nb,m,s,t,use,cur[N]; struct edge{int n,v,w;}e[M&lt;&lt;1]; inline void add(int x,int y,int z){e[++en]=(edge){h[x],y,z};h[x]=en;} inline void exadd(int x,int y,int z){add(x,y,z);add(y,x,0);} bool bfs(int s,int aim){ fill(d,0); copy(cur,h); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].w){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].w){ int tp=dfs(y,min(rest,e[i].w),aim); rest-=tp; e[i].w-=tp; e[i^1].w+=tp; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(na);read(nb); nb-=na; for(int x,y;;){ read(x);read(y); if(x==-1) break; exadd(x+1,y+1,1); } for(int i=1;i&lt;=na;i++) exadd(1,i+1,1); for(int i=1;i&lt;=nb;i++) exadd(na+1+i,na+nb+2,1); int ans=dinic(1,na+nb+2); if(ans==0){puts(&quot;No Solution!&quot;);return 0;} write(ans);puts(&quot;&quot;); for(int i=2;i&lt;=en;i+=2){ int x=e[i].v,y=e[i^1].v; if(x!=1&amp;&amp;y!=1&amp;&amp;x!=na+nb+2&amp;&amp;y!=na+nb+2&amp;&amp;e[i^1].w) write(y-1),putchar(&#39; &#39;),write(x-1),putchar(&#39;\\n&#39;); } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"https://blog.yzcthinktwice.com/tags/二分图匹配/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1260C Infinite Fence","slug":"CF1260C Infinite Fence","date":"2019-11-29T11:16:01.000Z","updated":"2019-11-29T11:53:16.123Z","comments":true,"path":"2019/11/29/CF1260C Infinite Fence/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/29/CF1260C Infinite Fence/","excerpt":"","text":"CF1260C Infinite Fence 数学结论题，现场却卡得我基本掉色 难度在于对数学式的敏感度 题解：假设r&lt;=b（如果不是就交换） 首先思考r，b互质的情况，发现一定会存在第pos个木板涂蓝色，而第pos+1个木板涂成红色的情况 也就是说$rx-by=1$一定有正整数解存在，这一点可以用裴蜀定理简单的证明 （在P1082 同余方程的题解里，你也许可以得到更好的证明） 这意味着如果要OBEY，那么区间[pos,pos+b]中的红色木板数量一定要小于k，也就是 (k-1)*r+1 \\geq b（该式的意思是pos以后的k-1块红木板要能够卡满，甚至超过这个长度为b的区间） 此时又可以发现对于r，b不互质的情况，如果我们只看那些能被gcd(r,b)整除的木板，它们的情况又是与上述情况相同的 换句话说，只要先将r，b都除去gcd(r,b)使两者互质，再套用上述判定式即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long int t,r,b,k; void doit(){ read(r);read(b);read(k); int gcd=__gcd(r,b); r/=gcd; b/=gcd; if(r&gt;b) swap(r,b); if((k-1)*r+1&gt;=b) puts(&quot;OBEY&quot;); else puts(&quot;REBEL&quot;); } signed main(){ read(t); while(t--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1149B Three Religions","slug":"CF1149B Three Religions","date":"2019-11-29T11:08:01.000Z","updated":"2019-12-01T01:43:15.767Z","comments":true,"path":"2019/11/29/CF1149B Three Religions/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/29/CF1149B Three Religions/","excerpt":"","text":"CF1149B Three Religions 一道新颖的dp好题 题意：有三个字符串$s_1,s_2,s_3$和一个主串$s$，每次操作改变一个$s_i$ （插入或删除字符），每次操作完之后问$s$是否可以分成3个子序列正好是$s_1,s_2,s_3$ 。任意时候$|s_i|\\leq 250$。 题解：设f[i][j][k]表示A串匹配到第i个字符，B串匹配到第j个字符，C串匹配到第k个字符时，在模式串中的最短距离，即最左点（串的下标都从1开始） 预处理出nxt[i][c]，表示模式串中，[i,n]区间内，c字符第一次出现的位置 下面是一张cf官方的解释nxt数组的图，它的下标从0开始，也许可以方便理解 初始化$f[i][j][k]=n+1,f[0][0][0]=0$，意思是假设怎样都匹配失败，都不去匹配才能成功 转移方程如下： ${f[i][j][k]=\\min\\left \\{nxt[f[i-1][j][k]+1][s[1][i]],nxt[f[i][j-1][k]+1][s[2][j]],nxt[f[i][j][k-1]+1][s[3][k]] \\right \\}}$ 意思是，尝试从A串中加个字符找后续位置，从B串中加个字符找后续位置,从C串中加个字符找后续位置，从这三个位置中的最左边的一个那转移 对于插入操作，注意到新增加的状态只有 新字符与另外两个串的每个位置 这至多250*250种状态，对于这些新状态重新跑一遍dp即可 对于删除操作，直接减小相应串长即可 对于答案ans=f[len[1]][len[2]][len[3]]，意思就是三个串全部匹配完后，在模式串中的最左点 当ans&lt;=n时，说明是可以在模式串中被匹配完的，输出YES 否则ans=n+1就输出NO 特别注意处理nxt数组时，nxt[n+1][]和nxt[n+2][]都要赋为n+1 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5,M=255; char p[N]; int s[4][M],nxt[N][28],f[M][M][M],n,q,len[4]; /*预处理出nxt[][]数组*/ void init(){ for(int i=0;i&lt;26;i++) nxt[n+1][i]=nxt[n+2][i]=n+1; //注意这边的[n+2] for(int i=n;i;i--) for(int j=0;j&lt;26;j++){ if(p[i]==j+&#39;a&#39;) nxt[i][j]=i; else nxt[i][j]=nxt[i+1][j]; } } void doit(){ char ch;cin&gt;&gt;ch; int id;read(id); if(ch==&#39;+&#39;){ cin&gt;&gt;ch; s[id][++len[id]]=ch-&#39;a&#39;; for(int i=(id==1?len[1]:0);i&lt;=len[1];i++) //三目表达式部分意思是，如果是这个串被修改，那它只要计算新的一位，否则就都要从头开始 for(int j=(id==2?len[2]:0);j&lt;=len[2];j++) for(int k=(id==3?len[3]:0);k&lt;=len[3];k++){ int &amp;now=f[i][j][k]; now=n+1; //都先假设不可能 if(i) now=min(now,nxt[f[i-1][j][k]+1][s[1][i]]); //A串转移 if(j) now=min(now,nxt[f[i][j-1][k]+1][s[2][j]]); //B串转移 if(k) now=min(now,nxt[f[i][j][k-1]+1][s[3][k]]); //C串转移 } } else{ len[id]--; //直接删长度 } if(f[len[1]][len[2]][len[3]]&lt;=n) puts(&quot;YES&quot;); //最左点在n以内就可行 else puts(&quot;NO&quot;); } signed main(){ read(n);read(q); scanf(&quot;%s&quot;,p+1); init(); while(q--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"DP","slug":"DP","permalink":"https://blog.yzcthinktwice.com/tags/DP/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1253E Antenna Coverage","slug":"CF1253E Antenna Coverage","date":"2019-11-29T11:06:01.000Z","updated":"2019-12-01T01:43:00.767Z","comments":true,"path":"2019/11/29/CF1253E Antenna Coverage/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/29/CF1253E Antenna Coverage/","excerpt":"","text":"CF1253E Antenna Coverage 一道难度2200的dp题 题意：街道上有$n$个天线。第$i$个天线的位置为$x_i$ ，以及一个范围值$s_i$ ；第$i$个天线的覆盖范围是$[x_i-s_i,x_i+s_i]$ 每次操作，你可以花费1代价，使得第$i$个天线的$s_i$增加一。每个天线都可以进行多次操作。现在请问你最少需要花费多少代价，使$[1,m]$编号内的每一个位置都被至少一个天线覆盖。 题解：f[i]表示覆盖1~i的最小代价 初始化f[i]=i，因为转移方向从左往右，在不考虑某点右方天线的情况下，最坏都可以看成是从f[0]转移的 转移枚举1~m每个点，再分别对每个点枚举所有天线，分类讨论： 若天线在它左边，由于从左向右转移的原则和局部最优解的性质，就可以不用判能否覆盖，直接从它的最大右覆盖处转移即可 $f[i]=min(f[i],f[max(0,x[j]-s[j]-1)])$ 若天线在它右边，则就要从它对于这个天线的左边的对称点转移，如果在天线半径之外，还要加上个代价 $f[i]=min(f[i],f[max(0,2*x[j]-i-1)]+max(0,i-x[j]-s[j]))$ 答案是f[m] 如果无法理解转移，可以看看下面这张图，是我从这里偷来的qwq 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int n,m,x[N],s[N],f[N]; signed main(){ read(n);read(m); for(int i=1;i&lt;=n;i++) read(x[i]),read(s[i]); for(int i=1;i&lt;=m;i++) f[i]=i; //初始化 for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++){ if(i&gt;=x[j]) f[i]=min(f[i],f[max(0,2*x[j]-i-1)]/*对称点处*/+max(0,i-x[j]-s[j])/*若超出还要补上额外代价*/); //在天线右边 else f[i]=min(f[i],f[max(0,x[j]-s[j]-1)]/*因为局部最优解，所以可以直接从边界转移*/); //在天线左边 } write(f[m]); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"DP","slug":"DP","permalink":"https://blog.yzcthinktwice.com/tags/DP/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1257E The Contest","slug":"CF1257E The Contest","date":"2019-11-28T04:16:01.000Z","updated":"2019-11-28T04:28:05.850Z","comments":true,"path":"2019/11/28/CF1257E The Contest/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/28/CF1257E The Contest/","excerpt":"","text":"CF1257E The Contest 一道锻炼前缀、后缀、差分、化式子能力的好题 题意：给你三个集合A,B,C，集合大小分别为an，bn，cn，且an+bn+cn=n 满足三个集合的并集正好是整数1~n 每次操作可以将一个任意集合中的任意数字扔到另一个集合中 问至少需要几次操作使得每个集合内的数字都是连贯的（空集也可以，且A中所有元素小于B中所有元素，B中所有元素小于C中所有元素 题解：为了满足题目要求，不妨假设A中含0到i，B中含i+1到j，C中含j+1到n+1（0和n+1是不存在的） 显然的，此时答案ans就是每个集合中不属于自己的元素的个数和 设a[i]表示A集合中含有数1~i的个数，b[i]与c[i]同理 利用差分的思想可以得出此时要扔进这三个集合的元素个数分别为$(b[i]+c[i])$，$(a[j]-a[i]+c[j]-c[i])$，$(a[n]-a[j]+b[n]-b[j])$ 加起来就得到 ans=(b[i]+c[i])+(a[j]-a[i]+c[j]-c[i])+(a[n]-a[j]+b[n]-b[j])移项 ans=(a[j]-a[i]+a[n]-a[j])+(b[i]+b[n]-b[j])+(c[i]+c[j]-c[i])抵消 ans=-a[i]+an+b[i]+bn-b[j]+c[j]ans=(b[i]-a[i])+(an+bn)+(c[j]-b[j]) \\ \\ [i","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"前缀","slug":"前缀","permalink":"https://blog.yzcthinktwice.com/tags/前缀/"},{"name":"后缀","slug":"后缀","permalink":"https://blog.yzcthinktwice.com/tags/后缀/"},{"name":"差分","slug":"差分","permalink":"https://blog.yzcthinktwice.com/tags/差分/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3147 [USACO16OPEN]262144","slug":"P3147 [USACO16OPEN]262144","date":"2019-11-28T04:13:01.000Z","updated":"2019-11-28T04:29:42.849Z","comments":true,"path":"2019/11/28/P3147 [USACO16OPEN]262144/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/28/P3147 [USACO16OPEN]262144/","excerpt":"","text":"P3147 [USACO16OPEN]262144 DP好题，状态比较难想 f[i][j]表示将位置为i的数合成数字j所需要达到的最右点 初始f[i][a[i]]=i+1 因为合并距离都是2幂次，所以转移可以用类似倍增的思想 循环j套i f[i][j]=f[f[i][j-1]][j-1]若f[i][j]不为0则说明i位置上j是可行的 最后统计可行j的最大值即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=262150; int n,ans,f[N][60]; signed main(){ read(n); for(int i=1,x;i&lt;=n;i++) f[i][read(x)]=i+1; //初始都在自己右边 for(int j=2;j&lt;=58;j++) for(int i=1;i&lt;=n;i++){ if(f[i][j]==0) f[i][j]=f[f[i][j-1]][j-1]; //类似倍增跳过去 if(f[i][j]&gt;0) ans=j; //可行就更新答案 } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.yzcthinktwice.com/tags/DP/"},{"name":"USACO","slug":"USACO","permalink":"https://blog.yzcthinktwice.com/tags/USACO/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"LOJ6276 果树","slug":"LOJ6276 果树","date":"2019-11-28T04:10:01.000Z","updated":"2019-12-01T01:42:43.372Z","comments":true,"path":"2019/11/28/LOJ6276 果树/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/28/LOJ6276 果树/","excerpt":"","text":"LOJ6276 果树 思维难度较大，代码难度巨大，细节超多 题意：给定一棵树，每个点有个颜色，询问特殊路径的数量 其中，定义特殊路径$(u,v)$为从u到v每个点颜色都不同的路径 $(u,v)=(v,u)$ 特别的，每种颜色至多出现20次 题解：每种颜色至多20次显然是问题的突破口 这样我们可以先假设所有点两两都是满足的，然后在同种颜色集合内两两枚举节点，对与两者相关联的点统一做关系消除，因为只要同时经过这两点的路径都一定是不合法的 这种“关联”显然是连贯的，而树上连贯的关系又想到什么？dfs序！ 在本题中，由于关联是双向的，我们将dfs序拓展成矩阵，消除关系就相当于在矩阵上放矩形（打阴影） 最后答案就是没被覆盖的部分 求矩阵面积并你又想到了啥？扫描线+线段树！ 套用模板即可 然鹅细节最多的部分在下面： 我们对枚举的同色两点进行如下分类讨论： 假设$deep_x&lt;=deep_y$且$col_x=col_y$ 已知如下一棵树： dfs矩阵是这样的的： SIT1： 无祖先关系 在上图中，x=2，y=3 发现此时会因为这两点导致关系不成立的是x的子树和y的子树（见图上的两个蓝框 这两部分由于都是子树，因此在dfs序上都是连续的（见下图的蓝色部分和绿色部分 可以在矩阵上打上两块完整的矩形（见下图的灰色部分 代码中只要计算dfs序上连续部分的头和尾就就可以得到矩形的四个顶点 SIT2： 有祖先关系 在上图中，x=1，y=6，且x是y的祖先 发现此时会因为这两点导致关系不成立的是y的子树和整棵树刨去点2的子树后的部分（见图上的两个蓝框 而这个点2是什么呢？它是x的所有儿子中距离y最近的一个，可以表示为点z 因此蓝框部分又可以叫做y的子树和整棵树刨去z的子树后的部分 z的位置怎么计算呢？ 发现z是y的祖先，且已知z到y的距离，因此可以用倍增lca的方法预处理出每个点2幂次倍的祖先，此时再对z-y距离二进制分解，对等于1的二进制位做爬升处理 y的子树部分与SIT1相同 那整棵树刨去z的子树后的部分在dfs序上怎么得到呢？ 由于是刨去，因此该部分可能是两段不连续的区间 在下图中，红线部分是z的子树，绿色是y的子树，两种蓝色是刨去后剩下的两段 代码中可以先将绿色与深蓝色部分打阴影 处理好后再将绿色与浅蓝色部分打阴影 添加阴影上下边和求面积并时注意点与长度的关系，即处理好是否需要+1变成左闭右开区间 最后面积算好后记得除以2,因为$(u,v)=(v,u)$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int f[N][20],en,h[N],sz[N],id[N],n,cnt,len[N&lt;&lt;2],tag[N&lt;&lt;2],ln,d[N]; vector&lt;int&gt; col[N]; long long ans; struct edge{ int n,v; }e[N&lt;&lt;1]; /*阴影的上下边界线*/ struct line{ int l,r,h,op; //op=1是上线，op=-1是下线 inline bool operator &lt; (const line &amp;nt) const { return h&lt;nt.h; } }a[N&lt;&lt;6]; /*线段树部分*/ void pushup(int x,int l,int r){ if(tag[x]){ len[x]=r-l+1; } else{ if(l^r) len[x]=len[x&lt;&lt;1]+len[x&lt;&lt;1|1]; else len[x]=0; } } void up(int x,int l,int r,int p,int q,int v){ if(p&lt;=l&amp;&amp;r&lt;=q){ tag[x]+=v; pushup(x,l,r); return ; } int mid=l+r&gt;&gt;1; if(p&lt;=mid) up(x&lt;&lt;1,l,mid,p,q,v); if(q&gt;mid) up(x&lt;&lt;1|1,mid+1,r,p,q,v); pushup(x,l,r); } void add(int x,int y){ e[++en]=(edge){h[x],y}; h[x]=en; } /*预处理部分*/ void dfs(int x){ sz[x]=1; d[x]=d[f[x][0]]+1; id[x]=++cnt; for(int i=1;i&lt;=16;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==f[x][0]) continue; f[y][0]=x; dfs(y); sz[x]+=sz[y]; } } /*倍增lca*/ int lca(int x,int y){ for(int i=16;~i;i--) if(d[f[y][i]]&gt;=d[x]) y=f[y][i]; if(x==y) return x; for(int i=16;~i;i--) if(f[x][i]^f[y][i]){ x=f[x][i]; y=f[y][i]; } return f[x][0]; } /*二进制跳跃找祖先*/ int getf(int x,int k){ for(int i=16;~i;i--) if(k&gt;&gt;i&amp;1) x=f[x][i]; return x; } /*添加阴影的上下边界线*/ void addline(int x,int y,int xx,int yy){ //(x,y)是矩形的左上角，(xx,yy)是矩形的右下角 a[++ln]=(line){x,xx,y,1}; //上线 a[++ln]=(line){x,xx,yy+1,-1}; //下线 a[++ln]=(line){y,yy,x,1}; //对称过来的上线 a[++ln]=(line){y,yy,xx+1,-1}; //对称过来的下线 } signed main(){ read(n); for(int i=1,x;i&lt;=n;i++) col[read(x)].push_back(i); for(int i=1,x,y;i&lt;n;i++){ read(x);read(y); add(x,y); add(y,x); } /*预处理出dfs序和fa[][]等信息*/ dfs(1); /*打阴影*/ for(int i=1;i&lt;=n;i++) //枚举颜色 for(int j=0;j&lt;col[i].size();j++) for(int k=j+1;k&lt;col[i].size();k++){ //两两枚举点 int x=col[i][j],y=col[i][k]; if(d[x]&gt;d[y]) swap(x,y); int LCA=lca(x,y); if(LCA==x){ //x是y祖先的情况 int z=getf(y,d[y]-d[x]-1); //求z的位置 int xx=id[z]-1; int yy=id[y]+sz[y]-1; x=1; y=id[y]; /*(x,y)是矩形的左上角，(xx,yy)是矩形的右下角，下同*/ if(x&lt;=xx) addline(x,y,xx,yy); //前半段 x=id[z]+sz[z],xx=n; if(x&lt;=xx) addline(x,y,xx,yy); //后半段 } else{ int xx=id[x]+sz[x]-1,yy=id[y]+sz[y]-1; x=id[x];y=id[y]; addline(x,y,xx,yy); //完整的一段 } } /*求面积并部分，模板*/ sort(a+1,a+1+ln); for(int i=1;i&lt;ln;i++){ up(1,1,n,a[i].l,a[i].r,a[i].op); ans+=1ll*len[1]*(a[i+1].h-a[i].h); } write(1ll*(1+n)*n-ans&gt;&gt;1ll); //一块等腰直角三角形面积减去一半的阴影面积 } 如果你写挂了，就请多检查检查你的打阴影部分","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"LOJ","slug":"LOJ","permalink":"https://blog.yzcthinktwice.com/tags/LOJ/"},{"name":"线段树","slug":"线段树","permalink":"https://blog.yzcthinktwice.com/tags/线段树/"},{"name":"dfs序","slug":"dfs序","permalink":"https://blog.yzcthinktwice.com/tags/dfs序/"},{"name":"扫描线","slug":"扫描线","permalink":"https://blog.yzcthinktwice.com/tags/扫描线/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"YOJ1 二人从空中落下","slug":"YOJ1 二人从空中落下","date":"2019-11-25T12:04:01.000Z","updated":"2019-11-25T12:44:08.583Z","comments":true,"path":"2019/11/25/YOJ1 二人从空中落下/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/25/YOJ1 二人从空中落下/","excerpt":"","text":"YOJ1 二人从空中落下 暂时没时间放上YOJ，先寄存在luogu上 几乎全原创的一道题，感受到了出题的艰难。。。 欢迎各位帮忙验题！ 题意:现有n个无区别的点，他们可能随机连边成为一棵特殊的树 这种树满足它的每个非叶子节点都有且只有两个儿子 现给出a和b 问这些点所生成的所有特殊的树，能满足高度$\\in\\left [ a,b \\right ]$的概率是多少（约定单个节点高度为1） 对998244353取模 题解：灵感来源于P1472奶牛家谱 一道简短的dp，暴力给了30 SUB1：a与b正好卡满所有可能情况，100%能安全降落 输出1即可 SUB2：从1到(n+1)/2枚举降落点进行爆搜 给出暴力的大致代码： int dfs(int cnt, int height){ if (cnt == 1) return height == 1; if (height &gt; (cnt + 1) / 2) return 0; if (height &lt;= 1) return 0; int state=0; for (int i(1); i &lt; cnt; i += 2){ for (int j(1); j &lt; height; ++j){ state += dfs(i, height - 1) * dfs(cnt - i - 1, j); state %= MOD; if (height - 1 != j){ state += dfs(i, height - 1) * dfs(cnt - i - 1, j); state %= MOD; } } } return state; } signed main(){ scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;a,&amp;b); m=n+1&gt;&gt;1; if(a&gt;m){ puts(&quot;0&quot;); return 0; } if(a==ceil(log2(n+1))&amp;&amp;b==m){ puts(&quot;1&quot;); return 0; } b=min(b,m); for(int i=1;i&lt;=m;i++) s[i]=s[i-1]+dfs(n,i); cout&lt;&lt;(((s[b]-s[a-1])%mod+mod)%mod)*fpow(s[m],mod-2,mod)%mod; return 0; } SUB3：给想出标程但没处理b导致RE的人 SUB4：给想出标程但没有差分答案的人 标算：令m=(n+1)/2 画图易知m是n个点的最大合法深度 设f[i][j]表示i个点深度小于等于j的树有几种 初始f[1][]=1 转移$O(n^2*m)$ 三层循环分别枚举深度，枚举总点数，枚举左子树分配点数 $f[i][k]=sum{f[j][k-1]*f[i-j-1][k-1]}$ 若j为左子树点数则i-j-1为右子树点数 乘法原理，两者相乘 答案的分子部分显然可以由f[n][b]-f[n][a-1]差分得到 而分母部分就是f[n][m] 要注意的是，有些点a,b很大，需要特判： 若a&gt;m则输出0，因为一种都不满足 否则若b&gt;m则需要先将b取min改为m再继续做，以防止RE爆下标，因为&gt;m的部分都一定是不满足的 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=1005,mod=998244353; int n,m,f[N][605],a,b; int fpow(int x,int y,int mod){ int res=1; for(;y;y&gt;&gt;=1,mod?(x*=x)%=mod:x*=x) if(y&amp;1) mod?(res*=x)%=mod:res*=x; return res; } signed main(){ read(n);read(a);read(b); m=(n+1)&gt;&gt;1; if(a&gt;m){ //对a特判 puts(&quot;0&quot;); return 0; } b=min(b,m); //对b特判 for(int i=1;i&lt;=m;i++) f[1][i]=1; //初始 for(int k=1;k&lt;=m;k++) //枚举深度 for(int i=3;i&lt;=n;i+=2) //枚举总点数 for(int j=1;j&lt;i;j+=2) //枚举左子树分配点数 (f[i][k]+=f[j][k-1]*f[i-j-1][k-1]%mod)%=mod; //累加 write((((f[n][b]-f[n][a-1])%mod+mod)%mod)*fpow(f[n][m],mod-2,mod)%mod); //差分得答案 }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://blog.yzcthinktwice.com/tags/dp/"},{"name":"YOJ","slug":"YOJ","permalink":"https://blog.yzcthinktwice.com/tags/YOJ/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"ABC146F Sugoroku","slug":"ABC146F Sugoroku","date":"2019-11-25T00:31:01.000Z","updated":"2019-11-25T12:01:56.338Z","comments":true,"path":"2019/11/25/ABC146F Sugoroku/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/25/ABC146F Sugoroku/","excerpt":"","text":"ABC146F Sugoroku 题意：给定一个01串，从0出发，恰好到达n胜利，每次能走1~m步，且数字为1的位置不能走 问字典序最小的行走方法（即不仅走的次数要少，且越靠前走的步数越要少） 题解：套路题，思路不算难想 step 1:先设计dp考虑走的次数尽可能少的条件 设f[i]表示到i位置的最少步数 初始f[]=oo,f[0]=0 转移$f_i=\\min \\left \\{ f_j|i-j&lt;=m \\right \\}+1 (a_i==0)$ 复杂度$O(nm)$ 考虑优化dp 发现min部分就是个滑动窗口，于是上单调队列 复杂度降为$O(n)$ step2:考虑题目的另一个要求：靠前的步数要尽可能少 因为总步数不变，靠前的要少，也就是说靠后的要多 也就是用g[]记录每次dp转移是从哪个位置转来的，如有相同则取前者转移 最后在dp后倒着从g[n]开始遍历，类似链表，每次g[n]与n的差就是这次走的步数 反着输出即可 代码实现也很简单，因为单调队列的先进后出的性质可以保证队首的下标是最小的，直接塞到g[]中即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int n,m,a[N],f[N],g[N]; deque&lt;int&gt; q; vector&lt;int&gt; ans; signed main(){ read(n);read(m); for(int i=0;i&lt;=n;i++) scanf(&quot;%1d&quot;,&amp;a[i]),f[i]=0x3f3f3f3f; f[0]=0; f[n+1]=0x3f3f3f3f; q.push_back(0); //先塞个0进去 for(int i=1;i&lt;=n;i++) if(!a[i]){ //转移先决条件 g[i]=n+1; while(!q.empty()&amp;&amp;q.front()+m&lt;i) q.pop_front(); //维护单调队列 if(!q.empty()) g[i]=q.front(); //维护g[] f[i]=f[g[i]]+1; //转移f[] while(!q.empty()&amp;&amp;f[q.back()]&gt;f[i]) q.pop_back(); //维护单调队列 q.push_back(i); } if(f[n]&gt;n){ write(-1); //走不到n则无解 return 0; } for(;n;n=g[n]) ans.push_back(n-g[n]); //倒着类链表便利g[] for(int i=ans.size()-1;i&gt;=0;i--) write(ans[i]),putchar(&#39; &#39;); //再倒着输出步数 }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.yzcthinktwice.com/tags/AtCoder/"},{"name":"dp","slug":"dp","permalink":"https://blog.yzcthinktwice.com/tags/dp/"},{"name":"单调队列","slug":"单调队列","permalink":"https://blog.yzcthinktwice.com/tags/单调队列/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"ABC146E Rem of Sum is Num","slug":"ABC146E Rem of Sum is Num","date":"2019-11-24T14:31:01.000Z","updated":"2019-11-25T11:49:22.800Z","comments":true,"path":"2019/11/24/ABC146E Rem of Sum is Num/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/24/ABC146E Rem of Sum is Num/","excerpt":"","text":"ABC146E Rem of Sum is Num 一道巧妙的思维题，考验了对数学式的转化 题意:给出一个数列和常数k，求合法子序列的个数 其中合法子序列需要满足： \\sum_{i}^{j}{a_i} \\equiv j-i+1\\ \\left (\\mod k \\right ) 题解：比赛时毫无思路，赛后看了题解茅塞顿开 让我们来转化这个需要满足的式子，其中规定$s_i$表示1-i的前缀和： \\sum_{i}^{j}{a_i} \\equiv j-i+1 \\ (\\mod k )s_j - s_{i-1} \\equiv j-(i-1) \\ (\\mod k )s_j - s_i \\equiv j-i \\ (\\mod k )s_i-i = s_j-j \\ (j-i","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.yzcthinktwice.com/tags/AtCoder/"},{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1223C Save the Nature","slug":"CF1223C Save the Nature","date":"2019-11-22T01:16:01.000Z","updated":"2019-11-24T00:59:19.680Z","comments":true,"path":"2019/11/22/CF1223C Save the Nature/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/22/CF1223C Save the Nature/","excerpt":"","text":"CF1223C Save the Nature 本文给出$O(nlog^2n)$和$O(nlogn)$的算法 首先二分答案的思路由询问内容的单调性可得，十分好想，一只log 重点在于check部分，有两种思路 1. 暴力sort两只log (156ms)思维难度低，代码难度低 关键是出题人没来卡 先O(n)扫一遍，得到每天的贡献（百分比） O(nlogn)从大到小排序，与每天的值配对 bool check(int n){ int sum=0; for(int i=1;i&lt;=n;i++){ b[i]=0; if(i%al==0) b[i]+=x; //有第一种贡献 if(i%be==0) b[i]+=y; //有第二种贡献 } sort(b+1,b+1+n,greater&lt;int&gt;()); //greater&lt;int&gt;()是自带的一个比较函数，用来从大到小排 for(int i=1;i&lt;=n;i++) sum+=a[i]*b[i]; //a[]在main()中均已除以100，直接暴力配对 return sum&gt;=k; } 2. lcm容斥一只log (62ms)跑的飞快，毕竟正解 我们发现如果有贡献，只有三种情况，即a的倍数,b的倍数,lcm(a,b)的倍数 方便起见，先做这么一件事： if(x&lt;y) swap(x,y),swap(al,be); 这样就保证lcm优于a,a优于b了 用除法算出a,b,lcm各有几个记为xn,yn,xyn 由容斥原理可得xn,yn都要减去xyn 使得可以保证a,b,lcm贡献互不相交 然后分三段按照lcm(x+y),a(x),b(y)的顺序扫一遍即可 bool check(int n){ int sum=0,xn=n/al,yn=n/be,xyn=n/lcm; //除法计算 xn-=xyn; //容斥 yn-=xyn; for(int i=1;i&lt;=xyn;i++) sum+=(x+y)*a[i]; //lcm段 for(int i=xyn+1;i&lt;=xyn+xn;i++) sum+=x*a[i]; //a段 for(int i=xyn+xn+1;i&lt;=xyn+xn+yn;i++) sum+=y*a[i]; //b段 return sum&gt;=k; } 代码两只log#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=2e5+5; int q,n,a[N],b[N],k,x,y,be,al; bool check(int n){ int sum=0; for(int i=1;i&lt;=n;i++){ b[i]=0; if(i%al==0) b[i]+=x; if(i%be==0) b[i]+=y; } sort(b+1,b+1+n,greater&lt;int&gt;()); for(int i=1;i&lt;=n;i++) sum+=a[i]*b[i]; return sum&gt;=k; } void doit(){ read(n); for(int i=1;i&lt;=n;i++) read(a[i]),a[i]/=100; sort(a+1,a+1+n,greater&lt;int&gt;()); read(x);read(al); read(y);read(be); read(k); int l=1,r=n,ans=-1; while(l&lt;=r){ int mid=l+r&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } write(ans);puts(&quot;&quot;); } signed main(){ read(q); while(q--) doit(); } 一只log#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=2e5+5; int q,n,a[N],b[N],k,x,y,be,al,lcm; bool check(int n){ int sum=0,xn=n/al,yn=n/be,xyn=n/lcm; xn-=xyn; yn-=xyn; for(int i=1;i&lt;=xyn;i++) sum+=(x+y)*a[i]; for(int i=xyn+1;i&lt;=xyn+xn;i++) sum+=x*a[i]; for(int i=xyn+xn+1;i&lt;=xyn+xn+yn;i++) sum+=y*a[i]; return sum&gt;=k; } void doit(){ read(n); for(int i=1;i&lt;=n;i++) read(a[i]),a[i]/=100; sort(a+1,a+1+n,greater&lt;int&gt;()); read(x);read(al); read(y);read(be); if(x&lt;y) swap(x,y),swap(al,be); lcm=al*be/__gcd(al,be); read(k); int l=1,r=n,ans=-1; while(l&lt;=r){ int mid=l+r&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } write(ans);puts(&quot;&quot;); } signed main(){ read(q); while(q--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"二分答案","slug":"二分答案","permalink":"https://blog.yzcthinktwice.com/tags/二分答案/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF949C Data Center Maintenance","slug":"CF949C Data Center Maintenance","date":"2019-11-21T06:36:01.000Z","updated":"2019-11-24T00:59:07.046Z","comments":true,"path":"2019/11/21/CF949C Data Center Maintenance/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/21/CF949C Data Center Maintenance/","excerpt":"","text":"CF949C Data Center Maintenance 这题如果没有搞清楚题意，其实结论是并不“显然”的 题目其实是让你主动推迟有且仅有一个点，并将所有会因此受影响的点也都连锁着推迟下去，问最少会有几个点推迟 注意这个”主动推迟“，这意味着即使已经满足条件了你还是得要推迟一个点 搞懂了题意，接下来的思路就好理解了 我们发现“推迟”是一种单向关系，即，如果我使你不得不推迟，而你却不会使我不得不推迟 将这种单向关系转成图论的单向边 边的是否添加，即询问两者的是否满足 u_x +1 \\equiv x_y \\ \\ ( mod {h} )发现一个点只要有出度那它肯定不是最优的 如A-&gt;B，选A必带B，选B可无A 所以首先可以确定答案节点没有出度的 其次，由于强联通分量里的点都是可以互相到达的，所以只要其一推迟，另外的都得推迟 于是缩点，经保留size 问题变成在DAG上找一个没有出度的最小的点 $O(n)$扫一遍即可 #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int h[N],en,H,n,m,scc[N],dfn[N],low[N],st[N],lim,cnt,du[N],sn,ans,sz[N],a[N]; bool v[N]; struct edge{ int n,u,v; }e[N]; void add(int x,int y){ e[++en]=(edge){h[x],x,y}; h[x]=en; } void tarjan(int x){ //找强联通分量 low[x]=dfn[x]=++cnt; v[x]=1; st[++lim]=x; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); } else{ if(v[y]) low[x]=min(low[x],dfn[y]); } } if(low[x]==dfn[x]){ int top; sn++; for(;;){ top=st[lim--]; scc[top]=sn; v[top]=0; sz[sn]++; if(top==x) return ; } } } signed main(){ read(n);read(m);read(H); for(int i=1;i&lt;=n;i++) read(a[i]); for(int i=1,x,y;i&lt;=m;i++){ read(x);read(y); if((a[x]+1)%H==a[y]) add(x,y); //边的添加（关系的判断） if((a[y]+1)%H==a[x]) add(y,x); } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=en;i++){ int x=scc[e[i].u],y=scc[e[i].v]; //根据原先加的边判定出度 if(x^y) du[x]++; } sz[0]=0x3f3f3f3f; for(int i=1;i&lt;=sn;i++) if(!du[i]){ if(sz[i]&lt;sz[ans]) ans=i; //取无出度节点的最小size } write(sz[ans]);puts(&quot;&quot;); for(int i=1;i&lt;=n;i++) if(scc[i]==ans) //是这个强联通分量的就输出 write(i),putchar(&#39; &#39;); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"tarjan","slug":"tarjan","permalink":"https://blog.yzcthinktwice.com/tags/tarjan/"},{"name":"强联通分量","slug":"强联通分量","permalink":"https://blog.yzcthinktwice.com/tags/强联通分量/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P1156 垃圾陷阱","slug":"P1156 垃圾陷阱","date":"2019-11-19T01:22:45.000Z","updated":"2019-11-28T04:19:07.460Z","comments":true,"path":"2019/11/19/P1156 垃圾陷阱/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/19/P1156 垃圾陷阱/","excerpt":"","text":"P1156 垃圾陷阱 先将垃圾按时间排序 分类讨论 先假设能逃出去 设f[i][j]表示前i个垃圾叠成高度j时的最长生存时间 初始f[0][0]=10 类背包转移 注意濒死也是能转移的，即f[][]&lt;0才无法转移 转移时超过高度就输出当前时间 再模拟逃不出去 计算最长存活时间 #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=105,M=105; int n,m,f[N][M]; struct trash{ int t,f,h; inline bool operator &lt; (const trash &amp;nt) const { return t&lt;nt.t; } }a[N]; signed main(){ read(m);read(n); for(int i=1;i&lt;=n;i++){ read(a[i].t); read(a[i].f); read(a[i].h); } sort(a+1,a+1+n); memset(f,-1,sizeof f); f[0][0]=10; for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=m;j++) if(f[i-1][j]&gt;=0){ if(j+a[i].h&gt;=m&amp;&amp;f[i-1][j]+a[i-1].t&gt;=a[i].t){ write(a[i].t); return 0; } if(f[i-1][j]+a[i-1].t&gt;=a[i].t){ f[i][j+a[i].h]=f[i-1][j]+a[i-1].t-a[i].t; f[i][j]=max(f[i][j],f[i-1][j]+a[i-1].t-a[i].t+a[i].f); } } } m=10; for(int i=1;i&lt;=n;i++){ if(m+a[i-1].t&lt;a[i].t){ write(m+a[i-1].t); return 0; } m-=a[i].t-a[i-1].t; m+=a[i].f; } write(m+a[n].t); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.yzcthinktwice.com/tags/DP/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P1220 关路灯","slug":"P1220 关路灯","date":"2019-11-19T00:34:04.000Z","updated":"2019-11-28T04:19:00.467Z","comments":true,"path":"2019/11/19/P1220 关路灯/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/19/P1220 关路灯/","excerpt":"","text":"P1220 关路灯 已被关的区间是封闭连续的，加之还要知道人是在左端点还是在右端点， 所以设f[i][j][0/1]表示现在[i,j]被关闭的最小花费，且0人在左端点，1人在右端点 初始f[st][st][0/1]=0，其他=oo 转移的费用通过两点路程差*左右两段未被关的区间的功率之和 功率和可通过前缀和计算 ans=min(f[1][n][0],f[1][n][1]) #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=55; int n,st,p[N],s[N],f[N][N][2]; inline int que(int l,int r){ return s[r]-s[l-1]; } signed main(){ read(n);read(st); for(int i=1;i&lt;=n;i++){ read(p[i]); read(s[i]); s[i]+=s[i-1]; } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i!=st||j!=st) f[i][j][0]=f[i][j][1]=0x3f3f3f3f; for(int j=st;j&lt;=n;j++) for(int i=j-1;i&gt;=1;i--){ f[i][j][0]=min(f[i+1][j][0]+(p[i+1]-p[i])*(que(1,i)+que(j+1,n)),f[i+1][j][1]+(p[j]-p[i])*(que(1,i)+que(j+1,n))); f[i][j][1]=min(f[i][j-1][0]+(p[j]-p[i])*(que(1,i-1)+que(j,n)),f[i][j-1][1]+(p[j]-p[j-1])*(que(1,i-1)+que(j,n))); } write(min(f[1][n][0],f[1][n][1])); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.yzcthinktwice.com/tags/DP/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P1373 小a和uim之大逃离","slug":"P1373 小a和uim之大逃离","date":"2019-11-18T23:53:01.000Z","updated":"2019-11-28T04:18:54.678Z","comments":true,"path":"2019/11/19/P1373 小a和uim之大逃离/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/19/P1373 小a和uim之大逃离/","excerpt":"","text":"P1373 小a和uim之大逃离 f[i][j][p][0/1]表示到(i,j)时两人差为p且最后一步是0/1走的的方案数, 初始f[i][j][a[i][j]][0]=1 ans=sum{f[i][j][0][1]} #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int mod=1e9+7; const int N=805; int n,m,k,f[N][N][18][2],a[N][N]; long long ans; signed main(){ read(n);read(m);read(k);k++; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ read(a[i][j]); f[i][j][a[i][j]][0]=1; } } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int p=0;p&lt;k;p++){ if(i&gt;1){ (f[i][j][p][0]+=f[i-1][j][(p-a[i][j]+k)%k][1])%=mod; (f[i][j][p][1]+=f[i-1][j][(p+a[i][j])%k][0])%=mod; } if(j&gt;1){ (f[i][j][p][0]+=f[i][j-1][(p-a[i][j]+k)%k][1])%=mod; (f[i][j][p][1]+=f[i][j-1][(p+a[i][j])%k][0])%=mod; } } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) (ans+=f[i][j][0][1])%=mod; write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.yzcthinktwice.com/tags/DP/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3398 仓鼠找sugar","slug":"P3398 仓鼠找sugar","date":"2019-11-12T13:33:01.000Z","updated":"2019-11-13T13:03:09.712Z","comments":true,"path":"2019/11/12/P3398 仓鼠找sugar/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/12/P3398 仓鼠找sugar/","excerpt":"","text":"P3398 仓鼠找sugar 模板题，询问树上两链是否有交 算法：给出性质：若两树链有交，则必有其中一条链的端点的lca在另一条链上，记为P 由这个性质题目一下变水了。。。 那如何判断一个点是否在一条链上呢？ 设a-b链lca为c，x-y链lca为z，且$d_c&gt;d_z$ WAY1. dis(x,a)+dis(x,b)=dis(a,b)显然的，不等就成三角形了 read(x),read(y),read(u),read(v); int z=lca(x,y),w=lca(u,v); if(d[z]&gt;d[w]){ swap(x,u); swap(y,v); swap(z,w); } if(dis(w,x)+dis(w,y)==dis(x,y)) puts(&quot;Y&quot;); else puts(&quot;N&quot;); WAY2. x是x-a的lca或x是x-b的lca反证易得 read(x),read(y),read(u),read(v); int z=lca(x,y),w=lca(u,v); if(d[z]&gt;d[w]){ swap(x,u); swap(y,v); swap(z,w); } if(lca(w,x)==w||lca(w,y)==w) puts(&quot;Y&quot;); else puts(&quot;N&quot;); 证明：当然手画树猜结论是大多数人的选择 我们容易发现，如果相交，记 $x=lca(a,b)$,$y=lca(c,d)$，则必有x在c-d路径上或y在a-b路径上 首先易知两点的lca在其路径上。如果路径相交，那么x要么在相交的路径上，要么不在。我们不妨记相交的那段为e-f 如果不在，由对称性，不妨设x靠近a，那么有a到x深度递减，b到e、e到f、f到x深度递减；同样，肯定有c到f、d到e深度递减，由此可知，y必定为f，由此得证 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5,M=N&lt;&lt;1; int n,m,en,h[N],s[N],sz[N],f[N],top[N],d[N]; struct edge{int n,v;}e[M]; inline void add(const int &amp;x,const int &amp;y){ e[++en]=(edge){h[x],y}; h[x]=en; } void dfs1(int x){ sz[x]=1; d[x]=d[f[x]]+1; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==f[x]) continue; f[y]=x; dfs1(y); sz[x]+=sz[y]; if(sz[s[x]]&lt;sz[y]) s[x]=y; } } void dfs2(int x,int TOP){ top[x]=TOP; if(s[x]) dfs2(s[x],TOP); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==f[x]||y==s[x]) continue; dfs2(y,y); } } inline int lca(int x,int y){ while(top[x]^top[y]) if(d[top[x]]&gt;d[top[y]]) x=f[top[x]]; else y=f[top[y]]; return d[x]&lt;d[y]?x:y; } void doit(){ int x,y,u,v; read(x),read(y),read(u),read(v); int z=lca(x,y),w=lca(u,v); if(d[z]&gt;d[w]){ swap(x,u); swap(y,v); swap(z,w); } if(lca(w,x)==w||lca(w,y)==w) puts(&quot;Y&quot;); else puts(&quot;N&quot;); } signed main(){ read(n);read(m); for(int i=1,x,y;i&lt;n;i++){ read(x);read(y); add(x,y); add(y,x); } dfs1(1); dfs2(1,1); while(m--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"LCA","slug":"LCA","permalink":"https://blog.yzcthinktwice.com/tags/LCA/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"nim游戏及变体","slug":"nim游戏及变体","date":"2019-11-11T13:58:01.000Z","updated":"2019-11-11T14:43:37.735Z","comments":true,"path":"2019/11/11/nim游戏及变体/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/11/nim游戏及变体/","excerpt":"","text":"PART1. 经典nim出处 问题：有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利 算法：若每堆石子数的异或和不为0，则先手必胜 证明：由于nim游戏的sg值与石子数相等，所以由SG定理可以方便的得到 例题：P2197 【模板】nim游戏 PART2. 分裂nim出处 新规则：每次取完石子后，可以将取的那一堆的石子 分为多堆，也可以不分 算法：与经典无异 证明：如果异或和不为0，那先手不用分某一堆石子，同Nim游戏 如果异或和为0， 不执行分裂操作则先手必败，同Nim游戏 若执行分裂操作，如果能够证明执行分裂操作的后继局面异或和依然不为0，那么结论成立 采用反证法，证明如果分裂后异或和为0 会产生矛盾 a1 xor a2 xor a3 xor ……xor an=0 a1=a2 xor a3 xor ……xor an 假设我们取的那一堆是第1堆，取完之后还有b1个，b1&lt;a1 将b1分为x+y 若x xor y xor a2 xor a3 xor ……xor an=0 则 x xor y=a2 xor a3 xor …… xor an 所以x xor y = a1 又因为异或是不进位的加法，所以x xor y&lt;=b1&lt;a1产生矛盾 PART3. 阶梯nim出处 新规则：取的石子不是拿出而是从第i堆放入第i-1堆 算法：将每个奇数位置的数x看成一堆有x个石子的石子堆，然后玩Nim游戏。 证明： 拿走某一堆石子的一部分，相当于将某个奇位置的石子移动到它左边的偶位置上。 如果大家都只动奇位置的石子，那么这等价于两人在玩Nim游戏。 但如果有人想打破规则呢？ 假设Nim游戏先手必胜，那么先手肯定优先玩Nim游戏；如果后手试图破坏局面，将某个偶位置上的若干石子移动到了左边的奇位置i上，那么先手可以将这若干个刚移到i的石子继续移动到i左边的偶位置上，对Nim局面依然没有任何影响，除非后手回头来继续动奇位置的石子，那也只能是输。 那么如果Nim游戏先手必败，也是同理，后手可以用相同的方式迫使先手玩Nim游戏，直到输为止。 因此，奇数位置的石子的相关信息，就直接决定了阶梯Nim问题的结果。 例题：POJ1704 Georgia and Bob PART4. 树上阶梯nim新规则：在阶梯nim的基础上赋予各节点树的顺序 算法：对深度为奇数的所有点玩Nim游戏。 证明： 根据SG定理，在阶梯nim的基础上做异或合并即可 例题： 这个文档的T3","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://blog.yzcthinktwice.com/tags/博弈论/"},{"name":"教程","slug":"教程","permalink":"https://blog.yzcthinktwice.com/tags/教程/"},{"name":"nim游戏","slug":"nim游戏","permalink":"https://blog.yzcthinktwice.com/tags/nim游戏/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"LIS，LCS与树状数组","slug":"LIS，LCS与树状数组","date":"2019-11-03T12:50:01.000Z","updated":"2019-11-03T13:58:10.651Z","comments":true,"path":"2019/11/03/LIS，LCS与树状数组/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/03/LIS，LCS与树状数组/","excerpt":"","text":"模拟赛中出到了类似题，特意在网上搜索学习，并有所感想 本文由此获得启发，特此感谢 PART1. LIS从P1439 【模板】最长公共子序列开始 50pt的$O(n^2)$算法很容易想，即设f[i]表示到i结束的最长LIS的长度 f[i]=\\max \\left \\{ f[j] | a_j","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://blog.yzcthinktwice.com/tags/教程/"},{"name":"LIS","slug":"LIS","permalink":"https://blog.yzcthinktwice.com/tags/LIS/"},{"name":"LCS","slug":"LCS","permalink":"https://blog.yzcthinktwice.com/tags/LCS/"},{"name":"树状数组","slug":"树状数组","permalink":"https://blog.yzcthinktwice.com/tags/树状数组/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3657 [USACO17FEB]Why Did the Cow Cross the Road II P","slug":"P3657 [USACO17FEB]Why Did the Cow Cross the Road II P","date":"2019-11-03T12:28:01.000Z","updated":"2019-11-28T04:14:31.451Z","comments":true,"path":"2019/11/03/P3657 [USACO17FEB]Why Did the Cow Cross the Road II P/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/03/P3657 [USACO17FEB]Why Did the Cow Cross the Road II P/","excerpt":"","text":"P3657 Why Did the Cow Cross the Road II P LCS是本题比较直观的一种思路，即将普通LCS（最长公共子序列）的相等的条件改为差的绝对值&lt;=4 众所周知，求LCS有两种$O(nlogn)$方法 一种是映射，另一种是DP优化 因为差的绝对值&lt;=4的条件会使映射变得复杂，我们这里采用DP优化的方法 该方法具体可以见[noip科普]关于LIS和一类可以用树状数组优化的DP 要注意的是，该方法中要记录b[]中各值可合法对应的值在a[]的位置，这个位置是需要通过排序来保证有序的 #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int a[N],b[N],n,f[N],ans,pos[N]; vector&lt;int&gt; p[N]; struct BIT{ //树状数组模板 #define lowbit(x) (x&amp;(-x)) int a[N]; void up(int x,int v){ while(x&lt;=n){ a[x]=max(a[x],v); x+=lowbit(x); } } int que(int x){ int res=0; while(x){ res=max(res,a[x]); x-=lowbit(x); } return res; } }ma; signed main(){ read(n); for(int i=1,x;i&lt;=n;i++){ read(x); pos[x]=i; //记录某值的位置 } for(int i=1;i&lt;=n;i++){ read(b[i]); for(int j=max(1,b[i]-4);j&lt;=min(n,b[i]+4);j++) p[i].push_back(pos[j]); //记录b[]值合法对应值的位置 sort(p[i].begin(),p[i].end()); //排序使之保证有序 } for(int i=1;i&lt;=n;i++) for(int j=p[i].size()-1;j&gt;=0;j--){ //按位置搞LCS int pos=p[i][j]; f[pos]=ma.que(pos-1)+1; ma.up(pos,f[pos]); } for(int i=1;i&lt;=n;i++) ans=max(ans,f[i]); //得到答案 write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.yzcthinktwice.com/tags/DP/"},{"name":"LCS","slug":"LCS","permalink":"https://blog.yzcthinktwice.com/tags/LCS/"},{"name":"树状数组","slug":"树状数组","permalink":"https://blog.yzcthinktwice.com/tags/树状数组/"},{"name":"USACO","slug":"USACO","permalink":"https://blog.yzcthinktwice.com/tags/USACO/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF上蓝！","slug":"CF上蓝！","date":"2019-11-01T23:30:00.000Z","updated":"2019-11-03T13:58:40.879Z","comments":true,"path":"2019/11/02/CF上蓝！/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/02/CF上蓝！/","excerpt":"","text":"令人激动！ 自己动手，丰衣足食 CF round #597我终于上蓝了！ 每题都很有思路，除了最后的两个dp题 没有任何罚时，D甚至是洛谷原题（打井），并且没来卡kruskal。。。 挺幸运的，见这里 全球rating 272，涨了161分","categories":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}]},{"title":"CF1239D Catowice City","slug":"CF1239D Catowice City","date":"2019-10-29T14:11:01.000Z","updated":"2019-11-03T14:07:38.324Z","comments":true,"path":"2019/10/29/CF1239D Catowice City/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/10/29/CF1239D Catowice City/","excerpt":"","text":"CF1239D Catowice City 说在前面的：其实本题在答案的统计上并没有另两篇题解讲的那么麻烦 如果你真正搞懂了tarjan，你会明白如果一个强连通分量有出边，由于它dfs的性质，一定会继续向下遍历，直到找到一个没有出度的强连通分量 因此，第一个被找到的强联通分量一定是没有出度的！ 这样其余两篇题解的做法在过程上还可以被大幅简化 题解首先，一个很简单的问题：为什么n个不可以都是猫呢？ 因为必须至少有一个人 那么我们就必须把这个人放到无法产生任何影响的地方去 即一个人群（或仅一个人） 这个人群必须满足不会再对后续产生影响（因为连猫不合法，连人不如换个部分做人群） 即无出度 同时人群中也要保持强联通，因为如果有人不强联通，他就可以被分离出看成猫 因此问题转化为在一个有向图中找一个没有出度的强连通分量 在这个没有出度的强联通分量里的都是人，否则是猫 而我之前又说过第一个被找到的强联通分量一定是没有出度的，因此编号为1的强连通分量就是我们要找的 另外，显然的，如果只有一个强连通分量就是不合法的 代码#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e6+5; int h[N],st[N],lim,dfn[N],low[N],cnt,en,scc[N],sn,n,m,t,sz[N]; bool v[N]; struct edge{int n,v;}e[N]; inline void add(int x,int y){e[++en]=(edge){h[x],y};h[x]=en;} void tarjan(int x){ //tarjan模板 v[x]=1; st[++lim]=x; dfn[x]=low[x]=++cnt; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); } else{ if(v[y]) low[x]=min(low[x],dfn[y]); } } if(dfn[x]==low[x]){ int top; sn++; for(;;){ top=st[lim--]; v[top]=0; scc[top]=sn; sz[sn]++; //sz[]是强连通分量的大小 if(top==x) break; } } } void doit(){ read(n);read(m); sn=cnt=en=lim=0; for(int i=1;i&lt;=n;i++) h[i]=sz[i]=dfn[i]=0; for(int i=1,x,y;i&lt;=m;i++){ read(x);read(y); if(x==y) continue; //自己和自己的猫可忽略 add(x,y); } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); if(sn==1){ //只有一个强连通分量，不合法 puts(&quot;No&quot;); return ; } printf(&quot;Yes\\n%d %d\\n&quot;,sz[1],n-sz[1]); //sz[1]是人的个数，减一减得到猫数 for(int i=1;i&lt;=n;i++) if(scc[i]==1) write(i),putchar(&#39; &#39;);puts(&quot;&quot;); //第一个的都是人 for(int i=1;i&lt;=n;i++) if(scc[i]!=1) write(i),putchar(&#39; &#39;);puts(&quot;&quot;); //否则是猫 } signed main(){ read(t); while(t--) doit(); } (ps.本题清零初始化用memset会T在第三个点，要改用for)","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"缩点","slug":"缩点","permalink":"https://blog.yzcthinktwice.com/tags/缩点/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://blog.yzcthinktwice.com/tags/强连通分量/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3294 [SCOI2016]背单词","slug":"P3294 [SCOI2016]背单词","date":"2019-10-28T14:28:01.000Z","updated":"2019-11-03T12:32:31.509Z","comments":true,"path":"2019/10/28/P3294 [SCOI2016]背单词/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/10/28/P3294 [SCOI2016]背单词/","excerpt":"","text":"P3294 【SCOI2016】背单词 题意（已用贪心思路简化）给定n个单词$s_i$，请重排序列，使每个单词的存在的后缀都在前面 设$s_j$为离$s_i$最近的后缀字符串 定义$a_i=i-j$ $ans=min(\\sum a_i)$ 题解后缀显然没有前缀来的容易处理，所以自然想到翻转每个单词，建出trie树 下面是个例子： 6 a ca ea gda hda ifb 1. 建出trie树(红点是颠倒后每个单词的末尾，注意根也是）： void ins(char *s){ int x=0; for(int i=0;s[i];i++){ if(!a[x].nt[s[i]-&#39;a&#39;]) a[x].nt[s[i]-&#39;a&#39;]=++cnt; x=a[x].nt[s[i]-&#39;a&#39;]; } a[x].tag=1; //tag==1说明是红点 } 2. 重构树跳过白点，保留红点（白点无用，可以忽略） void doit(int x){ if(a[x].tag&amp;&amp;x){ g[last[x]].push_back(x); //g[x][]存重构树中点x的儿子们 last[x]=x; //last[x]是原树里x节点上方离它最近的红点（包括自己） } for(int i=0;i&lt;26;i++) if(a[x].nt[i]){ last[a[x].nt[i]]=last[x]; doit(a[x].nt[i]); } } 3. dfs遍历重构树，并将直接祖先相同的子树按节点数从小到大排序 inline bool cmp(const int &amp;x,const int &amp;y){ return sz[x]&lt;sz[y]; } void dfs(int x){ sz[x]=1; //sz[x]是以x为根的子树的大小 for(int i=0;i&lt;g[x].size();i++){ dfs(g[x][i]); sz[x]+=sz[g[x][i]]; } sort(g[x].begin(),g[x].end(),cmp); } 4. 根据题意遍历重构树，用dfs序得到答案void getans(int x){ int dfn=cnt++; //dfn是父亲的dfs序，cnt是节点自己的dfs序 for(int i=0;i&lt;g[x].size();i++){ ans+=cnt-dfn; //两者相减就是题意里的ai getans(g[x][i]); } } 思路背后的理由Q1. 为什么题意可以这样简化？三条规则，规则一显然是可以被避免且没有后两种优的，规则二可以看做规则三的特殊情况，简单起见，只考虑规则三即可 Q2. 排序的正确性？花费与最后一个填入的后缀有关,那么这个后缀的位置离当前位置越近越好,也就是应该有尽量少的单词夹在两个中间,所以我们应该选下属单词最少的那个进行拓展，而下属单词的多少就等价于重构树中子树的大小。 Q3. dfs序的正确性？这里引用 @坐山客 的题解： 考虑重新建树之后，i节点的子树中的所有节点的后缀都是i 如果同一深度上有不止一棵子树，那么我们先在一棵上取出一个叶子节点j，再取出一个根节点i，我们发现如果j&gt;i的话肯定不如i&lt;j优秀 因为调整之后i的子树上所有节点对花费的贡献-=子树大小，j对花费的贡献+1，所以我们可以看到j&gt;i的花费&lt;=i&gt;j的情况 最后我们经过所有的调整可以发现序列变成了dfs序 所以dfs序最优 完整代码将以上各步骤代码合在一起就是： tips. ANS要用long long!!! #include &lt;bits/stdc++.h&gt; using namespace std; inline int read(int &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } inline void write(long long x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int L=5.1e5+5; struct node{ //trie树的每个节点 int nt[26]; bool tag; }; long long ans; int cnt,last[L],sz[L],n; vector&lt;int&gt; g[L]; char s[L]; struct trie{ //trie及所需操作 node a[L]; int cnt; void ins(char *s){ //建树 int x=0; for(int i=0;s[i];i++){ if(!a[x].nt[s[i]-&#39;a&#39;]) a[x].nt[s[i]-&#39;a&#39;]=++cnt; x=a[x].nt[s[i]-&#39;a&#39;]; } a[x].tag=1; } void doit(int x){ //重构树 if(a[x].tag&amp;&amp;x){ g[last[x]].push_back(x); last[x]=x; } for(int i=0;i&lt;26;i++) if(a[x].nt[i]){ last[a[x].nt[i]]=last[x]; doit(a[x].nt[i]); } } }tr; inline bool cmp(const int &amp;x,const int &amp;y){ return sz[x]&lt;sz[y]; } void dfs(int x){ //重排重构树 sz[x]=1; for(int i=0;i&lt;g[x].size();i++){ dfs(g[x][i]); sz[x]+=sz[g[x][i]]; } sort(g[x].begin(),g[x].end(),cmp); } void getans(int x){ //统计答案 int dfn=cnt++; for(int i=0;i&lt;g[x].size();i++){ ans+=cnt-dfn; getans(g[x][i]); } } signed main(){ read(n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s); reverse(s,s+strlen(s)); //反转单词 tr.ins(s); } tr.a[0].tag=1; //根也是红点 tr.doit(0); dfs(0); getans(0); write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"字典树","slug":"字典树","permalink":"https://blog.yzcthinktwice.com/tags/字典树/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.yzcthinktwice.com/tags/贪心/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P2658 【汽车拉力比赛】","slug":"P2658 【汽车拉力比赛】","date":"2019-10-27T14:49:01.000Z","updated":"2019-11-03T12:32:16.255Z","comments":true,"path":"2019/10/27/P2658 【汽车拉力比赛】/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/10/27/P2658 【汽车拉力比赛】/","excerpt":"","text":"P2658 【汽车拉力比赛】并查集的思路很多人已经讲过了，我这里提供几个并查集方法的（常数）优化 路径压缩&amp;按秩合并 int getf(int x){ if(f[x]==x) return x; return f[x]=getf(f[x]); } void unite(int x,int y){ int fx=getf(x),fy=getf(y); if(fx==fy) return; if(rk[fx]&lt;rk[fy]) f[fx]=fy; else f[fy]=fx; if(rk[fx]==rk[fy]) rk[fx]++; } 路径压缩应该很多人都加了吧。。。 四个方向（上下左右）-&gt;两个方向（下右） 边是双向的，而且是网格图，因此是有个层次性的，无需重复地双向都unite 将每个路标的fa与第一个路标的fa比较 可以节约一半的getf 另外，感觉自己的码风还挺好理解的。。。 #include &lt;bits/stdc++.h&gt; using namespace std; inline int read(int &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } inline void write(int x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=505; int n,m,f[N*N],ans,rk[N*N],a[N][N],l,r; vector&lt;int&gt; tag; inline int hash(int x,int y){ return (x-1)*m+y; } inline int getf(int x){ if(f[x]==x) return x; return f[x]=getf(f[x]); //路径压缩 } inline void unite(int x,int y){ int fx=getf(x),fy=getf(y); if(fx==fy) return; if(rk[fx]&lt;rk[fy]) f[fx]=fy; //按秩合并 else f[fy]=fx; if(rk[fx]==rk[fy]) rk[fx]++; } inline bool check(int k){ for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) f[hash(i,j)]=hash(i,j),rk[hash(i,j)]=1; //并查集初始化 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ if(abs(a[i][j]-a[i+1][j])&lt;=k&amp;&amp;i+1&lt;=n) //向下unite(hash(i,j),hash(i+1,j)); if(abs(a[i][j]-a[i][j+1])&lt;=k&amp;&amp;j+1&lt;=m) //向右 unite(hash(i,j),hash(i,j+1)); } int fa=getf(tag[0]); //先得到第一个fa for(int i=1;i&lt;tag.size();i++) if(getf(tag[i])!=fa) //后面的与第一个比较 return 0; return 1; } signed main(){ read(n);read(m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ read(a[i][j]); r=max(r,a[i][j]); } for(int i=1;i&lt;=n;i++) for(int j=1,x;j&lt;=m;j++){ read(x); if(x) tag.push_back(hash(i,j)); //我用vector存路标 } while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; if(check(mid)) r=mid-1,ans=mid; else l=mid+1; } write(ans); } 另外，我这份代码是用c++交的，c++11以上会ce","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://blog.yzcthinktwice.com/tags/二分答案/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF再次被skip","slug":"CF再次被skip","date":"2019-10-26T15:22:01.000Z","updated":"2019-11-03T13:58:39.138Z","comments":true,"path":"2019/10/26/CF再次被skip/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/10/26/CF再次被skip/","excerpt":"","text":"时隔多日，今天又来打打CF，本来可以上蓝的说。。。 结果sb又把自己skip了，一晚上白给 自闭了QAQ","categories":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}]},{"title":"HDU5521 Meeting","slug":"HDU5521 Meeting","date":"2019-07-17T14:11:01.000Z","updated":"2019-11-10T09:06:07.797Z","comments":true,"path":"2019/07/17/HDU5521 Meeting/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/07/17/HDU5521 Meeting/","excerpt":"","text":"HDU5521 Meeting 题意： 给你n个点，它们组成了m个团，第i个团内有si个点，且每个团内的点互相之间距离为ti，问如果同时从点1和点n出发，最短耗时多少相遇 很明显题目给出的是个无负环的图，且要跑出单源最短路，那不就是个dij吗 大方向定下，但图该怎么建呢？ way1:给每个团内的所有点两两暴力建边 如图所示：黑的为点，红的为团，相同颜色的边长度相等 共$\\sum ^{m}_{i=1}\\dfrac {1}{2}s_{i}\\left( s_{i}-1\\right)$条边 而题面又告诉我们$\\sum ^{m}_{i=1}s_{i}&lt;=10^6$ 边数1e12这谁顶得住啊QuQ way2:我们再看上面这张图，发现同个团内类似三角形的东西其实是不需要的，因为反正有更近的直接连接的边，为啥还要再去绕个圈去松弛操作呢？ 这时候我们就可以在每个团中建个虚点，改无向图为有向图，即实点可以0消耗到虚点，虚点要ti到实点 正如下图所示：蓝色的为虚点，灰色的为从实点到虚点的路径，长度为0；彩色的为从虚点到实点的路径，长度为ti 边数是不是被减少到了$\\sum ^{m}_{i=1}2s_{i}$？是不是很优秀？ 建完图后，分别以1和n为起点，跑一遍最短路 $Ans=min\\{max\\{点1到点i最短路,点n到点i最短路|1&lt;=i&lt;=n\\}\\}$ ps.这道题十分毒瘤，我提交后曾四次PE，输出请注意你的空格以及换行，避免冗余 typedef long long ll; const int N=2e5+5,M=4e6+5; int en,T,n,m,h[N],cnt,ans[N],nm; ll dis[2][N]; struct node{ int x; ll v; inline bool operator &lt; (const node &amp;nt) const {return v&gt;nt.v;} }; struct edge{int n,v;ll w;}e[M]; //前向星存边 inline void add(const int &amp;x,const int &amp;y,const ll &amp;z){e[++en]=(edge){h[x],y,z};h[x]=en;} void dij(int s){ //一个堆优dijkstra模板 int pos; //小技巧，提前判断好当前最短路应存进哪个dis[]数组 if(s==1) pos=0; else pos=1; priority_queue&lt;node&gt; q; memset(dis[pos],66,sizeof dis[pos]); q.push((node){s,0}); dis[pos][s]=0; while(!q.empty()){ node x=q.top(); q.pop(); if(x.v!=dis[pos][x.x]) continue; for(int i=h[x.x];i;i=e[i].n){ int y=e[i].v; if(dis[pos][x.x]+e[i].w&lt;dis[pos][y]){ dis[pos][y]=dis[pos][x.x]+e[i].w; q.push((node){y,dis[pos][y]}); } } } } signed main(){ scanf(&quot;%d&quot;,&amp;T); while(T--){ en=nm=0; memset(h,0,sizeof h); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,t,s;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;t,&amp;s); int center=n+i; //虚点 for(int i=1,x;i&lt;=s;i++){ scanf(&quot;%d&quot;,&amp;x); add(x,center,0); //实点到虚点无长度 add(center,x,t); //虚点到实点有长度 } } dij(1); //从1跑 dij(n); //从n跑 ll MIN=dis[0][0]; for(int i=1;i&lt;=n;i++){ ll tp=max(dis[0][i],dis[1][i]); if(tp==MIN) ans[++nm]=i; //nm记录当前最优解共有几个，ans[]记录这些满足最优解的下标 if(tp&lt;MIN){ nm=1; //比当前最优解还优，刷新，重新从1开始 ans[1]=i; MIN=tp; } } printf(&quot;Case #%d: &quot;,++cnt); if(MIN==dis[0][0]) printf(&quot;Evil John\\n&quot;); //没有最优解-&gt;即无解 else{ printf(&quot;%lld\\n&quot;,MIN); for(int i=1;i&lt;=nm;i++) if(i&lt;nm) printf(&quot;%d &quot;,ans[i]); else printf(&quot;%d\\n&quot;,ans[i]); //最后一个后无空格 } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://blog.yzcthinktwice.com/tags/HDU/"},{"name":"最短路","slug":"最短路","permalink":"https://blog.yzcthinktwice.com/tags/最短路/"},{"name":"思维","slug":"思维","permalink":"https://blog.yzcthinktwice.com/tags/思维/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1194D 1-2-K Game","slug":"CF1194D 1-2-K Game","date":"2019-07-15T14:11:01.000Z","updated":"2019-11-13T13:03:15.605Z","comments":true,"path":"2019/07/15/CF1194D 1-2-K Game/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/07/15/CF1194D 1-2-K Game/","excerpt":"","text":"CF1194D 1-2-K Game 首先让我们考虑没有k的情况： 1. (n mod 3 =0)因为n可以被分解成若干个3相加 而每个3可以被分解为1+2或2+1 所以无论A出什么B都有方法应对 B胜 2. (n mod 3 =1)A可以先选择余数1 这样问题又回到了第一种情况 AB角色互换 A胜 3. (n mod 3 =2)与2同理，A先选2即胜 而现在多出来的这个k也可以看成是3的某个自然数倍数加上一个小于3的数 即$k\\equiv x\\left( mod3\\right)$ 我们再来对x分类讨论： 1. (x=0)此时的k就好像快速地切除1+2或2+1的回合 但对手总不会站着不动吧？ 我们知道B总是有方法使每一回合内(A+B)%3都等于1的 列举一下(k用3代替)： A:1 B:3 A:2 B:2 A:3 B:1 是不是每回合在mod3意义下都是相同的？ 那么若干个回合后如果无法实现上述方法了 即n%=k+1 如果n=k A获胜 否则情况又变回了无k的情况 %3判断即可 2. (x=1)此时k就好像有着能省略若干个回合功能的1 k就可有可无了 又回到了无k的情况 3. (x=2)与2同理 知道了这些，代码就很好写了： int n,k,t; signed main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); if(k%3){ if(n%3) puts(&quot;Alice&quot;); else puts(&quot;Bob&quot;); } else{ n%=k+1; if(n==k||n%3) puts(&quot;Alice&quot;); else puts(&quot;Bob&quot;); } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.yzcthinktwice.com/tags/博弈论/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]}]}