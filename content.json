{"meta":{"title":"THINK TWICE","subtitle":"YZC BLOG","description":"YZC BLOG","author":"yzc","url":"https://blog.yzcthinktwice.com"},"pages":[{"title":"","date":"2019-12-14T11:01:20.134Z","updated":"2019-12-14T11:01:20.134Z","comments":true,"path":"baidu_verify_U8QbXIxsvQ.html","permalink":"https://blog.yzcthinktwice.com/baidu_verify_U8QbXIxsvQ.html","excerpt":"","text":"U8QbXIxsvQ"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-23T16:29:35.816Z","comments":true,"path":"comment/index.html","permalink":"https://blog.yzcthinktwice.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-10-23T16:29:35.816Z","comments":false,"path":"client/index.html","permalink":"https://blog.yzcthinktwice.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-12-01T01:49:42.139Z","comments":false,"path":"bangumi/index.html","permalink":"https://blog.yzcthinktwice.com/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-23T16:29:35.817Z","comments":false,"path":"donate/index.html","permalink":"https://blog.yzcthinktwice.com/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-23T16:29:35.817Z","comments":false,"path":"lab/index.html","permalink":"https://blog.yzcthinktwice.com/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-23T16:29:35.821Z","comments":true,"path":"tags/index.html","permalink":"https://blog.yzcthinktwice.com/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-23T16:29:35.820Z","comments":true,"path":"rss/index.html","permalink":"https://blog.yzcthinktwice.com/rss/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-23T16:29:35.814Z","comments":false,"path":"about/index.html","permalink":"https://blog.yzcthinktwice.com/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-23T16:29:35.822Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://blog.yzcthinktwice.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-23T14:31:23.679Z","comments":false,"path":"music/index.html","permalink":"https://blog.yzcthinktwice.com/music/index.html","excerpt":"","text":"我的收藏 天气之子海上钢琴师","keywords":"喜欢的音乐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-23T16:29:35.822Z","comments":false,"path":"video/index.html","permalink":"https://blog.yzcthinktwice.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"links","date":"2019-10-27T15:11:06.000Z","updated":"2019-10-27T14:44:38.022Z","comments":true,"path":"links/index.html","permalink":"https://blog.yzcthinktwice.com/links/index.html","excerpt":"","text":"","keywords":"友人帐"}],"posts":[{"title":"CF1198F GCD Groups 2","slug":"CF1198F GCD Groups 2","date":"2020-01-06T11:13:06.000Z","updated":"2020-01-06T11:24:24.634Z","comments":true,"path":"2020/01/06/CF1198F GCD Groups 2/","link":"","permalink":"https://blog.yzcthinktwice.com/2020/01/06/CF1198F GCD Groups 2/","excerpt":"","text":"CF1198F GCD Groups 2 一道div1的F,神他喵居然是道玄学random_shuffle题？？？ 然鹅也是需要一些贪心思路的呢，朴素随机wa的概率还是高的呢 题解：考虑对打乱后序列正确性的判定及划分 我们注意到如果数$x$是某一组的gcd的倍数，那依照贪心的思路，它肯定不应该被放进那一组，而是放进另一组 于是我们可以做到$O(n)$判定 为什么这么random是对的呢？口胡一下就是一组数gcd=1的概率会随数的增加而呈指数级减小，完整证明可以看官方的 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int n,a[N],ans[N],b[N]; inline int gcd(int x,int y){ if(!y) return x; return gcd(y,x%y); } signed main(){ read(n); srand(time(NULL)); for(int i=1;i&lt;=n;i++) read(a[i]),b[i]=i; long long begin_time=clock(); while(clock()-begin_time&lt;CLOCKS_PER_SEC*0.45){ random_shuffle(b+1,b+1+n); int g1=0,g2=0; for(int i=1;i&lt;=n;i++){ int now=gcd(g1,a[b[i]]); if(now^g1){ g1=now; ans[b[i]]=1; } else{ g2=gcd(g2,a[b[i]]); ans[b[i]]=2; } } if(g1==1&amp;&amp;g2==1){ puts(&quot;YES&quot;); for(int i=1;i&lt;=n;i++) write(ans[i]),putchar(&#39; &#39;); return 0; } } puts(&quot;NO&quot;); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"},{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"乱搞","slug":"乱搞","permalink":"https://blog.yzcthinktwice.com/tags/乱搞/"},{"name":"随机","slug":"随机","permalink":"https://blog.yzcthinktwice.com/tags/随机/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1198E Rectangle Painting 2","slug":"CF1198E Rectangle Painting 2","date":"2020-01-06T11:13:05.000Z","updated":"2020-01-06T11:22:52.064Z","comments":true,"path":"2020/01/06/CF1198E Rectangle Painting 2/","link":"","permalink":"https://blog.yzcthinktwice.com/2020/01/06/CF1198E Rectangle Painting 2/","excerpt":"","text":"CF1198E Rectangle Painting 2 网络流好题，模型是二分图的最小覆盖 题解：首先要想到一个很显然的贪心，对于一个黑格，他要么是在纵向上被完全覆盖，要么是在横向上被完全覆盖，其中“完全覆盖”是指整行或整列都被一次性涂白 稍微思考一下，题目变成了在纵向上选一些列，在横向上选一些行，使得将他们完全覆盖后不存在一个黑格，问最少的选择数 我们可以将有黑格的行看成一个点集，将有黑格的列看成另一个点集，对于两者之间的交点，看成两个点集之间的连边，于是我们就得到了一个二分图 题目变成了二分图的最小覆盖问题 由于这张二分图的点数很和边数多，我们考虑离散与压缩，并用网络流进行优化，因为有一个重要定理：最小覆盖=最大流 离散后，对于一个矩形，我们只考虑它的四个边界，两个对立边界中所有点的代价全部赋给靠右（或下）的边界点，即（右减左，或下减上） 我们知道，网络流中点的代价是由超源和超汇给他的，于是从超源向行点连边，容量为其代价，从列点向超汇连边，容量为其代价，行点和列点之间的连边即两者是否相交，容量为无穷大 具体的，在代码实现中，我们将一条边界形如$[l,r]$的左闭右闭区间，修改成形如$[l,r+1)$的左闭右开区间 这是一个十分套路的方便操作，我们可以清楚的判定一个点到底是要被算进左边的代价还是右边的代价，并防止最右边被漏掉，详细可以看代码 代码轻微复杂，特先做出注释： .x.x=x1 .x.y=y1 .y.x=x2 .y.y=y2 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define pii pair&lt;int,int&gt; #define x first #define y second const int oo=0x7fffffff,N=405,M=N*N+5; int en=1,h[N],n,m,s,t,cur[N],d[N],ux[N],uy[N],uxn,uyn; pair&lt;pii,pii&gt; a[N]; //pii套pii~ struct edge{ int n,v,w; }e[M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } bool bfs(int s,int t){ for(int i=s;i&lt;=t;i++) d[i]=0,cur[i]=h[i]; queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(!d[y]&amp;&amp;e[i].w){ d[y]=d[x]+1; if(y==t) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int t){ if(x==t) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].w){ int tp=dfs(y,min(rest,e[i].w),t); rest-=tp; e[i].w-=tp; e[i^1].w+=tp; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(n);read(m); for(int i=1;i&lt;=m;i++){ read(a[i].x.x); read(a[i].x.y); read(a[i].y.x);a[i].y.x++; //改成左闭右开区间 read(a[i].y.y);a[i].y.y++; ux[++uxn]=a[i].x.x; uy[++uyn]=a[i].x.y; ux[++uxn]=a[i].y.x; uy[++uyn]=a[i].y.y; } ux[++uxn]=uy[++uyn]=n+1; //加一个边界，以防遗漏最右点 sort(ux+1,ux+1+uxn); sort(uy+1,uy+1+uyn); uxn=unique(ux+1,ux+1+uxn)-ux-1; //离散 uyn=unique(uy+1,uy+1+uyn)-uy-1; s=0,t=uxn+uyn+1; //超源超汇 for(int i=1;i&lt;=m;i++){ a[i].x.x=lower_bound(ux+1,ux+1+uxn,a[i].x.x)-ux; //离散后的坐标 a[i].x.y=lower_bound(uy+1,uy+1+uyn,a[i].x.y)-uy; a[i].y.x=lower_bound(ux+1,ux+1+uxn,a[i].y.x)-ux; a[i].y.y=lower_bound(uy+1,uy+1+uyn,a[i].y.y)-uy; for(int x=a[i].x.x;x&lt;a[i].y.x;x++) for(int y=a[i].x.y;y&lt;a[i].y.y;y++) add(x,y+uxn,oo),add(y+uxn,x,0); //添加交点的无穷边 } for(int i=1;i&lt;uxn;i++) add(s,i,ux[i+1]-ux[i]),add(i,s,0); //根据相邻边之间的距离，计算它的代价，并从超源向行点连边 for(int i=1;i&lt;uyn;i++) add(i+uxn,t,uy[i+1]-uy[i]),add(t,i+uxn,0); write(dinic(s,t)); //最大流=最小覆盖 }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P2149 [SDOI2009]Elaxia的路线","slug":"P2149 [SDOI2009]Elaxia的路线","date":"2020-01-06T11:13:03.000Z","updated":"2020-01-06T11:20:19.751Z","comments":true,"path":"2020/01/06/P2149 [SDOI2009]Elaxia的路线/","link":"","permalink":"https://blog.yzcthinktwice.com/2020/01/06/P2149 [SDOI2009]Elaxia的路线/","excerpt":"","text":"P2149 [SDOI2009]Elaxia的路线 最短路好题，需要一定思维 题解：首先要注意到一个性质：对于两点之间的最短路所构成的新有向图，将是一个DAG 这是很显然的，因为有环就会从终点转回起点，也就不优了 因此题目变成给出两个DAG，求他们的两条所属链，使得重合部分最大 对于样例数据，我们可以画出下面这张图，（其中蓝点是一组，红点是一组）： 于是我们可以选择其中一组点（这里选红点），从起点往终点遍历一次（红）边，注意是有向边，同时判断当前边是否是另外一个人可以同向而行（或逆向而行的边），记$f[x]$和$g[x]$，分别表示从（红色）起点到$x$路径上同向或逆向的最长相交路线长度，于是就变成了一个DAG上的DP问题，用拓扑排序解决，答案$ans=\\max\\{\\{f\\},\\{g\\}\\}$ 另外可能会有一个疑问，为什么一条边要么算在同向贡献里，要么算在逆向贡献里呢，因为一条边在所属DAG中，要么是从A到B，要么是从B到A，不然就成环了 然后再稍微提一下如何判断一条边是否在（x1-&gt;y1）或（x2-&gt;y2）的最短路径上，我们可以分别以x1,y1,x2,y2为源点跑一次最短路，若$dis_{x,y}=dis_{x,u}+dis_{v,u}$，则点$u$在(x-&gt;y)最短路径上（注意箭头是有向的） 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } #define x1 X #define x2 XX #define y1 Y #define y2 YY const int N=1505,M=2e4+5; int en,h[N],dis[N][4],n,m,x1,x2,y1,y2,ans,f[N],g[N],du[N]; bool exi[M]; struct edge{ int n,v,w; }e[M]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } struct node{ int x,v; inline bool operator &lt; (const node &amp;nt) const { return v&gt;nt.v; } }; void dij(int s,int op){ //朴素的最短路 priority_queue&lt;node&gt; q; q.push((node){s,0}); dis[s][op]=0; while(!q.empty()){ node x=q.top(); q.pop(); if(dis[x.x][op]^x.v) continue; for(int i=h[x.x];i;i=e[i].n){ int y=e[i].v; if(dis[x.x][op]+e[i].w&lt;dis[y][op]){ dis[y][op]=dis[x.x][op]+e[i].w; q.push((node){y,dis[y][op]}); } } } } void topo(){ queue&lt;int&gt; q; q.push(x1); while(!q.empty()){ int x=q.front(); q.pop(); ans=max(ans,max(f[x],g[x])); //答案取个最大值 for(int i=h[x];i;i=e[i].n) if(exi[i]){ int y=e[i].v; if(!--du[y]) q.push(y); if(dis[x][2]+e[i].w+dis[y][3]==dis[y2][2]) f[y]=max(f[y],f[x]+e[i].w); //两人同向而行 if(dis[x][3]+e[i].w+dis[y][2]==dis[y2][2]) g[y]=max(g[y],g[x]+e[i].w); //两人逆向而行 } } } signed main(){ read(n);read(m);read(x1);read(y1);read(x2);read(y2); for(int i=1,x,y,z;i&lt;=m;i++){ read(x);read(y);read(z); add(x,y,z); add(y,x,z); } memset(dis,60,sizeof dis); dij(x1,0); dij(y1,1); dij(x2,2); dij(y2,3); for(int x=1;x&lt;=n;x++) for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(dis[x][0]+e[i].w+dis[y][1]==dis[y1][0]){ exi[i]=1; //exi=exist 这条边是属于蓝点DAG的 du[y]++; //入度加一 } } topo(); write(ans); } ```","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://blog.yzcthinktwice.com/tags/最短路/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://blog.yzcthinktwice.com/tags/拓扑排序/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P1306 斐波那契公约数","slug":"P1306 斐波那契公约数","date":"2020-01-06T11:13:02.000Z","updated":"2020-01-06T11:19:00.060Z","comments":true,"path":"2020/01/06/P1306 斐波那契公约数/","link":"","permalink":"https://blog.yzcthinktwice.com/2020/01/06/P1306 斐波那契公约数/","excerpt":"","text":"P1306 斐波那契公约数 数学结论+矩乘简单优化 由于数学结论证明过于巧妙，这里仅放出我看的那篇题解 题解：转载：见这里 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int mod=1e8; struct mat{ int a[2][2]; mat(){memset(a,0,sizeof a);} inline mat operator * (const mat &amp;nt) const { mat res; for(int i=0;i&lt;=1;i++) for(int j=0;j&lt;=1;j++) for(int k=0;k&lt;=1;k++) res.a[i][j]=(1ll*res.a[i][j]+1ll*a[i][k]*nt.a[k][j]%mod)%mod; return res; } }A,B; mat mpow(mat x,int y){ mat res; for(int i=0;i&lt;=1;i++) res.a[i][i]=1; for(;y;y&gt;&gt;=1,x=x*x) if(y&amp;1) res=res*x; return res; } int n,m; signed main(){ read(n);read(m); A.a[0][0]=A.a[0][1]=1; B.a[0][1]=B.a[1][0]=B.a[1][1]=1; write((A*mpow(B,__gcd(n,m)-1)).a[0][0]); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://blog.yzcthinktwice.com/tags/矩阵乘法/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"转载","slug":"转载","permalink":"https://blog.yzcthinktwice.com/tags/转载/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1055F Tree and XOR","slug":"CF1055F Tree and XOR","date":"2020-01-06T11:13:01.000Z","updated":"2020-01-06T11:16:01.129Z","comments":true,"path":"2020/01/06/CF1055F Tree and XOR/","link":"","permalink":"https://blog.yzcthinktwice.com/2020/01/06/CF1055F Tree and XOR/","excerpt":"","text":"CF1055F Tree and XOR 思路算法难度双高的一道trie树题目，代码是我看别人的打的，然后使用瞪眼法思考了半天才有了懂了些门路 题解：先是对题意的一些简单转换：由于对于每一条xor链都可以看成是两个数（xor前缀）的结果，所以题目变成了对于长度为$n$的数列$val_i$（也就是xor前缀），求两两异或结果的第$k$小值 下面开始正文： 我们考虑以贪心的思路从高到低逐位推出ans每一位的值 构建trie树的同时，对于每一个$val_i$，我们计算出在当前答案进度下，与它配对所能得到0的方案数$cnt$，假如比当前剩余的$k$值小，就在$k$中减掉$cnt$，且当前位答案应为1，否则0 (上面的话可能很玄乎，毕竟是洛谷黑题CF2800pt呢，我争取再讲清楚点) 在某一层上，遍历时对于trie树上的两条链，我们发现会有三种情况，一种是小于答案的，我们会在减cnt时减掉并换一条链继续便利（因为另一条一定是更大的）；一种是大于答案的，我们不会去管（遍历）它；还有一种是（可能）等于答案的，也就是我们所要从上到下遍历的，注意到因为是两条链，因此对于每个$val_i$自己的链（代码中是$a[i]$），还要额外记一条能与它异或出答案的链（代码中是$b[i]$） 这样就是一个时空$O(62*N)$的算法 思路貌似有了呢，但代码难度还是十分高的 因为还有很重要的一点，由于朴素的trie内存会炸，所以我们要考虑滚存trie树（然后会使代码可读性极度下降，导致蒟蒻我一开始难以理解） trie树滚存的大致思路是由于一层最多只有$n$个点，所以我们只保存改层$n$个点的两个子节点，并对于每个$val_i$记两个指针$a[i]$和$b[i]$（上面有提到），一个是自己的，一个是要与自己匹配的链的，每次开始处理新的一层，处理指针数组都要清空，在根据上一层的指针数组构建出这一层的trie树，为啥这不会导致节点混乱呢？大概是因为如果上一层两个$val_i$指向同一个节点的话，他们在新建的节点中的“指向”也不会发生改变 这样，空间复杂度就降到了$O(n)$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e6+5; int n,a[N],b[N],ch[N][2],sz[N]; /*a[]b[]上文有讲，ch[i][0/1]表示val[i]的左右节点编号，sz[]表示有多少val[i]经过这个节点*/ long long sum,ans,k,val[N]; signed main(){ read(n);read(k); a[1]=b[1]=1; //1表示trie树的根节点 for(int i=2;i&lt;=n;i++){ int x;long long y; read(x);read(y); val[i]=y^val[x]; //父节点编号保证小于自己，所以可以直接O(1)维护xor前缀 a[i]=b[i]=1; } for(int i=61;i&gt;=0;i--){ int cnt=0;sum=0; for(int j=1;j&lt;=n;j++) ch[j][0]=ch[j][1]=sz[j]=0; //清空上一层的 for(int j=1;j&lt;=n;j++){ int &amp;p=ch[a[j]][val[j]&gt;&gt;i&amp;1]; //根据指针建新点 if(!p) p=++cnt; sz[a[j]=p]++; } for(int j=1;j&lt;=n;j++) sum+=sz[ch[b[j]][val[j]&gt;&gt;i&amp;1]]; //统计在“可能相等”中会产生几对0 int op=0; //op是当前位的答案 if(sum&lt;k) k-=sum,op=1,ans|=1ll&lt;&lt;i; for(int j=1;j&lt;=n;j++) b[j]=ch[b[j]][val[j]&gt;&gt;i&amp;1^op]; //看看b指针是否要换一条链 } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.yzcthinktwice.com/tags/贪心/"},{"name":"字典树","slug":"字典树","permalink":"https://blog.yzcthinktwice.com/tags/字典树/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P2048 [NOI2010]超级钢琴","slug":"P2048 [NOI2010]超级钢琴","date":"2020-01-06T11:13:00.000Z","updated":"2020-01-06T11:14:45.523Z","comments":true,"path":"2020/01/06/P2048 [NOI2010]超级钢琴/","link":"","permalink":"https://blog.yzcthinktwice.com/2020/01/06/P2048 [NOI2010]超级钢琴/","excerpt":"","text":"P2048 [NOI2010]超级钢琴 代码难度低，但思维难度较高且极为巧妙的一道题 题解：超级和弦有很多选择，但对于左端点只有$n-l+1$种选择 先思考一个子问题：固定一个左端点$x$，如何$O(1)$在$[x+l-1,x+r-1]$内选择右端点$y$使得$\\sum\\limits_{i=x}^{y}a_i$最大？ 考虑前缀和$pre_i=\\sum\\limits_{j=1}^{i}a_j$，则$\\sum\\limits_{i=x}^{y}a_i=pre_y-pre_{x-1}$ 由于左端点$x$固定所以$pre_{x-1}$是定值，所以只需要找出$pre_y$的最小值的下标即可 这就变成了一个无修改的rmq问题，用st表可以做到$O(1)$解决 这样我们可以$O(n)$枚举左端点并通过st表算出最优的右端点，这样我们就得到了$n-l+1$条左端点各异的超级和弦，并且显然的，其中一条一定是全局最优的 考虑通过这些和弦算出次优的 对于不是最优的和弦，我们保留，对于最优和弦，我们拆分 因为最优和弦的右端点就好比二分答案的指针，中间找过了就往左右两边找，分裂出两个左端点不变但右端点改变的局部最优和弦 考虑将这两条和弦与其它保留的和弦比较，选出当前最优的 显然的，这种方法是具有普遍性的，因此可以推广开去，求出前$k$条最优和弦 另外，对于“比较最优和弦”这一操作，我们可以采用优先队列快速实现 由于一次最多出两条新的，因此总复杂度是$O(k\\log(n+k))$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=5e5+5; int n,m,l,r,f[N][21]; long long ans,pre[N]; struct exstr{ int x,l,r,a; /*x=start l=left_limit_of_map_range r=right_limit_of_map_range a=aim*/ inline bool operator &lt; (const exstr &amp;nt) const { return pre[a]-pre[x-1]&lt;pre[nt.a]-pre[nt.x-1]; } }; priority_queue&lt;exstr&gt; q; int max(int x,int y){ return pre[x]&gt;pre[y]?x:y; } void init(){ for(int i=1;i&lt;=n;i++) f[i][0]=i; //存的是下标，比较的是前缀和 int lg=log2(n); for(int j=1;j&lt;=lg;j++) for(int i=1;i&lt;=n;i++) if(i+(1&lt;&lt;j)-1&lt;=n) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); } int rmq(int l,int r){ int k=log2(r-l+1); return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]); } exstr mk(int x,int l,int r){ return (exstr){x,l,r,rmq(l,r)}; //在[l,r]区间里找个最优的右端点 } signed main(){ read(n);read(m);read(l);read(r); for(int i=1,x;i&lt;=n;i++) pre[i]=pre[i-1]+read(x); //搞出前缀和 init(); //预处理st表 for(int i=1;i+l-1&lt;=n;i++) //枚举左端点 q.push(mk(i,i+l-1,min(i+r-1,n))); while(m--){ exstr x=q.top(); q.pop(); ans+=pre[x.a]-pre[x.x-1]; if(x.a^x.l) q.push(mk(x.x,x.l,x.a-1)); //没碰到左端点就拆 if(x.a^x.r) q.push(mk(x.x,x.a+1,x.r)); //没碰到右端点就拆 } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"st表","slug":"st表","permalink":"https://blog.yzcthinktwice.com/tags/st表/"},{"name":"优先队列","slug":"优先队列","permalink":"https://blog.yzcthinktwice.com/tags/优先队列/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"开学!","slug":"开学!","date":"2020-01-01T23:00:00.000Z","updated":"2020-01-06T11:29:02.389Z","comments":true,"path":"2020/01/02/开学!/","link":"","permalink":"https://blog.yzcthinktwice.com/2020/01/02/开学!/","excerpt":"","text":"今天开学！","categories":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}],"tags":[],"keywords":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}]},{"title":"CF455B A Lot of Games","slug":"CF455B A Lot of Games","date":"2019-12-31T15:58:02.000Z","updated":"2020-01-06T11:11:14.865Z","comments":true,"path":"2019/12/31/CF455B A Lot of Games/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/31/CF455B A Lot of Games/","excerpt":"","text":"CF455B A Lot of Games 一道trie树上博弈好题，考察了对于博弈状态的设计 我是从这篇题解得到启示的 题解：先只考虑其中一场博弈 对于n个单词建出它们的trie树 对于trie树上的每个节点设计四种状态：必胜，必败，胜败主动（由自己决定），胜败被动（由对手决定） 由题意可得，叶子结点都是必胜态的，然后就会有四种转移： 若儿子中有主动点，那么对手肯定会走那个点，所以当前点是被动点 若儿子中必胜必败两种点都有，那么对手可以随便选，所以当前点是被动点 若儿子中只有被动点，那么对手是真的被动，所以当前点是主动点 若儿子只有必胜点，当前点肯定是必败点；若儿子只有必败点，当前点肯定是必胜点 由下往上处理出每个点的博弈态后，我们对于trie的根节点（可以看成是把对手当成已经决策过的先手）的状态再次进行分类讨论： 先手必败会有三种情况： 根节点是个主动点 那么对手可以先故意输k-1局保证主动然后再赢一局 根节点是个必胜点 那么无论怎么玩都是对手赢 根节点是个必败点但是k是个偶数 那么两人交替着当先手，偶数局后正好轮到对手获胜 其余情况都是先手必胜 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int cnt,n,k; char s[N]; struct node{ int nxt[26],s; /* s表示该节点的博弈状态=0/1/2/3 =0:必败 =1:必胜 =2:主动胜败 =3:被动胜败 */ }a[N]; void ins(char *s){ int x=0; for(int i=0;s[i];i++){ int k=s[i]-&#39;a&#39;; if(!a[x].nxt[k]) a[x].nxt[k]=++cnt; x=a[x].nxt[k]; } } void dfs(int x){ int son=0,cnt[4]={0}; for(int i=0;i&lt;26;i++) if(a[x].nxt[i]){ dfs(a[x].nxt[i]); son++; cnt[a[a[x].nxt[i]].s]++; } if(!son){ a[x].s=1; return ; } if(cnt[0]) a[x].s=1; if(cnt[1]) a[x].s=0; if(cnt[0]&amp;&amp;cnt[1]) a[x].s=3; if(cnt[3]==son) a[x].s=2; if(cnt[2]) a[x].s=3; } signed main(){ read(n);read(k); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s); ins(s); } dfs(0); if(a[0].s==2){ puts(&quot;Second&quot;); return 0; } if(a[0].s==0&amp;&amp;!(k&amp;1)){ puts(&quot;Second&quot;); return 0; } if(a[0].s==1){ puts(&quot;Second&quot;); return 0; } puts(&quot;First&quot;); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.yzcthinktwice.com/tags/博弈论/"},{"name":"字典树","slug":"字典树","permalink":"https://blog.yzcthinktwice.com/tags/字典树/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1270X Good Bye 2019","slug":"CF1270X Good Bye 2019","date":"2019-12-30T15:59:04.000Z","updated":"2019-12-30T13:35:14.493Z","comments":true,"path":"2019/12/30/CF1270X Good Bye 2019/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1270X Good Bye 2019/","excerpt":"","text":"CF1270X Good Bye 2019 2019年的最后一场CF，参加的人很多，按理说上分更容易，但我没有把握住机会，差点变成goodbye rating 2019 作为难得的9题场，题目质量很高，囊括了几何题，构造题，交互题，数学题等等，于是我来统一写篇题解，包括题A、B、C、D、E、G。（F先咕着，我看懂再说） CF1270A Card Game题意：两个人打牌，牌可以重复出，保证牌的点数不同，点数大的人获胜 题解：水出天际的一道题，看看第一个人那有没有牌n就行了 代码：void doit(){ int n,a,b; bool flag=0; read(n);read(a);read(b); for(int i=1,x;i&lt;=a;i++){ read(x); if(x==n) flag=1; } for(int i=1,x;i&lt;=b;i++) read(x); if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } CF1270B Interesting Subarray题意：给出一个序列，请构造出一个所给序列的子序列，使得该子序列中的最大值-最小值&gt;=子序列长度 题解：由于没有长度限制，因此只要$O(n)$扫一遍判断每个长度为2的子序列（也就是相邻的两个数）是否合法即可 代码：void doit(){ int n,flag=0; read(n); for(int i=1;i&lt;=n;i++){ read(a[i]); if(i==1) continue; if(abs(a[i]-a[i-1])&gt;1) flag=i-1; } if(flag){ puts(&quot;YES&quot;); write(flag);putchar(&#39; &#39;);write(flag+1);puts(&quot;&quot;); } else{ puts(&quot;NO&quot;); } } CF1270C Make Good题意：给出一个长度为$n$的序列$a_1…a_n$，请随意添加$k$个数$a_{n+1}…a_{n+k}$，满足$k\\in[0,3]$，使得$\\sum\\limits_{i=1}^{n+k}a_i=2\\cdot\\oplus_{i=1}^{n+k}a_i$ 题解：因为没有要求最小化$k$，我们可以考虑这样构造：先添加一个数$a_{n+1}$使得$\\oplus_{i=1}^{n+1}a_i=0$，由于异或的性质，这是十分容易实现的：$a_{n+1}=\\oplus_{i=1}^{n}a_i$ 此时可以把这$n+1$个数看做常数，我们还要添加的数$a_{n+2}$为未知数，就得到了一个一元一次方程$\\sum\\limits_{i=1}^{n+1}+a_{n+2}=2*a_{n+2}$，依式化简算出就可以得到$a_{n+2}$ 这样，无论给出怎样的序列$a$，都只需要添加至多两个数$a_{n+1}$和$a_{n+2}$就可以满足条件 代码：void doit(){ int n,sum=0,p=0; read(n); for(int i=1,x;i&lt;=n;i++) p^=read(x),sum+=x; puts(&quot;2&quot;); write(p),putchar(&#39; &#39;);write(p+sum); puts(&quot;&quot;); } CF1270D Strange Device看这里 CF1270E Divide Points看这里 CF1270G Subset with Zero Sum看这里","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"总集","slug":"总集","permalink":"https://blog.yzcthinktwice.com/tags/总集/"},{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1270D Strange Device","slug":"CF1270D Strange Device","date":"2019-12-30T15:59:03.000Z","updated":"2019-12-30T13:28:45.703Z","comments":true,"path":"2019/12/30/CF1270D Strange Device/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1270D Strange Device/","excerpt":"","text":"CF1270D Strange Device 思维题，交互题，现场脑抽没有打出脑子中的正确算法，导致排名并不是很高，直接导致了新年上紫失败 题意：给出$n$和$k$，让你求$m$ 其中$n$表示$n$个数，$k$表示每次你可以询问的数的个数，$m$是对于你的询问，交互器返回的是你所询问$k$个数中的第$m$小数 特别的，n个数互不相同 规定询问格式为： $k$个$\\in[1,n]$互不相同的数，表示下标 规定交互器回答你的询问的格式为： 两个数$x$和$y$，其中$x$是这$k$个数中第$m$小数的下标，$y=a_x$ 题解：题目给出了$n$个数，但其实我们只需要用到$k+1$个数 为了方便解释，规定$ask(x) [x\\in[1,k+1]]$表示一次从$1$到$k+1$的询问，但不包括下标$x$ 先$ask(k+1)$，记返回的$x$为$pos$，$y$为$p$ 再$ask(pos)$，记返回的$y$为$q$ 通过两次询问我们可以得出$a_{pos}$和$a_{k+1}$大小关系 判断方法为：若$q&gt;p$则$a_{k+1}&gt;a_{pos}$，否则$a_{k+1}&lt;a_{pos}$ 为什么呢？可以类比一下平均数，更换一个数就是在修改平均数的权重 然后再做$k-1$次询问$ask(x) [x\\in[1,k] | x\\neq pos]$ 记每次询问的到的$y$为$num$，前$k$个数中比$p$小的数有$cnt$个 根据上文得出的$a_{pos}$和$a_{k+1}$大小关系进行如下分类讨论： $a_{pos}&lt;a_{k+1}$ 此时若$num=p$则说明只是在比$p$小的数里做了个交换，$cnt+1$ $a_{pos}&gt;a_{k+1}$ 此时若$num!=p$则说明是从比$p$小的数里选了个数做交换，$cnt+1$ 最后的答案$m=cnt+1$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } int n,k,ka,kb,pa,pb,ans,op; void print(int x){ printf(&quot;? &quot;); for(int i=1;i&lt;=k+1;i++) if(i^x) printf(&quot;%d &quot;,i); puts(&quot;&quot;); cout.flush(); } signed main(){ read(n);read(k); print(k+1); read(ka);read(kb); print(ka); read(pa);read(pb); op=pb&gt;kb; for(int i=1,x,y;i&lt;=k;i++) if(i^ka){ print(i); read(x);read(y); if(!op){ if(y==kb) ans++; } else{ if(y^kb) ans++; } } printf(&quot;! %d\\n&quot;,ans+1); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"构造","slug":"构造","permalink":"https://blog.yzcthinktwice.com/tags/构造/"},{"name":"交互","slug":"交互","permalink":"https://blog.yzcthinktwice.com/tags/交互/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1270E Divide Points","slug":"CF1270E Divide Points","date":"2019-12-30T15:59:02.000Z","updated":"2019-12-30T13:28:36.785Z","comments":true,"path":"2019/12/30/CF1270E Divide Points/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1270E Divide Points/","excerpt":"","text":"CF1270E Divide Points 神仙题，需要一些几何和代数的直觉 题意：给出$n$个直角坐标系上的点，两两连边，现要求将它们分成两个非空点集，使得同点集连边的长度不会在异点集连边的长度中有相同的出现 题解：首先要意识到这么一种划分方式：设点坐标$(x,y)$，特征值$p=x+y$，将$p$的奇偶性相同的点划分在一起 为什么这样是正确的呢？因为$p$奇偶性相同的点之间的连边一定是偶数的（指不开根号），否则一定是奇数的，这一点有疑问的话可以用代数简单的证明得到 问题看起来就这样解决了，但题目还有一个要求：点集非空 这样当所有的$p$都是奇数或都是偶数时就不合法了 怎么办呢？下面开始神仙操作了： 考虑将原图形等比例缩小一半（指面积），此时不变的是边之间的大小关系，改变的是每个点的$p$值的奇偶性，这保证了继续使用上述划分方法的正确性 那如何让图形缩小一半呢？这就要用到切比雪夫距离了 具体的，若原来的点$A$坐标$(x,y)$，那它变换后的对应点$A’$就是$(\\frac{x+y}{2},\\frac{x-y}{2})$ 形象的，可以看下下面这张图： （其实不仅缩小了，还旋转了45度呢） 为啥这么神奇呢？我也不知道哈qwq 这样就可以对图形一直做这种变换，直到有个点的$p$的奇偶性不同于其它的点为止 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e3+5; int a[N],n,x[N],y[N]; vector&lt;int&gt; odd; signed main(){ read(n); for(int i=1;i&lt;=n;i++){ read(x[i]);read(y[i]); a[i]=x[i]+y[i]; if(a[i]&amp;1) odd.push_back(i); } while(odd.empty()||odd.size()==n){ odd.clear(); for(int i=1;i&lt;=n;i++){ int xx=x[i],yy=y[i]; x[i]=xx+yy&gt;&gt;1; y[i]=xx-yy&gt;&gt;1; a[i]=x[i]+y[i]; if(a[i]&amp;1) odd.push_back(i); } } write(odd.size());puts(&quot;&quot;); for(int i=0;i&lt;odd.size();i++) write(odd[i]),putchar(&#39; &#39;); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"},{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"构造","slug":"构造","permalink":"https://blog.yzcthinktwice.com/tags/构造/"},{"name":"几何","slug":"几何","permalink":"https://blog.yzcthinktwice.com/tags/几何/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1270G Subset with Zero Sum","slug":"CF1270G Subset with Zero Sum","date":"2019-12-30T15:59:01.000Z","updated":"2019-12-30T13:29:14.900Z","comments":true,"path":"2019/12/30/CF1270G Subset with Zero Sum/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1270G Subset with Zero Sum/","excerpt":"","text":"CF1270G Subset with Zero Sum 巧妙的思维、构造题 题意：给出一个长度为$n$的序列$a$，其中$a_i\\in[i-n,i-1]$ 现让你从中选出几个数，使得他们的和为0 题解：发现$a_i$的范围很特殊，于是我们可以考虑把它拆成$i$和$i-a_i$两部分，其中$i$是它的正贡献，$i-a_i$是它的负贡献 构造方法是这样的：将$a_i$看作一个节点，从任意一个点出发，贪心的找可以直接用正贡献抵消它的负贡献的点，再依次往下找点，直到回到了一个已经走过的点 抽象的，可以把这$n$个点看作一张有向图（基环树），问题就变成了在上面找个简单环，$O(n)$即可解决 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e6+5; int n,a[N]; bool v[N]; void doit(){ vector&lt;int&gt; ans; read(n); for(int i=1;i&lt;=n;i++){ a[i]=i-read(a[i]); v[i]=0; } int aim=1; for(;!v[aim];aim=a[aim]) v[aim]=1; ans.push_back(aim); for(int i=a[aim];i^aim;i=a[i]) ans.push_back(i); write(ans.size());puts(&quot;&quot;); for(int i=0;i&lt;ans.size();i++) write(ans[i]),putchar(&#39; &#39;);puts(&quot;&quot;); } signed main(){ int t; read(t); while(t--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"构造","slug":"构造","permalink":"https://blog.yzcthinktwice.com/tags/构造/"},{"name":"基环树","slug":"基环树","permalink":"https://blog.yzcthinktwice.com/tags/基环树/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF700B Connecting Universities","slug":"CF700B Connecting Universities","date":"2019-12-30T15:58:02.000Z","updated":"2019-12-30T13:29:22.741Z","comments":true,"path":"2019/12/30/CF700B Connecting Universities/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF700B Connecting Universities/","excerpt":"","text":"CF700B Connecting Universities 巧妙的思维题 题解：直接硬配求贡献的方法显然是难以实现的，所以我们需要转换思路： 考虑计算每条边的贡献，边的贡献和就是我们的答案 举个例子，看下面这张图： 红边将大学分成了左右两个点集，在所有的配对方案中，从左右点集各选一个点配对肯定是最优先考虑的 为什么呢？因为同一集合中选点，距离都是固定的，但从不同集合选点，还能够额外加上一条红边的价值 也就是说贪心思路就是要最大化左右两端配对的方案数 如果设左点集为$A$，右点集为$B$，显然的，连接它们的边的价值就是$\\min(|A|,|B|)$ 因为$|A|+|B|=2*k$，所以只需要知道每条边一侧的大学数 又因为这是一棵树，从下往上统计一个点子树内的大学数可以了 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=2e5+5; int en,n,m,h[N],a[N]; long long ans; struct edge{ int n,v; }e[N&lt;&lt;1]; void add(int x,int y){ e[++en]=(edge){h[x],y}; h[x]=en; } void dfs(int x,int fa){ for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==fa) continue; dfs(y,x); a[x]+=a[y]; } ans+=min(a[x],m-a[x]); } signed main(){ read(n);read(m);m&lt;&lt;=1; for(int i=1,x;i&lt;=m;i++) a[read(x)]=1; for(int i=1,x,y;i&lt;n;i++){ read(x);read(y); add(x,y); add(y,x); } dfs(1,0); write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1268B Domino for Young","slug":"CF1268B Domino for Young","date":"2019-12-30T15:57:02.000Z","updated":"2019-12-30T13:28:02.771Z","comments":true,"path":"2019/12/30/CF1268B Domino for Young/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1268B Domino for Young/","excerpt":"","text":"CF1268B Domino for Young 一道画图猜性质题 题解：首先，十分贪心的，偶数高度列可以自己消完自己，奇数高度列则会剩下最底下一个 手动画图可以很快发现这么一个性质：若两个奇数高度列之间有连续的偶数个偶数高度列，那么这两个奇数高度列的最底下也会被消掉，也就是说，可以多放一个骨牌 于是我们就可以开一个栈，记录奇数高度列出现的位置，如果栈顶与当前的距离为偶数就可弹掉，答案加一 又因为下标奇偶性加上一个偶数不会改变，所以栈里只要存下标是奇还是偶就行了 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } int n; long long ans; stack&lt;int&gt; s; signed main(){ read(n); for(int i=1,x;i&lt;=n;i++){ read(x); ans+=x&gt;&gt;1; if(x&amp;1){ if(!s.empty()&amp;&amp;(s.top()^i&amp;1)){ s.pop(); ans++; } else s.push(i&amp;1); } } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1263E Editor","slug":"CF1263E Editor","date":"2019-12-30T15:56:02.000Z","updated":"2019-12-30T13:27:38.720Z","comments":true,"path":"2019/12/30/CF1263E Editor/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1263E Editor/","excerpt":"","text":"CF1263E Editor 难度不大，比较有意思的一道思维题 题解：首先是括号序列的经典操作：将左括号看作1，将右括号看作-1 按照该操作，显然的，合法的括号序列的前缀应该都是大于等于0的，且总和等于0 换句话说，若要判断当前括号序列是否合法，就要知道它的最小前缀是否小于0，是则不合法；还要知道总和是否等于0，否则不合法 在合法的基础上，概括号序列的最大深度就是最大前缀 数字和，前缀最大，前缀最小 将上面三样东西拿线段树维护一下就解决问题了 另外，对于字符的修改，在线段树上的表现就是单点赋值（1/-1/0） 由于只有全局查询，甚至都不用写query函数 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e6+5; int n,a[N&lt;&lt;2],mi[N&lt;&lt;2],ma[N&lt;&lt;2]; char s[N]; void pushup(int x){ a[x]=a[x&lt;&lt;1]+a[x&lt;&lt;1|1]; mi[x]=min(mi[x&lt;&lt;1],a[x&lt;&lt;1]+mi[x&lt;&lt;1|1]); ma[x]=max(ma[x&lt;&lt;1],a[x&lt;&lt;1]+ma[x&lt;&lt;1|1]); } void up(int x,int l,int r,int p,int v){ if(l==r){ a[x]=mi[x]=ma[x]=v; return ; } int mid=l+r&gt;&gt;1; if(p&lt;=mid) up(x&lt;&lt;1,l,mid,p,v); else up(x&lt;&lt;1|1,mid+1,r,p,v); pushup(x); } signed main(){ read(n); scanf(&quot;%s&quot;,s+1); for(int i=1,pos=1;i&lt;=n;i++){ if(s[i]==&#39;L&#39;) pos-=(pos&gt;1); else if(s[i]==&#39;R&#39;) pos++; else{ if(s[i]==&#39;(&#39;) up(1,1,n,pos,1); else if(s[i]==&#39;)&#39;) up(1,1,n,pos,-1); else up(1,1,n,pos,0); } if(a[1]||mi[1]&lt;0) write(-1); else write(ma[1]); putchar(&#39; &#39;); } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"线段树","slug":"线段树","permalink":"https://blog.yzcthinktwice.com/tags/线段树/"},{"name":"括号序列","slug":"括号序列","permalink":"https://blog.yzcthinktwice.com/tags/括号序列/"},{"name":"前缀","slug":"前缀","permalink":"https://blog.yzcthinktwice.com/tags/前缀/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1266D Decreasing Debts","slug":"CF1266D Decreasing Debts","date":"2019-12-30T15:55:02.000Z","updated":"2019-12-30T13:28:14.534Z","comments":true,"path":"2019/12/30/CF1266D Decreasing Debts/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1266D Decreasing Debts/","excerpt":"","text":"CF1266D Decreasing Debts 巧妙的思维题 题解：为了方便表述，我设$in(x)$表示点$x$的入边的权值和，$out(x)$表示点$x$的出边的权值和 在此题中，我们需要发现如果一条出边$$满足$in(u)=0$，$out(v)=0$，且起点$u$固定，那么只要终点$v$合法就可以随意连（这里的“合法”指的是这条边的权值小于$in(v)$），入边同理。 为什么呢？因为如果满足上述条件，那么此时能与边$$发生关系的边$$一定是与它无公共端点的，此时会变成$$，也就是上文所说的“随便连” 为了让图中只存在这样的边，我们需要消去形如$u-&gt;v-&gt;w$的边 具体地，消去的方法就是让$in(v)$和$out(v)$同时减去$\\min(in(v),out(v))$ 这样，点$v$就会偏向$u$或$w$，甚至直接消失 现在，图上就只剩下两种点了，我们把它划分成两个点集： 只有出边的点集A 只有入边的点集B 只要双指针跑一遍（两个点集分别一个），将它们随意配对，用点集B的$in()$去抵消点集A的$out()$只需满足最后所有的$in()$和$out()$都等于0就好了，而每进行一次抵消，就是连一次边，消一个（或两个）点 为什么一定有方案存在，使得A和B可以同时消完呢？因为$\\sum\\limits_{u\\in A} out(u)=\\sum\\limits_{u\\in B} in(u)$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=1e5+5; int n,m,in[N],out[N]; vector&lt;int&gt; a,b; struct edge{ int x,y,z; }; vector&lt;edge&gt; ans; signed main(){ read(n);read(m); for(int i=1,x,y,z;i&lt;=m;i++){ read(x);read(y);read(z); out[x]+=z; in[y]+=z; } for(int i=1;i&lt;=n;i++){ int tp=min(in[i],out[i]); in[i]-=tp; out[i]-=tp; if(in[i]) b.push_back(i); if(out[i]) a.push_back(i); } for(int i=0,j=0;i&lt;a.size()&amp;&amp;j&lt;b.size();){ int tp=min(out[a[i]],in[b[j]]); out[a[i]]-=tp; in[b[j]]-=tp; ans.push_back((edge){a[i],b[j],tp}); if(out[a[i]]==0) i++; if(in[b[j]]==0) j++; } write(ans.size());puts(&quot;&quot;); for(int i=0;i&lt;ans.size();i++){ write(ans[i].x);putchar(&#39; &#39;); write(ans[i].y);putchar(&#39; &#39;); write(ans[i].z);puts(&quot;&quot;); } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"图论","slug":"图论","permalink":"https://blog.yzcthinktwice.com/tags/图论/"},{"name":"构造","slug":"构造","permalink":"https://blog.yzcthinktwice.com/tags/构造/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1067A Array Without Local Maximums","slug":"CF1067A Array Without Local Maximums","date":"2019-12-30T15:54:02.000Z","updated":"2019-12-30T13:27:51.899Z","comments":true,"path":"2019/12/30/CF1067A Array Without Local Maximums/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1067A Array Without Local Maximums/","excerpt":"","text":"CF1067A Array Without Local Maximums 常规dp题 题解：设$f[i][j][0/1]$表示前$i$个数，第$i$个数选$j$，第$i-1$个数是否大于等于第$i$个数的方案数，显然的，1表示合法，0表示不合法 （注意：题目中有-1的条件，其实处理起来只需要把定值$a[i]$换成一层从1到200的循环枚举即可，下文中统一用$a[i]$替代） 初始化$f[1][a[i]][0]=1$ 转移考虑分类讨论： 循环枚举第$i-1$个数为$k$，那么$j$与$k$会有三种大小关系： j等于k 对$f[i][j][1]$造成影响，因为$j$对于$k$是合法的，前面一位只要选$k$就合法，所以$f[i][j][1]+=f[i-1][k][0]+f[i-1][k][1]$ j小于k 对$f[i][j][1]$造成影响，因为$j$对于$k$是不合法的，$k$的前一位对于$k$就一定要是合法的，所以$f[i][j][1]+=f[i-1][k][1]$ j大于k 对$f[i][j][0]$造成影响，因为$j$对于$k$是合法的，前面一位只要选$k$就合法，所以$f[i][j][0]+=f[i-1][k][0]+f[i-1][k][1]$ 由此，可以得出如下dp代码： for(int j=1;j&lt;=200;j++){//当前位 for(int k=1;k&lt;=200;k++){//上一位 if(k==j) f[i][j][1]=(f[i][j][1]+f[i-1][k][0]+f[i-1][k][1])%mod; if(k&gt;j) f[i][j][1]=(f[i][j][1]+f[i-1][k][1])%mod; if(k&lt;j) f[i][j][0]=(f[i][j][0]+f[i-1][k][0]+f[i-1][k][1])%mod; } } 这样的dp是$O(200^2*n)$的，但不难看出这可以用前缀和优化 维护$f[i][j][0/1]$的前缀和，再合并一下dp方程，我们就可以$O(1)$算出$f[i][j][0/1]$，复杂度就降为$O(200*n)$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int mod=998244353; const int N=1e5+5,M=205; int n,a[N],f[N][M][2],ans,sum[M][2]; int calc(int l,int r,int op){ return ((sum[r][op]-sum[l-1][op])%mod+mod)%mod; } signed main(){ read(n); for(int i=1;i&lt;=n;i++) read(a[i]); if(a[1]==-1) for(int i=1;i&lt;=200;i++) f[1][i][0]=1; else f[1][a[1]][0]=1; for(int i=1;i&lt;=200;i++){ sum[i][0]=sum[i-1][0]+f[1][i][0]; sum[i][1]=sum[i-1][1]+f[1][i][1]; } for(int i=2;i&lt;=n;i++){ if(a[i]==-1){ for(int j=1;j&lt;=200;j++){ f[i][j][1]=(calc(j,j,0)+calc(j,200,1))%mod; f[i][j][0]=(calc(1,j-1,0)+calc(1,j-1,1))%mod; } } else{ f[i][a[i]][1]=(calc(a[i],a[i],0)+calc(a[i],200,1))%mod; f[i][a[i]][0]=(calc(1,a[i]-1,0)+calc(1,a[i]-1,1))%mod; } for(int j=1;j&lt;=200;j++){ sum[j][0]=sum[j-1][0]+f[i][j][0]; sum[j][1]=sum[j-1][1]+f[i][j][1]; } } if(a[n]==-1) for(int i=1;i&lt;=200;i++) ans=(ans+f[n][i][1])%mod; else ans=f[n][a[n]][1]; write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1271D Portals","slug":"CF1271D Portals","date":"2019-12-30T15:50:02.000Z","updated":"2019-12-30T13:28:25.758Z","comments":true,"path":"2019/12/30/CF1271D Portals/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/30/CF1271D Portals/","excerpt":"","text":"CF1271D Portals 比赛时自己卡在了这题上，现在特来写篇比较符合现场思路的题解 题解：dp很好想，状态也十分经典：设$f[i][j]$表示前$i$个城堡，手头剩下$j$个士兵的最大收益 初始化$f[0][k]=0$，其它赋为负无穷 从后往前继承状态时要从$a_i$开始枚举（能成功占领的条件），士兵数要减$b_i$（可以加兵的条件） 转移需要稍微思考下 是考虑从每条路转移吗？这样的话就会变得相当复杂，二维状态也不够用了 这时候就需要注意到一条很关键的性质：假设当前要从$u$走路径$$到$v$，那么在合法的前提下，$u$肯定是越大越好 为什么呢？ 因为题目有一条很重要的限制，就是$n$座城堡都要被占领，也就是说，既然这条路转移的收益是相同的，而多一个士兵也许能让你占领更多城堡，那么贪心地肯定是要把这个士兵留的时间越长越好 依照这样的思路，我们可以处理出$v_{u,i}$，满足存在边$$，且$u$是连向$v$的最远的一个城堡 由于$v_{u,i}$都是互不干扰的，我们就可以根据收益的从大到小，贪心地在$v_{u,i}$中做选择，注意所做的选择必须是成前缀式的，也就是说要选次优的前提条件是更优的都选了 另外，题目还说可以原地留兵，这怎么搞呢？ 我们不妨看成每个城堡上都有一条自环，与其它有着相同终点的路一起比较起点的远近即可 转移部分具体可以看看代码 代码中为了方便理解，最大士兵人数我用的都是常数5000，其实也可以把它换成士兵数的前缀和来减小常数 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=5005; int ans=-1,a[N],b[N],c[N],link[N],f[N][N],n,m,k,g[N]; vector&lt;int&gt; nxt[N]; inline bool cmp(const int &amp;x,const int &amp;y){ return c[x]&gt;c[y]; } signed main(){ read(n);read(m);read(k); for(int i=1;i&lt;=n;i++){ read(a[i]); read(b[i]); read(c[i]); link[i]=i; //建立自环 } for(int i=1,x,y;i&lt;=m;i++){ read(x);read(y); link[y]=max(link[y],x); //处理出最远起点 } for(int i=1;i&lt;=n;i++) nxt[link[i]].push_back(i); //枚举终点，从该点的最远起点连边 for(int i=1;i&lt;=n;i++) sort(nxt[i].begin(),nxt[i].end(),cmp); //按照收益从大到小排序 memset(f,~0x3f,sizeof f); f[0][k]=0; //初始化 for(int i=1;i&lt;=n;i++){ for(int j=a[i];j+b[i]&lt;=5000;j++) //继承上个城堡的状态，注意a[i]和b[i] f[i][j+b[i]]=f[i-1][j]; int cnt=nxt[i].size(); for(int j=0;j&lt;=5000;j++){ int sum=0; g[j]=f[i][j]; //另外开个临时数组g[]，以免覆盖原数组 for(int k=0;k&lt;cnt;k++) if(j+k+1&lt;=5000){ sum+=c[nxt[i][k]]; //几个前缀和 g[j]=max(g[j],f[i][j+k+1]+sum); //k+1是因为k是从0开始的，其实是表示在前缀上选择的城堡的数量（即要花费的士兵的数量） } } memcpy(f[i],g,sizeof g); //赋回去 } for(int i=0;i&lt;=5000;i++) ans=max(ans,f[n][i]); write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.yzcthinktwice.com/tags/贪心/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1114F Please, another Queries on Array?","slug":"CF1114F Please, another Queries on Array","date":"2019-12-17T10:00:05.000Z","updated":"2019-12-17T14:10:05.140Z","comments":true,"path":"2019/12/17/CF1114F Please, another Queries on Array/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/17/CF1114F Please, another Queries on Array/","excerpt":"","text":"CF1114F Please, another Queries on Array? 状压+简单数论+简单线段树，一看就很套路。。。 题解：首先思考欧拉函数的通项公式$\\varphi(x)=x*\\prod\\limits_{i=1}^{n}(1-\\frac{1}{p_i})$，其中$p_i$是$x$的质因数 也就是说对于要求的$\\varphi(x)$，我们需要知道它的值$x$，和它的质因数$p_i$ 考虑题目要求的查询$\\varphi(\\prod \\limits_{i=l}^{r} a_i)$，根据上面的推理，要求出它我们也需要知道两样东西，$\\prod \\limits_{i=l}^{r} a_i$和区间$[l,r]$内有哪些质因数 乘积可以用线段树简单的维护，那有哪些质因数用什么维护呢？ 注意到题目给出的$a_i$和$x$都很小，如果有经验的话（或者打个表）可以发现，这范围内只有62个质数 这不就是提示要状压吗！ 于是线段树上开个longlong状压搞区间或就好了 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long #define res pair&lt;int,int&gt; #define x first //x是查询的乘积 #define y second //y是查询的状压 const int mod=1e9+7; const int N=4e5+5; int pn,p[70]; bool prime[350]; int a[N&lt;&lt;2],s[N&lt;&lt;2],mtg[N&lt;&lt;2],stg[N&lt;&lt;2],n,q,inv[70],sit[N],val[N]; int fpow(int x,int y,int mod){ int mul=1; for(;y;y&gt;&gt;=1,mod?(x*=x)%=mod:x*=x) if(y&amp;1) mod?(mul*=x)%=mod:mul*=x; return mul; } void init(int n){ for(int i=2;i&lt;=n;i++) prime[i]=1; for(int i=2;i&lt;=n;i++){ if(prime[i]) p[pn]=i,inv[pn++]=fpow(i,mod-2,mod); for(int j=0;j&lt;pn&amp;&amp;i*p[j]&lt;=n;j++){ prime[i*p[j]]=0; if(i%p[j]==0) break; } } } void pushup(int x){ a[x]=a[x&lt;&lt;1]*a[x&lt;&lt;1|1]%mod; //a是乘积 s[x]=s[x&lt;&lt;1]|s[x&lt;&lt;1|1]; //s是状压 } void build(int x,int l,int r){ mtg[x]=1; stg[x]=0; if(l==r){ a[x]=val[l]; s[x]=sit[l]; return ; } int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid); build(x&lt;&lt;1|1,mid+1,r); pushup(x); } void pushdown(int x,int l,int r){ int mid=l+r&gt;&gt;1; if(mtg[x]^1){ //乘上 (mtg[x&lt;&lt;1]*=mtg[x])%=mod; (mtg[x&lt;&lt;1|1]*=mtg[x])%=mod; (a[x&lt;&lt;1]*=fpow(mtg[x],mid-l+1,mod))%=mod; (a[x&lt;&lt;1|1]*=fpow(mtg[x],r-mid,mod))%=mod; mtg[x]=1; } if(stg[x]){ //或上 stg[x&lt;&lt;1]|=stg[x]; stg[x&lt;&lt;1|1]|=stg[x]; s[x&lt;&lt;1]|=stg[x]; s[x&lt;&lt;1|1]|=stg[x]; stg[x]=0; } } res merge(res x,res y){ //答案合并 return res(x.x*y.x%mod,x.y|y.y); } res que(int x,int l,int r,int p,int q){ if(p&lt;=l&amp;&amp;r&lt;=q){ return res(a[x],s[x]); } pushdown(x,l,r); int mid=l+r&gt;&gt;1; res ans=res(1,0); if(p&lt;=mid) ans=merge(ans,que(x&lt;&lt;1,l,mid,p,q)); if(q&gt;mid) ans=merge(ans,que(x&lt;&lt;1|1,mid+1,r,p,q)); return ans; } void up(int x,int l,int r,int p,int q,int xv,int sv){ if(p&lt;=l&amp;&amp;r&lt;=q){ (a[x]*=fpow(xv,r-l+1,mod))%=mod; s[x]|=sv; (mtg[x]*=xv)%=mod; stg[x]|=sv; return ; } pushdown(x,l,r); int mid=l+r&gt;&gt;1; if(p&lt;=mid) up(x&lt;&lt;1,l,mid,p,q,xv,sv); if(q&gt;mid) up(x&lt;&lt;1|1,mid+1,r,p,q,xv,sv); pushup(x); } void doit(){ char s[10]; scanf(&quot;%s&quot;,s); int l,r; read(l);read(r); if(s[0]==&#39;T&#39;){ res tp=que(1,1,n,l,r); for(int i=0;i&lt;pn;i++) if(tp.y&gt;&gt;i&amp;1) //解压 tp.x=tp.x*inv[i]%mod*(p[i]-1)%mod; write(tp.x);puts(&quot;&quot;); } else{ int x,s=0; read(x); for(int i=0;i&lt;pn;i++) if(x%p[i]==0) s|=1ll&lt;&lt;i; up(1,1,n,l,r,x,s); } } signed main(){ init(300); read(n);read(q); for(int i=1;i&lt;=n;i++){ read(val[i]); for(int j=0;j&lt;pn;j++) if(val[i]%p[j]==0) sit[i]|=1ll&lt;&lt;j; //分解出有哪些质因数搞状压 } build(1,1,n); while(q--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"},{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"状压","slug":"状压","permalink":"https://blog.yzcthinktwice.com/tags/状压/"},{"name":"线段树","slug":"线段树","permalink":"https://blog.yzcthinktwice.com/tags/线段树/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://blog.yzcthinktwice.com/tags/欧拉函数/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1151F Sonya and Informatics","slug":"CF1151F Sonya and Informatics","date":"2019-12-17T10:00:04.000Z","updated":"2019-12-17T14:14:50.876Z","comments":true,"path":"2019/12/17/CF1151F Sonya and Informatics/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/17/CF1151F Sonya and Informatics/","excerpt":"","text":"CF1151F Sonya and Informatics 矩阵优化dp超好题，dp状态十分巧妙 题解：DP部分：题目要求排成一个非降序列，由于只有0和1，这意味着要将所有0放在1的前面，又因为0和1的数量是确定的，所以哪些位置给0，哪些位置给1也是确定的 记$m$表示序列中0的个数，我们知道1~m中的0和m+1~n中的1是合法的，反之不合法 状态很巧妙，设$f[i][j]$表示交换$i$次后，前$m$个位置有$j$个0 光凭状态中的一个$j$，我们就可以知道1~m中0和1的个数，m+1~n中0和1的个数，换句话说，知道了合法的数的个数 记$cnt$表示数列中前$m$个数中0的个数，初始化$f[0][cnt]=1$，表示现有状况 考虑转移，容易发现每次交换两个数，$f[i][j]$只会由$f[i-1][j-1]$，$f[i-1][j+1]$，$f[i-1][j]$得到，可以进行如下分类讨论： $f[i-1][j-1](m-(j-1))(m-(j-1))$ 表示将前$m$个数中的0与后$n-m$个数中的1做交换，其中第一个$(m-(j-1))$的意思是前m个数中1的个数，第二个的意思是后$n-m$个数中0的个数 $f[i-1][j+1](j+1)(n-m-(m-(j+1)))$ 与第一中转移相反，即将前$m$个数中的1与后$n-m$个数中的0做交换 $f[i-1][j]j(m-j)$ 在前$m$个数中选两个数交换（注意是一个1一个0！） $f[i-1][j](m-j)(n-m-(m-j))$ 在后$n-m$个数中选两个数交换（注意是一个1一个0！） $f[i-1][j]m(m-1)/2$ 表示将两个0做交换 $f[i-1][j](n-m)(n-m-1)/2$ 表示将两个1做交换 最后$f[i][j]$的值就是以上6部分转移之和 而根据题目的要求，$ans=\\frac{f[k][m]}{\\sum\\limits_{i=0}^{m}f[k][i]}$，表示$k$次交换后的前$m$个数都是0的方案数（合法方案）除以总的方案数 这样你就得到了一个$O(nk)$的dp，下面按照分类讨论的顺序dp代码： int cnt=0; for(int i=1;i&lt;=m;i++) cnt+=(a[i]==0); f[0][cnt]=1; for(int i=1;i&lt;=k;i++) for(int j=0;j&lt;=m;j++){ if(j!=0) f[i][j]=(f[i][j]+f[i-1][j-1]*(m-(j-1))*(m-(j-1))%mod)%mod; if(j!=m) f[i][j]=(f[i][j]+f[i-1][j+1]*(j+1)*(n-m-(m-(j+1)))%mod)%mod; f[i][j]=(f[i][j]+f[i-1][j]*j*(m-j)%mod)%mod; f[i][j]=(f[i][j]+f[i-1][j]*(m-j)*(n-m-(m-j))%mod)%mod; f[i][j]=(f[i][j]+f[i-1][j]*m*(m-1)/2%mod)%mod; f[i][j]=(f[i][j]+f[i-1][j]*(n-m)*(n-m-1)/2%mod)%mod; } 矩乘部分：注意到$k$非常大，而$n$却很小，这意味着还有优化的空间 重新观察转移方程，发现$f[i][j]$可以表示为$f[i-1][j-1]k_1+f[i-1][j]k_2+f[i-1][j+1]*k_3$的形式，其中$k_1$，$k_2$，$k_3$是三个只与$j$相关的常数 这个系数恒定不变的性质，就是矩乘优化的标志 矩乘由两部分组成，$1m$状态矩阵$A$，和$mm$转移矩阵$B$ $A$描述的是每一阶段的$f$数组，下标与$f$数组的$j$意义相同，因此初始化$A_{cnt}=1$ $B$是用来将$A$从旧状态转移到新状态的，$B_{i,j}$表示从$A_i$转移到$A_j$的系数 具体地，只要仔细地根据转移方程将系数填进$B$矩阵就好了 这样答案所需要的状态$A’$就等于$A*B^k$，意思是转移了$k$次 而又因为矩乘的结合律，可以用快速幂 复杂度被优化到了$O(n^3\\log k)$，其中$n^3$是矩乘的，$\\log k$是快速幂的 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int mod=1e9+7; const int N=105; int n,k,m,cnt,a[N]; struct mat{ int a[N][N]; mat(){memset(a,0,sizeof a);} inline mat operator * (const mat &amp;nt) const { //重载矩阵乘法 mat res; for(int i=0;i&lt;=m;i++) for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=m;k++) res.a[i][j]=(1ll*res.a[i][j]+1ll*a[i][k]*nt.a[k][j]%mod)%mod; return res; } }A,B; mat mpow(mat x,int y){ //矩阵快速幂 mat res; for(int i=0;i&lt;=m;i++) res.a[i][i]=1; for(;y;y&gt;&gt;=1,x=x*x) if(y&amp;1) res=res*x; return res; } int fpow(int x,int y){ //普通快速幂（用来求逆元） int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res; } signed main(){ read(n);read(k); for(int i=1;i&lt;=n;i++){ read(a[i]); m+=(a[i]==0); } for(int i=1;i&lt;=m;i++) cnt+=(a[i]==0); A.a[0][cnt]=1; for(int i=0;i&lt;=m;i++){ //枚举，把转移方程塞到转移矩阵里 if(i!=0) B.a[i-1][i]=1ll*(m-(i-1))*(m-(i-1))%mod; B.a[i][i]=1ll*i*(m-i)%mod; B.a[i][i]=(1ll*B.a[i][i]+1ll*(m-i)*(n-m-(m-i))%mod)%mod; B.a[i][i]=(1ll*B.a[i][i]+1ll*m*(m-1)/2%mod)%mod; B.a[i][i]=(1ll*B.a[i][i]+1ll*(n-m)*(n-m-1)/2%mod)%mod; if(i!=m) B.a[i+1][i]=1ll*(i+1)*(n-m-(m-(i+1)))%mod; } B=mpow(B,k); A=A*B; int sum=0; for(int i=0;i&lt;=m;i++) sum=(1ll*sum+A.a[0][i])%mod; //统计总方案数（答案的分母） write(1ll*A.a[0][m]*fpow(sum,mod-2)%mod); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://blog.yzcthinktwice.com/tags/矩阵乘法/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1272F Two Bracket Sequences","slug":"CF1272F Two Bracket Sequences","date":"2019-12-17T10:00:03.000Z","updated":"2019-12-17T14:03:11.281Z","comments":true,"path":"2019/12/17/CF1272F Two Bracket Sequences/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/17/CF1272F Two Bracket Sequences/","excerpt":"","text":"CF1272F Two Bracket Sequences 题解：设$g[i][j][k]$表示要使$S$串匹配到第$i$个括号，$T$串匹配到第$j$个括号，所得到的答案串里还有$k$个左括号未匹配所需要的最少括号 同时记录$f[i][j][k]=\\{i’,j’,k’\\}$表示$g[i][j][k]$是从$g[i’][j’][k’]$转移来的 考虑转移： 假设我们现在要在状态$\\{i,j,k\\}$上添加个左括号转移到状态$\\{ni,nj,nk\\}$ 因为是添加左括号，所以$nk=k+1$ 如果$S_{i+1}$是左括号，那么$ni=i+1$（意思是匹配），否则就$ni=i$（意思是加个不存在的括号） $T$串同理 相反的，如果现在要加个右括号，那$nk=k-1$（因为可以抵消一个左括号），其余与左括号的情况同理 另外，还要注意$nk$的上下边界，即$nk\\in[0,len_S+len_T]$ 代码中，考虑用bfs进行这个dp过程，从$\\{0,0,0\\}$一步加一个括号，由于bfs的性质，可以保证第一次到达某种状态时，解一定是最优的（即括号数最少） 这样我们就可以省略g数组了 最后考虑回溯统计答案 显然的，状态$\\{len_S,len_T,0\\}$是我们需要的答案状态，表示$S$和$T$串都匹配完了，且没有左括号剩余 我们就可以从这个答案状态出发，沿$f$数组回溯到$\\{0,0,0\\}$为止 假设现在状态时$\\{i,j,k\\}$，将要回溯到$\\{i’,j’,k’\\}$ 如果$k&gt;k’$，就说明现在这个状态是一个左括号 否则$k&lt;k’$就说明这个状态是一个右括号 把相应括号加到答案串里逆序输出即可 代码中我写了个结构体，实际上也可以用c++11自带的多元组tuple 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=205; int n,m; char a[N],b[N]; string ans; struct node{ int i,j,k; }f[N][N][N&lt;&lt;1]; void bfs(){ queue&lt;node&gt; q; memset(f,-1,sizeof f); //一开始都没走过 f[0][0][0]=(node){0,0,0}; //起始状态 q.push((node){0,0,0}); while(!q.empty()){ node x=q.front();q.pop(); int i=x.i,j=x.j,k=x.k,ni,nj,nk; ni=i+(a[i+1]==&#39;(&#39;); //加个左括号，这样写可以精简代码的说~ nj=j+(b[j+1]==&#39;(&#39;); nk=k+1; if(nk&lt;=n+m&amp;&amp;f[ni][nj][nk].i==-1){ //记忆化的思路，没走过才能走 f[ni][nj][nk]=x; q.push((node){ni,nj,nk}); } ni=i+(a[i+1]==&#39;)&#39;); //加个右括号 nj=j+(b[j+1]==&#39;)&#39;); nk=k-1; if(nk&gt;=0&amp;&amp;f[ni][nj][nk].i==-1){ f[ni][nj][nk]=x; q.push((node){ni,nj,nk}); } } } signed main(){ scanf(&quot;%s%s&quot;,a+1,b+1); n=strlen(a+1);m=strlen(b+1); bfs(); int i=n,j=m,k=0; while(i||j||k){ //回溯 node nxt=f[i][j][k]; if(nxt.k&lt;k) ans=&quot;(&quot;+ans; else ans=&quot;)&quot;+ans; i=nxt.i;j=nxt.j;k=nxt.k; } cout&lt;&lt;ans; }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3978 [TJOI2015]概率论","slug":"P3978 [TJOI2015]概率论","date":"2019-12-17T10:00:02.000Z","updated":"2019-12-17T14:14:10.188Z","comments":true,"path":"2019/12/17/P3978 [TJOI2015]概率论/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/17/P3978 [TJOI2015]概率论/","excerpt":"","text":"P3978 [TJOI2015]概率论 一道推式子好题，本来确实是想写题解的，但rqy写得实在是太好了，这里就放出她的题解 我这里补充说明一下$ans=\\frac{g_n}{f_n}$的原因： 题目说每种树概率相同，那概率$=\\frac{1}{f_n}$ 设第$i$种n节点的树有$p_i$个叶子 根据期望的线性性，$ans=\\sum\\limits_{i=1}^{f_n}\\frac{p_i}{f_n}=\\frac{\\sum\\limits_{i=1}^{f_n}p_i}{f_n}$ 又因为$\\sum\\limits_{i=1}^{f_n}p_i=g_n$ 所以可得$ans=\\frac{g_n}{f_n}$","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"},{"name":"概率期望","slug":"概率期望","permalink":"https://blog.yzcthinktwice.com/tags/概率期望/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"转载","slug":"转载","permalink":"https://blog.yzcthinktwice.com/tags/转载/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P4197 Peaks","slug":"P4197 Peaks","date":"2019-12-17T10:00:01.000Z","updated":"2019-12-17T14:11:54.779Z","comments":true,"path":"2019/12/17/P4197 Peaks/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/17/P4197 Peaks/","excerpt":"","text":"P4197 Peaks 糅合了倍增、Kruskal重构树、可持久化线段树求区间第K大这些经典问题，是一道不错的练习题 题解：这题由于比较复杂，先放上一张从这盗来的图，是样例的Kruskal重构树 ： 首先注意到只经过困难值小于等于$x$的路径这一限制，这是一个经典的Kruskal重构树问题 具体见上图：红点是实点，白点是虚点，红色数字是连接白点下方两个点的边的权值 很容易发现Kruskal重构树的一个性质：一棵子树里的所有红数字都是小于等于该子树根上的红数字的 现在题目给出了你起点$v$，和限制$x$，根据这个性质，就可以从红点$v$开始向上爬，直到爬到一个白点$p$，满足$p$的父亲的红色数字大于$x$或$p$没有父亲 至于爬的过程这又是一个经典问题，我们用倍增解决，可以使爬的过程复杂度从$O(n)$降为$O(\\log n)$ 在得到$p$点后，以$p$为根的子树内的所有红点就是起点$v$可以到达的点，现在的任务就是要快速求出一棵子树上的第$k$大数 由于所有的山峰高度都在叶子（即红点上），不难看出是有连续性的 观察上面的图，我们可以在建完重构树后从树根开始，从上往下跑一遍dfs 在把值插入主席树的同时，把所有的叶子拍扁，记录下所有白点所管辖的红点的范围 至于这个红点的范围，可以具体看图，从左到右，十分清楚 这样对于询问，就可以先根据$v$和$x$找出$p$，再在$p$的所管辖红点范围内做个区间第$k$大查询即可 另外在代码中，还有一个常规操作是要先将山峰高度离散化了再做 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5,M=5e5+5; int height[N&lt;&lt;1],rt[N],h[N&lt;&lt;1],en,un,cnt,f[N&lt;&lt;1],fa[N&lt;&lt;1][21],n,m,q,num[N],val[N],id,lef[N&lt;&lt;1],rig[N&lt;&lt;1]; int lc[N&lt;&lt;6],rc[N&lt;&lt;6],a[N&lt;&lt;6]; struct edge{ int n,v; }e[N&lt;&lt;1]; inline void add(int x,int y){ e[++en]=(edge){h[x],y}; h[x]=en; } struct ee{ int x,y,z; inline bool operator &lt; (const ee &amp;nt) const { return z&lt;nt.z; } }data[M]; inline int getf(int x){ if(f[x]==x) return x; return f[x]=getf(f[x]); } /*建基树*/ int build(int l,int r){ int x=++cnt; if(l==r){ return x; } int mid=l+r&gt;&gt;1; lc[x]=build(l,mid); rc[x]=build(mid+1,r); return x; } /*插入个数*/ int up(int pre,int l,int r,int p){ int x=++cnt; lc[x]=lc[pre]; rc[x]=rc[pre]; a[x]=a[pre]+1; if(l==r){ return x; } int mid=l+r&gt;&gt;1; if(p&lt;=mid) lc[x]=up(lc[pre],l,mid,p); else rc[x]=up(rc[pre],mid+1,r,p); return x; } /*查询第k大*/ int que(int x,int y,int l,int r,int k){ if(l==r) return l; int now=a[rc[y]]-a[rc[x]]; //看看较大的半边有多少个数 int mid=l+r&gt;&gt;1; if(now&gt;=k) return que(rc[x],rc[y],mid+1,r,k); //够k个就往大的找（右边） else return que(lc[x],lc[y],l,mid,k-now); //不够就砍掉右边的数量，再往小的找（左边） } /*维护倍增所需信息，记录白点所管辖红点范围，将山峰高度插到主席树中*/ void dfs(int x){ for(int i=1;i&lt;=20;i++) fa[x][i]=fa[fa[x][i-1]][i-1]; if(x&lt;=n){ int pos=lower_bound(num+1,num+1+un,val[x])-num; id++; //找到一个红点，范围+1 rt[id]=up(rt[id-1],1,un,pos); //把红点的山峰高度插到主席树中去 } else{ lef[x]=id; //Attention!!!注意这边存是一个左开右闭区间 for(int i=h[x];i;i=e[i].n){ int y=e[i].v; dfs(y); } rig[x]=id; } } void doit(){ int s,x,k; read(s);read(x);read(k); for(int i=20;i&gt;=0;i--) if(fa[s][i]&amp;&amp;height[fa[s][i]]&lt;=x) s=fa[s][i]; //倍增找题解中所说的p点 if(rig[s]-lef[s]&lt;k){ //如果管辖范围内根本不足k个点就无解 puts(&quot;-1&quot;); return ; } write(num[que(rt[lef[s]],rt[rig[s]],1,un,k)]);puts(&quot;&quot;); //查询 } signed main(){ read(n);read(m);read(q); for(int i=1;i&lt;=n;i++) num[i]=read(val[i]); sort(num+1,num+1+n); un=unique(num+1,num+1+n)-num-1; //离散化 for(int i=1,x,y,z;i&lt;=m;i++){ read(x);read(y);read(z); data[i]=(ee){x,y,z}; } sort(data+1,data+1+m); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1,num=0;i&lt;=m;i++){ //Krusakal int x=getf(data[i].x),y=getf(data[i].y); if(x==y) continue; num++; height[n+num]=data[i].z; f[x]=f[y]=f[n+num]=n+num; //n+num是虚点编号 add(n+num,x); //从上往下（从虚往实）连边 add(n+num,y); fa[x][0]=fa[y][0]=n+num; if(num==n-1) break; } rt[0]=build(1,un); //建基树 dfs(2*n-1); //2*n-1是深度最浅的虚点，即树根 while(q--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"倍增","slug":"倍增","permalink":"https://blog.yzcthinktwice.com/tags/倍增/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"https://blog.yzcthinktwice.com/tags/Kruskal重构树/"},{"name":"可持久化线段树","slug":"可持久化线段树","permalink":"https://blog.yzcthinktwice.com/tags/可持久化线段树/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P4284 [SHOI2014]概率充电器","slug":"P4284 [SHOI2014]概率充电器","date":"2019-12-10T12:11:00.000Z","updated":"2019-12-15T08:12:48.097Z","comments":true,"path":"2019/12/10/P4284 [SHOI2014]概率充电器/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/P4284 [SHOI2014]概率充电器/","excerpt":"","text":"P4284 [SHOI2014]概率充电器 一道换根树形概率期望dp好题 题解：先对问题进行转化 因为期望的线性性，所以整棵树期望几个被充电就等价于所有节点各自被充电的期望的和，又由于对于每个节点，期望都等于概率×1，所以其实题目就是在问你所有节点能被充上电的概率的和 方便起见，考虑从反面进行思考，即求每个节点的不被充上电的概率 记点$x$自己亮的概率为$q[x]$，x,y之间通电的概率为$e[x][y]$ 设$g[x]$表示点x不亮的概率 容易得到$g[x]=(1-q[x])\\prod\\limits_{(x,y)\\in E}(1-e[x][y]+e[x][y]g[y])$ 方程的意思是（自己不会亮自己）且（（与之相连的点不会导电）或（与之相连的点会导电但没电）） 注意到这个方程是有后效性的，所以先确定一个全局根，再设$f[x]$表示点x不被以x为根子树内任何一个点点亮的概率，得到新方程$f[x]=(1-q[x])\\prod\\limits_{y \\in son(x)}(1-e[x][y]+e[x][y]f[y])$ 发现这个方程每在树上跑一遍，每次所选的全局根的g[x]都因为等于f[x]而得到 所以只要跑n遍dp，每次换个全局根就可以算出来所有g[x]了？ 然而因为这个方程要求的东西显然是可以分成上贡献和下贡献两部分，且仅仅是乘起来的，所以我们考虑换根树形dp 在第二次dfs的时候跑g[x]的转移方程，这要求算出实际的g[fa]，因为现实的g[fa]是重复计算了x这部分子树的贡献的，所以除去后带进方程，就可以得到g[x]，而至于多余的部分，显然是可以用f[x]算出来的，也就是$g[fa]_{实际}=g[fa]/(1-e[fa][x]+e[fa][x]*f[x])$ 算完所有的g[x]后，容易得出$ans=\\sum\\limits_{i=1}^{n}(1-g[i])$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=5e5+5; int en,h[N],n; double ans,g[N],f[N],p[N]; struct edge{ int n,v; double w; }e[N&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,0.01*z}; h[x]=en; } void dfs1(int x,int fa){ f[x]=1-p[x]; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==fa) continue; dfs1(y,x); f[x]*=1-e[i].w+e[i].w*f[y]; } } void dfs2(int x,int fa,int past){ if(x==1) g[x]=f[x]; else{ double cfa=g[fa]/(1-e[past].w+e[past].w*f[x]);//contribution from ancestor：祖先的贡献 g[x]=f[x]*(1-e[past].w+e[past].w*cfa); } for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==fa) continue; dfs2(y,x,i); } } signed main(){ read(n); for(int i=1,x,y,z;i&lt;n;i++){ read(x);read(y);read(z); add(x,y,z); add(y,x,z); } for(int i=1,x;i&lt;=n;i++) p[i]=0.01*read(x); dfs1(1,0); dfs2(1,0,0); for(int i=1;i&lt;=n;i++) ans+=1-g[i]; printf(&quot;%.6lf&quot;,ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"概率期望","slug":"概率期望","permalink":"https://blog.yzcthinktwice.com/tags/概率期望/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P2114 [NOI2014]起床困难综合症","slug":"P2114 [NOI2014]起床困难综合症","date":"2019-12-10T12:09:00.000Z","updated":"2019-12-15T08:14:35.080Z","comments":true,"path":"2019/12/10/P2114 [NOI2014]起床困难综合症/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/P2114 [NOI2014]起床困难综合症/","excerpt":"","text":"P2114 [NOI2014]起床困难综合症 LOJ也有，巧妙的位运算贪心题 题解：注意到每一位都是各自独立的，这意味着贪心是可行的 由于每一位在确定了起始的数字后都无法再改变，所以不妨预处理出每一位的0/1在经过所有门后是0还是1 具体的方法是分别拿一个全0的数和一个全1的数（0x7fffffff）去穿过所有门 这样一来对于每一位只会有四种情况： 情况 起始 终止 起始 终止 1 0 0 1 0 2 0 0 1 1 3 0 1 1 0 4 0 1 1 1 贪心的，我们从高到低枚举各位，对于第i位，如果能从0变1，那肯定选0，没有代价，贡献为$2^i$ 否则，如果只有1能变1，且还有至少$2^i$的资本，那就要用$2^i$的代价换$2^i$的贡献，具体的，“资本”就是指题目给出的m 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } int p1=0x7fffffff,p0,n,m,ans,x; //p1是全1数，p0是全0数 char s[5]; signed main(){ read(n);read(m); while(n--){ scanf(&quot;%s&quot;,s);read(x); if(s[0]==&#39;A&#39;) p0&amp;=x,p1&amp;=x; //分别穿过n道门 if(s[0]==&#39;X&#39;) p0^=x,p1^=x; if(s[0]==&#39;O&#39;) p0|=x,p1|=x; } for(int i=29;i&gt;=0;i--){ if(p0&gt;&gt;i&amp;1) ans|=1&lt;&lt;i; //能从0到1 else if(p1&gt;&gt;i&amp;1&amp;&amp;(1&lt;&lt;i)&lt;=m) ans|=1&lt;&lt;i,m-=1&lt;&lt;i; //能从1到1且资本充足 } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"位运算","slug":"位运算","permalink":"https://blog.yzcthinktwice.com/tags/位运算/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1245E Hyakugoku and Ladders","slug":"CF1245E Hyakugoku and Ladders","date":"2019-12-10T12:08:00.000Z","updated":"2019-12-15T08:12:55.715Z","comments":true,"path":"2019/12/10/CF1245E Hyakugoku and Ladders/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/CF1245E Hyakugoku and Ladders/","excerpt":"","text":"CF1245E Hyakugoku and Ladders 一道不错的概率dp 题解：方便起见，先将二维转成一维，终点为100,起点为1 设f[i]表示格子i到终点的期望步数，nxt[i]表示用梯子会到达的格子 初始f[100]=0 先考虑不能一步到的格子（93～1），转移为$f[i]=1+\\frac{\\sum_{j=1}^{6} \\min(f[i+j],f[nxt[i+j]])}{6}$ （解释：+1表示要在上一种基础上多扔一次，除以6表示从每个上一种转移的概率都是$\\frac{1}{6}$，min()表示可以靠老老实实走转移，也可以靠梯子转移） 再考虑能一步到的格子（99～94） 手算 f[99]=\\frac{5(f[99]+1)}{6}+\\frac{f[100]+1}{6}（解释：$\\frac{5}{6}$概率留原地,$\\frac{1}{6}$概率到终点） 打开 \\frac{f[99]}{6}=1得到 f[99]=6其他同理，可以得出99~94号格子都期望6步到达终点 最后答案就是f[1] 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=15; int id[N][N],nxt[105],cnt; double f[105]; signed main(){ for(int i=10;i&gt;=1;i--) if(i&amp;1) for(int j=10;j&gt;=1;j--) id[i][j]=++cnt; else for(int j=1;j&lt;=10;j++) id[i][j]=++cnt; //id[i][j]表示从上到下第i行，从左到右第j列转成一维后的序号 for(int i=1,x;i&lt;=10;i++) for(int j=1;j&lt;=10;j++) nxt[id[i][j]]=id[i-read(x)][j]; //nxt[i]表示第i格子会到哪，有梯子则指向梯子终点，否则指向自己 for(int i=99;i&gt;=94;i--) f[i]=6; //手算得出 for(int i=93;i&gt;=1;i--){ for(int j=1;j&lt;=6;j++) f[i]+=fmin(f[i+j],f[nxt[i+j]]); //转移 f[i]=f[i]/6.0+1; //除以概率，加上代价 } printf(&quot;%.10lf&quot;,f[1]); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"概率期望","slug":"概率期望","permalink":"https://blog.yzcthinktwice.com/tags/概率期望/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF138C Mushroom Gnomes - 2","slug":"CF138C Mushroom Gnomes - 2","date":"2019-12-10T12:07:00.000Z","updated":"2019-12-15T08:14:30.101Z","comments":true,"path":"2019/12/10/CF138C Mushroom Gnomes - 2/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/CF138C Mushroom Gnomes - 2/","excerpt":"","text":"CF138C Mushroom Gnomes - 2 偏模板的用线段树优化的简单概率期望题 题解：首先转化题意，题目问所有蘑菇价值和的期望，由于期望的线性性，这等同于在问你每个蘑菇期望价值之和，已知价值，只要求出每个蘑菇不被覆盖的概率即可 思路很好想，对于每棵树，在它的左边做个区间乘，在它的右边做个区间乘，乘上的是1-倒下的概率，最后再单点查询每个蘑菇不被覆盖的概率 另外，因为注意到范围为1e9，所以还要离散化，对于每棵树的操作，只记录左边的两个端点和右边的两个端点 特别的，在代码中，由于询问都在修改之后，所以标记直接保留在线段上即可，不用上下传，只要查询的时候一直累乘即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5,M=1e4+5,NM=N*4+M,TR=NM&lt;&lt;2; int n,m,pt[NM],pn; double p[TR],ans; struct tree{ int x,h,l,r; }a[N]; struct mushroom{ int x,v; }b[M]; void build(int x,int l,int r){ p[x]=1; //初始概率都为1 if(l==r) return ; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid); build(x&lt;&lt;1|1,mid+1,r); } void up(int x,int l,int r,int L,int R,double v){ if(L&lt;=l&amp;&amp;r&lt;=R){ p[x]*=v; return ; } int mid=l+r&gt;&gt;1; if(L&lt;=mid) up(x&lt;&lt;1,l,mid,L,R,v); if(R&gt;mid) up(x&lt;&lt;1|1,mid+1,r,L,R,v); } double que(int x,int l,int r,int pos){ if(l==r) return p[x]; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) return p[x]*que(x&lt;&lt;1,l,mid,pos); //把标记累乘 return p[x]*que(x&lt;&lt;1|1,mid+1,r,pos); } signed main(){ read(n);read(m); for(int i=1;i&lt;=n;i++){ read(a[i].x);read(a[i].h);read(a[i].l);read(a[i].r); pt[++pn]=a[i].x-a[i].h; //pt储存有用的端点信息 pt[++pn]=a[i].x-1; pt[++pn]=a[i].x+1; pt[++pn]=a[i].x+a[i].h; } for(int i=1;i&lt;=m;i++){ read(b[i].x);read(b[i].v); pt[++pn]=b[i].x; } sort(pt+1,pt+1+pn); pn=unique(pt+1,pt+1+pn)-pt-1; build(1,1,pn); for(int i=1;i&lt;=n;i++){ up(1,1,pn,lower_bound(pt+1,pt+1+pn,a[i].x-a[i].h)-pt,lower_bound(pt+1,pt+1+pn,a[i].x-1)-pt,1.0-0.01*a[i].l); //乘左边 up(1,1,pn,lower_bound(pt+1,pt+1+pn,a[i].x+1)-pt,lower_bound(pt+1,pt+1+pn,a[i].x+a[i].h)-pt,1.0-0.01*a[i].r); //乘右边 } for(int i=1;i&lt;=m;i++) ans+=que(1,1,pn,lower_bound(pt+1,pt+1+pn,b[i].x)-pt)*b[i].v; //查询概率并乘上价值 printf(&quot;%.10lf&quot;,ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"概率期望","slug":"概率期望","permalink":"https://blog.yzcthinktwice.com/tags/概率期望/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1227F2 Wrong Answer on test 233 (Hard Version)","slug":"CF1227F2 Wrong Answer on test 233 (Hard Version)","date":"2019-12-10T12:04:00.000Z","updated":"2019-12-15T08:16:30.801Z","comments":true,"path":"2019/12/10/CF1227F2 Wrong Answer on test 233 (Hard Version)/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/CF1227F2 Wrong Answer on test 233 (Hard Version)/","excerpt":"","text":"CF1227F2 Wrong Answer on test 233 (Hard Version) 点这通往Easy版题解/) Hard版是个组合数学题，但只要发现了对称性比Easy更简单。。。 题解：假设你已经通过各种奇奇怪怪的方法发现了Easy版中，$f[i][j]=f[i][-j]$这一性质（比方说大眼观察这对称的dp方程啊（雾）），可以得到如下推导 已知$ANS=\\sum\\limits_{i=1}^{n}f[i][j] [j&gt;0]$，$\\sum\\limits_{i=1}^{n}f[i][j] [j&gt;0]=\\sum\\limits_{i=1}^{n}f[i][j] [j&lt;0]$，总方案数=$k^n$ 可得$ANS=\\frac{k^n-\\sum\\limits_{i=1}^{n}f[i][0]}{2}$ 也就是我们现在要求出变化前后分数相同的方案数 设$m=\\sum\\limits_{i=1}^{n}[a_i==a_{nxt(i)}]$ 与Easy同理，容易发现只有这m题会引起分数差的改变 我们可以从0到$\\left \\lfloor \\frac{m}{2} \\right \\rfloor$枚举$i$表示这m题中有i道导致分数差-1，同时这需要i道导致分数差+1的题来抵消影响 选择这$2i$道题的方案数就是$\\binom{m}{i}\\binom{m-i}{i}$，同时还要乘上$(k-2)^{m-2*i}$，因为剩下的题想不造成影响，各自都有k-2种选择 $i$枚举累加完后，还要再乘上一个$k^{n-m}$，因为那些题无论怎么选都不会造成影响 所以最后可以得到： ANS=\\frac{k^n-k^{n-m}*\\sum\\limits_{i=0}^{\\left \\lfloor \\frac{m}{2} \\right \\rfloor}(\\binom{m}{i}*\\binom{m-i}{i}*(k-2)^{m-2*i})}{2}依式计算即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int mod=998244353; const int N=2e5+5; int n,k,f[N],inv[N],ans,a[N],b[N],m; int fpow(int x,int y,int mod){ int res=1; for(;y;y&gt;&gt;=1,mod?(x*=x)%=mod:x*=x) if(y&amp;1) mod?(res*=x)%=mod:res*=x; return res; } int C(int n,int m){ return f[n]*inv[m]%mod*inv[n-m]%mod; } signed main(){ read(n);read(k); for(int i=1;i&lt;=n;i++) read(a[i]),b[i%n+1]=a[i]; if(k==1){ write(0); return 0; } for(int i=1;i&lt;=n;i++) if(a[i]^b[i]) m++; f[0]=1; for(int i=1;i&lt;=m;i++) f[i]=f[i-1]*i%mod; inv[m]=fpow(f[m],mod-2,mod); for(int i=m-1;i&gt;=0;i--) inv[i]=inv[i+1]*(i+1)%mod; for(int i=0;i*2&lt;=m;i++) (ans+=C(m,i)*C(m-i,i)%mod*fpow(k-2,m-i*2,mod)%mod)%=mod; (ans*=fpow(k,n-m,mod))%=mod; write((fpow(k,n,mod)-ans+mod)%mod*fpow(2,mod-2,mod)%mod); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"},{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1227F1 Wrong Answer on test 233 (Easy Version)","slug":"CF1227F1 Wrong Answer on test 233 (Easy Version)","date":"2019-12-10T12:03:00.000Z","updated":"2019-12-15T08:12:59.519Z","comments":true,"path":"2019/12/10/CF1227F1 Wrong Answer on test 233 (Easy Version)/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/CF1227F1 Wrong Answer on test 233 (Easy Version)/","excerpt":"","text":"CF1227F1 Wrong Answer on test 233 (Easy Version) 点这通往Hard版题解/) Easy版是个dp题 题解：$f[i][j]$表示前$i$道题，$s2$比$s1$多对$j$道题（注意$j$值域$[-n,n]$，所以代码中要额外加个$n$） 初始化$f[0][0]=1$ 转移有两种 假设第$i$题答案为$A$，$i$后面一题答案为$B$ 若$A==B$，则$f[i][j]=f[i-1][j]*k$，意思是无论第i题怎样选，s1和s2的差都不会因此而改变，要么都对，要么都错 若$A!=B$，则$f[i][j]=f[i-1][j-1]+f[i-1][j+1]+(k-2)*f[i-1][j]$，意思是一种自己错的方法，一种自己对的方法，k-2种都错的方法 最后答案就是$\\sum\\limits_{i=1}^{n}f[n][i]$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int mod=998244353; const int N=2005; int n,k,ans,a[N],b[N],f[N][N&lt;&lt;1]; signed main(){ read(n);read(k); for(int i=1;i&lt;=n;i++) read(a[i]),b[i%n+1]=a[i]; //b[]是移位后的a[] if(k==1){ write(0); return 0; } f[0][0+n]=1; for(int i=1;i&lt;=n;i++){ if(a[i]==b[i]){ for(int j=-n;j&lt;=n;j++) f[i][j+n]=f[i-1][j+n]*k%mod; } else{ for(int j=-n;j&lt;=n;j++) f[i][j+n]=(f[i-1][j-1+n]+f[i-1][j+1+n]+(k-2)*f[i-1][j+n])%mod; } } for(int i=1;i&lt;=n;i++) (ans+=f[n][i+n])%=mod; write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"ABC147X","slug":"ABC147X","date":"2019-12-10T12:02:00.000Z","updated":"2019-12-15T08:16:52.143Z","comments":true,"path":"2019/12/10/ABC147X/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/ABC147X/","excerpt":"","text":"ABC147早上花2个多小时全过了，来写篇总集 ABC147A Blackjack题解：3行签到题，模拟即可 代码：略 ABC147B Palindrome-philia题解：正着反着同时扫，不同就ans++ 代码：略 ABC147C HonestOrUnkind2题解：n很小，所以可以直接$2^n$枚举哪些是好的，一个简便的做法就是通过枚举$1~2^n-1$这些数，第i位为1则表示第i个人是好的，再对每种情况依次去检查每句“好人”说的话，如果与自己的枚举相矛盾则不合法，否则合法就统计1的个数（即好人的个数），取最大的输出 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=17; int n,ans,a[N],x[N][N],y[N][N]; bool check(int s){ for(int i=0;i&lt;n;i++) if(s&gt;&gt;i&amp;1) for(int j=1;j&lt;=a[i];j++) if((s&gt;&gt;x[i][j]&amp;1)!=y[i][j]) return 0; return 1; } int count(int x){ int ans=0; while(x){ if(x&amp;1) ans++; x&gt;&gt;=1; } return ans; } signed main(){ read(n); for(int i=0;i&lt;n;i++){ read(a[i]); for(int j=1;j&lt;=a[i];j++) read(x[i][j]),read(y[i][j]),x[i][j]--; } int lim=1&lt;&lt;n; for(int s=0;s&lt;lim;s++) if(check(s)) ans=max(ans,count(s)); write(ans); } ABC147D Xor Sum 4题解：注意到异或，这说明所有的异或值都是各自独立的，我们就可以用每一位上1的个数乘每一位上0的个数得到答案中该位上的数 十分巧妙的是，虽然这是二进制，但并不用考虑高精（我就打了高精），因为改为的单位值乘上该位的数值，自动就会帮你进位到较高位，依次类推 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int mod=1e9+7; int ans,cnt[70],n; signed main(){ read(n); for(int i=1,x;i&lt;=n;i++){ read(x); for(int j=0;j&lt;60;j++) if(x&gt;&gt;j&amp;1ll) cnt[j]++; //cnt[i]表示第i位上1的个数 } for(int i=0;i&lt;60;i++) (ans+=cnt[i]*(n-cnt[i])%mod*((1ll&lt;&lt;i)%mod)%mod)%=mod; write(ans); } ABC147E Balanced Path题解：递推题，详见这里 代码：同上 ABC147F Sum Difference题解：递推题，详见这里 代码：同上","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.yzcthinktwice.com/tags/AtCoder/"},{"name":"总集","slug":"总集","permalink":"https://blog.yzcthinktwice.com/tags/总集/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"ABC147F Sum Difference","slug":"ABC147F Sum Difference","date":"2019-12-10T12:01:00.000Z","updated":"2019-12-15T08:14:22.033Z","comments":true,"path":"2019/12/10/ABC147F Sum Difference/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/ABC147F Sum Difference/","excerpt":"","text":"ABC147F Sum Difference 题解：记有$N$个数，起始为$s$，公差为$d$，高桥那有$n$个数，有$k_1$份$d$，青木那有$m$个数，$k_2份d$ 显然的，我们可以将高桥的值设为$(ns+k1d)$，将青木的值设为$(ms+k2d)$ 则$\\Delta=(n-m)s+(k1-k2)d$ 又因为$n+m=N$,$k_1+k_2=\\sum\\limits_{i=0}^{N-1}i=N*(N-1)/2$ 所以$\\Delta=(2n-N)s+(2k_1-N(N-1)/2)*d$ 也就是说$\\Delta$只与$ns+k_1d$相关，其它的都是些常数 并且，其实$k_1\\in[\\sum\\limits_{i=0}^{n-1}i,\\sum\\limits_{i=N-n}^{N-1}i]$，区间内的所有整数$k_1$都可以取到，这一点很容易证明 因此现在问题变成了给出N+1个形如$\\{ ns+k_1d |k_1\\in[\\sum\\limits_{i=0}^{n-1}i,\\sum\\limits_{i=N-n}^{N-1}i] \\}$的等差数列，求它们并集的大小 注意到公差都是d，这说明两个不同的等差数列是否有交集只取决于他们的起点%d的值，我们记起点$n*s\\equiv p (\\mod d)$，则可以将p值相同的等差数列放在一起处理 此时p值相同的等差数列又好比一条条线段，让你求它们所覆盖的总点数 这就十分好处理了，先记下每条线段的左右端点，按照左右端点从左到右再排个序，维护左右端点极值的同时分类讨论，扫一遍即可 值得注意的是，因为算法中用到了模d，而d的值域是包括0的，所以还需要特判d==0： s==0则直接输出1 s!=0则直接输出n+1 在我的代码中会有不少冗余的部分，主要是为了提供一个比较容易理解的思路 另外，代码中并没有特意算出p值，具体处理可以见注释 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=2e5+5; int ans,n,s,d; /*该结构体记录一个精简后等差数列的信息*/ struct seg{ int i,l,r; //i是n，l是左端点，r是右端点 inline bool operator &lt; (const seg &amp;nt) const { int d1=i%d*s%d,d2=nt.i%d*s%d; //d1和d2是两个等差数列的p值 if(d1^d2) return d1&lt;d2; //将p值作为第一关键字 if(l^nt.l) return l&lt;nt.l; //然后将左端点从左向右排（其实好像并不用考虑相同的l和r） return r&gt;nt.r; } }f[N]; /*计算l+l+1+...+r-1+r*/ int calc(int l,int r){ return (l+r)*(r-l+1)/2; } signed main(){ read(n);read(s);read(d); if(d==0){ //特判 if(s==0) write(1); else write(n+1); return 0; } for(int i=0;i&lt;=n;i++) f[i]=(seg){i,i*s/d+calc(0,i-1),i*s/d+calc(n-i,n-1)}; //计算等差数列的各种信息，注意n的枚举是从0到n sort(f,f+1+n); for(int i=0,j;i&lt;=n;i=j+1){ j=i; //区间[i,j]内的等差数列的p值都是相等的 while(j+1&lt;=n&amp;&amp;f[j+1].i%d*s%d==f[i].i%d*s%d) j++; int l=f[i].l,r=f[i].r; //l和r是已访问过最右独立线段并的左右端点 ans+=r-l+1; for(int k=i+1;k&lt;=j;k++){ if(f[k].r&lt;=r) continue; //被当前区间所包括，可以直接跳过不处理 if(f[k].l&lt;=r){ //与当前区间有交集，更新答案和区间右边界 ans-=r-l+1; //删除原贡献 r=f[k].r; ans+=r-l+1; //加上新贡献 } else{ //无交集，重新设置左右边界 l=f[k].l; r=f[k].r; ans+=r-l+1; //加上新贡献 } } } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.yzcthinktwice.com/tags/AtCoder/"},{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"ABC147E Balanced Path","slug":"ABC147E Balanced Path","date":"2019-12-10T12:00:00.000Z","updated":"2019-12-15T08:12:44.718Z","comments":true,"path":"2019/12/10/ABC147E Balanced Path/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/ABC147E Balanced Path/","excerpt":"","text":"ABC147E Balanced Path 题解：方格？取数？向右向下走？ 我首先很自然地想到了f[i][j]表示到(i,j)格最小差的dp，然鹅这是错的，因为这玩意显然是不满足局部最优解的。。。 注意到每个格上的数给的很小，只有80，这意味差的绝对值范围只在0~161x80（161意思是在80x80的棋盘里，要走过161格） 然后考虑f[i][j][k]=0/1表示到第(i,j)格，差的绝对值为k的方案是否存在 转移时枚举f[i-1][j][]和f[i][j-1][]中的所有可行的k（可行的判定即f[i][j][k]=1），加上或减去当前格内的差值，记为k’，将所有的f[i][j][|k’|]赋为1（注意绝对值） 这里发现转移有很多多余的步骤，所以可以添加一点优化 讲一下我选择的优化，优化幅度较小，但代码好打，即额外额外一个g[i][j]表示当前各自上可行解得最大值，这样转移时就不用每次的从0到161x80跑，只需要0到g[i][j-1]和g[i-1][j]就可以了 其它人的优化也是异曲同工，主要目的是减少冗余的试错 因为最后答案既要满足最优，又要满足可行，所以$ans= \\min \\{ k|f[n][m][k]==1 \\}$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=82; int n,m,a[N][N],b[N][N],g[N][N]; bool f[N][N][12801]; signed main(){ read(n);read(m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) read(a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) read(b[i][j]),a[i][j]=abs(a[i][j]-b[i][j]); //反正只需要一个差，就先都算出来 f[1][1][a[1][1]]=1; g[1][1]=a[1][1]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ if(i&gt;1){ for(int k=0;k&lt;=g[i-1][j];k++) if(f[i-1][j][k]) f[i][j][abs(k-a[i][j])]=f[i][j][k+a[i][j]]=1; g[i][j]=max(g[i][j],g[i-1][j]+a[i][j]); } if(j&gt;1){ for(int k=0;k&lt;=g[i][j-1];k++) if(f[i][j-1][k]) f[i][j][abs(k-a[i][j])]=f[i][j][k+a[i][j]]=1; g[i][j]=max(g[i][j],g[i][j-1]+a[i][j]); } } for(int k=0;k&lt;=g[n][m];k++) if(f[n][m][k]){ write(k); return 0; } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.yzcthinktwice.com/tags/AtCoder/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1223E Paint the Tree","slug":"CF1223E Paint the Tree","date":"2019-12-10T11:57:00.000Z","updated":"2019-12-15T08:12:52.052Z","comments":true,"path":"2019/12/10/CF1223E Paint the Tree/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/CF1223E Paint the Tree/","excerpt":"","text":"CF1223E Paint the Tree 锻炼了转化题意的能力 题解：首先转化题意：题目告诉你一个点最多k种颜色，每种颜色最多两次，两端点同色边能获得它的贡献 显然的，同色获贡献，换句话说，就是如果想要某条边的贡献的话，就要将它们涂上同一种颜色，也就是说，一个点最多选k条相连边的贡献 此时，题意变为选若干条边，规定每个点的边集中最多选k条，问最大边权和 问最大价值，肯定要用贪心，但在这里只能是个局部贪心，即在每在所有相连边里，在满足规定的前提下，尽可能选大边 注意到一个点连出的会有两种边，父边和子边，如果不选父边的话，就可以在子边里贪心选k条，否则就只能选k-1条（即减去第k大的子边） 于是设$f[x][1/0]$表示以x为根的子树内的最大边权和，1表示选父边，0表示不选 需要注意的是，对于$f[x][1]$是并不包括父边贡献的，因为对它的定义是以x为根的子树内的最大边权和，搞清楚设的是什么，这很重要 对于转移，$f[x][0]$就是累加子边里最大的k个价值，而$f[x][1]$是k-1个 具体的，子边的价值是指$\\max(f[son][0],f[son][1]+w[x][son])$ 另外在代码中还有许多巧妙的小细节，有助于精简代码 如先将$f[x][1]$看成$f[x][0]$一起处理，最后再减去第k大的子边贡献 又如先假设都不选子边，累加上$f[son][0]$，经对$f[son][1]+w[x][son]-f[son][0]$进行排序，最后如果排序出来的前k个是正数（即选子边更优）的话，就也累加上，更新最优值，这个最优值就是$f[x][0]$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=5e5+5; int en,h[N],n,k,f[N][2]; struct edge{ int n,v,w; }e[N&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void dfs(int x,int fa){ int tot=0; vector&lt;int&gt; a; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==fa) continue; dfs(y,x); tot+=f[y][0]; //假设都不选子边 a.push_back(f[y][1]+e[i].w-f[y][0]); } sort(a.begin(),a.end(),greater&lt;int&gt;()); for(int i=0;i&lt;min((int)a.size(),k);i++) if(a[i]&gt;0) tot+=a[i]; //拿差值更新最优值 f[x][0]=f[x][1]=tot; if(k&lt;=a.size()&amp;&amp;a[k-1]&gt;0) f[x][1]-=a[k-1]; //除去第k大的，留给父边 } void doit(){ read(n);read(k); for(int i=1;i&lt;=n;i++) h[i]=0; en=0; for(int i=1,x,y,z;i&lt;n;i++){ read(x);read(y);read(z); add(x,y,z); add(y,x,z); } dfs(1,0); write(f[1][0]);puts(&quot;&quot;); } signed main(){ int t; read(t); while(t--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF799D Field expansion","slug":"CF799D Field expansion","date":"2019-12-10T11:56:00.000Z","updated":"2019-12-15T08:14:18.166Z","comments":true,"path":"2019/12/10/CF799D Field expansion/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/CF799D Field expansion/","excerpt":"","text":"CF799D Field expansion 题解：虽然n给的范围很大，但首先要明确，最坏情况下也至多操作34次，因为$a,b\\leq2^{17}$，所以34之后的操作都可以无视 这其实就说明这道题可以用指数级算法解决，如bfs 考虑在bfs设两个参数$x$和$y$，分别表示两边的目标放大倍数，并且使$x&lt;y$ 贪心的，操作肯定是从大到小选的 这样每次操作至多只会产生两种新状态，要么在$x$中砍掉一定倍数，要么在$y$中砍掉一定倍数 如果某个时刻$x$和$y$都等于1了，就说明已经合法，输出答案 否则到不了就无解输-1 下面的代码看起来可能是$2^{34}$的，但其实是$2^{17}$的，因为在一边达到目标倍数后，它的x就一直会保持1的状态被map记录下，不再增加新状态，从而就从双选变成单选了 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define pii pair&lt;int,int&gt; #define x first #define y second const int N=1e5+5; int a,b,h,w,n,val[N]; queue&lt;pii&gt; q; map&lt;pii,int&gt; v; //map记录该状态有没有走过，至少走几步 pii adjust(pii x){ //维护x和y，使得x始终y if(x.x&gt;x.y) swap(x.x,x.y); return x; } int divi(int x,int y){ //计算目标放大倍数 return x/y+(x%y!=0); } signed main(){ read(a);read(b);read(h);read(w);read(n); for(int i=1;i&lt;=n;i++) read(val[i]); sort(val+1,val+1+n,greater&lt;int&gt;()); //倒着排序 int lim=min(34,n); //最大操作次数 pii hii=pii(divi(a,h),divi(b,w)),wii=pii(divi(a,w),divi(b,h)); //旋转也可以，所以有两种起始状态 v[hii]=v[wii]=1; //起始步数为1 q.push(hii); q.push(wii); while(!q.empty()){ //bfs pii now=q.front(); q.pop(); int step=v[now]; if(now.x==1&amp;&amp;now.y==1){ write(step-1); //操作次数=步数-1 return 0; } if(step&gt;lim) continue; pii nxt=adjust(pii(divi(now.x,val[step]),now.y)); //该操作给x if(v[nxt]==0){ //没有走过就走 v[nxt]=step+1; q.push(nxt); } nxt=adjust(pii(now.x,divi(now.y,val[step]))); //该操作给y if(v[nxt]==0){ v[nxt]=step+1; q.push(nxt); } } write(-1); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.yzcthinktwice.com/tags/搜索/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P2515 [HAOI2010]软件安装","slug":"P2515 [HAOI2010]软件安装","date":"2019-12-10T11:12:00.000Z","updated":"2019-12-15T08:17:22.137Z","comments":true,"path":"2019/12/10/P2515 [HAOI2010]软件安装/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/P2515 [HAOI2010]软件安装/","excerpt":"","text":"P2515 [HAOI2010]软件安装 十分巧妙的一道缩点+dfs序上背包好题 题解容易发现一个强联通分量里的所有点都是相互依存的，也就是说一个选，个个选，所以不妨把代价、贡献分别求和并缩点 缩完点后是个有着森林性质的有向图，自然的，加个虚点，把所有树根连在一起，合成一棵树 接下来的操作就十分玄学巧妙了，是复杂度十分优秀的dfs序dp（我是第一次见到。。。） 先跑出这棵树的dfs序，并处理出一些东西 记$id[i]$表示dfs序第i位的节点编号，$sz[i]表示以i为根的子树的大小$，$cost[i]$为节点的代价，$val[i]$为节点的贡献，$pre[i]$表示树上，根到i父亲的代价的和 设$f[i][j]$表示dfs序上，前i-1个点（注意，这是精华所在），用了j单位内存时的最大价值 转移分成两类，采用刷表法 选择当前节点 f[i+1][j+cost[id[i]]]=\\max\\{ f[i][j] \\} +val[id[i]] 不选择当前节点 f[i+sz[id[i]]][j]=\\max\\{ f[i][j] \\} 最后答案就是$f[新树节点数+1][m]$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=105,M=505; int f[N][M],n,m,du[N],id[N],sz[N],cn,en,h[N],dfn[N],cnt,low[N],st[N],lim,scc[N],cost[N],val[N],w[N],s[N],pre[N]; bool v[N]; struct edge{ int n,u,v; }e[N&lt;&lt;1]; void add(int x,int y){ e[++en]=(edge){h[x],x,y}; h[x]=en; } void tarjan(int x){ low[x]=dfn[x]=++cnt; st[++lim]=x; v[x]=1; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); } else{ if(v[y]) low[x]=min(low[x],dfn[y]); } } if(low[x]==dfn[x]){ int top; cn++; for(;;){ top=st[lim--]; v[top]=0; scc[top]=cn; cost[cn]+=w[top]; val[cn]+=s[top]; if(top==x) break; } } } void dfs(int x){ id[++cnt]=x; sz[x]=1; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; pre[y]=pre[x]+cost[x]; dfs(y); sz[x]+=sz[y]; } } signed main(){ read(n);read(m); for(int i=1;i&lt;=n;i++) read(w[i]); for(int i=1;i&lt;=n;i++) read(s[i]); for(int i=1,x;i&lt;=n;i++){ read(x); if(x) add(x,i); } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); memset(h,0,sizeof h); int enn=en; for(int i=1;i&lt;=enn;i++){ int x=e[i].u,y=e[i].v; if(scc[x]==scc[y]) continue; add(scc[x],scc[y]); du[scc[y]]++; } for(int i=1;i&lt;=cn;i++) if(!du[i]) add(0,i); //加虚点 cnt=0; dfs(0); for(int i=1;i&lt;=cnt;i++){ for(int j=pre[id[i]];j&lt;=m-cost[id[i]];j++) //选 f[i+1][j+cost[id[i]]]=max(f[i+1][j+cost[id[i]]],f[i][j]+val[id[i]]); for(int j=pre[id[i]];j&lt;=m;j++) //不选 f[i+sz[id[i]]][j]=max(f[i+sz[id[i]]][j],f[i][j]); } write(f[cnt+1][m]); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"缩点","slug":"缩点","permalink":"https://blog.yzcthinktwice.com/tags/缩点/"},{"name":"dfs序","slug":"dfs序","permalink":"https://blog.yzcthinktwice.com/tags/dfs序/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P1485 火枪打怪","slug":"P1485 火枪打怪","date":"2019-12-10T11:10:00.000Z","updated":"2019-12-15T08:16:48.198Z","comments":true,"path":"2019/12/10/P1485 火枪打怪/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/10/P1485 火枪打怪/","excerpt":"","text":"P1485 火枪打怪 巧妙地使用前缀和进行复杂度优化（其实是后缀，但反着做就是前缀了qwq） 题解：很明显，对于p我们要进行二分答案，复杂度一只log 但这也意味着check函数复杂度只能为线性的，这就是问题的难度所在 首先，朴素地想，可以从右往左打怪，同时维护左边每个怪的剩余血量$b_i$，如果枚举到$i$时，$b_i&lt;0$就说明它死了，否则就一直用子弹，知道$b_i&lt;0$或子弹用光 因为p是相对固定的，所以可以先用sqrt()得出溅射的最远距离$s$ 假设从左到右第i只怪原有血量为$a_i$，在$i$右边用了$m$次子弹，每次子弹直接作用在$x_j$位置上 可以得到计算式：$b_i=a_i-\\sum\\limits_{j=1}^{m}[p-(x_j-i)^2]$ 尝试对它进行拆分： \\ \\ \\ \\ a_i-\\sum\\limits_{j=1}^{m}[p-(x_j-i)^2]=a_i-\\sum\\limits_{j=1}^{m}(p-x_j^2-i^2+2x_ji)=a_i-\\sum\\limits_{j=1}^{m}p+\\sum\\limits_{j=1}^{m}x_j^2+\\sum\\limits_{j=1}^{m}i^2-\\sum\\limits_{j=1}^{m}2x_ji=a_i-m(p-i^2)+\\sum\\limits_{j=1}^{m}x_j^2-2i\\sum\\limits_{j=1}^{m}x_j发现对于此式需要维护三个东西：$m$，$\\sum\\limits_{j=1}^{m}x_j^2$，$\\sum\\limits_{j=1}^{m}x_j$ 对于三者分别开一个记录后缀和的数组，每用一枚子弹，就更新一下 对于距离的限制，用后缀和简单差分一下即可 这样就可以做到$O(1)$ 查询，$O(n)$判断了 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=5e5+5; int a[N],sum1[N],sum2[N],sum3[N],ans,n,k; inline int min(const int &amp;x,const int &amp;y){return x&lt;y?x:y;} /*sum1[]是第三个，sum2[]是第二个，sum3[]是第一个*/ bool check(int p){ int ma=sqrt(p); //预处理出最大距离 for(int i=n;i&gt;=1;i--){ sum1[i]=sum1[i+1]; //继承 sum2[i]=sum2[i+1]; sum3[i]=sum3[i+1]; int lim=min(n+1,i+ma+1); int hp=a[i]-(sum3[i]-sum3[lim])*(p-i*i); //从三个后缀和那分别查询 hp+=sum2[i]-sum2[lim]; hp-=2*i*(sum1[i]-sum1[lim]); if(hp&lt;0) continue; //死了就跳过 while(hp&gt;=0){ hp-=p; sum1[i]+=i; //分别维护三个后缀和 sum2[i]+=i*i; sum3[i]++; if(sum3[i]&gt;k) return 0; //没子弹了就失败 } } return 1; } signed main(){ read(n);read(k); for(int i=1;i&lt;=n;i++) read(a[i]); int l=1,r=1e12; while(l&lt;=r){ int mid=l+r&gt;&gt;1; if(check(mid)) r=mid-1,ans=mid; else l=mid+1; } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://blog.yzcthinktwice.com/tags/二分答案/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P2365 任务安排","slug":"P2365 任务安排","date":"2019-12-04T12:08:01.000Z","updated":"2019-12-15T08:16:59.358Z","comments":true,"path":"2019/12/04/P2365 任务安排/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/04/P2365 任务安排/","excerpt":"","text":"P2365 任务安排 洛谷数据较弱，LOJ有加强版 前缀和+斜率优化dp好题 题解：考虑最朴素的$O(n^3)$dp 记t[i]表示各任务时间的前缀和，c[i]为各任务花费的前缀和 设f[i][j]表示前i个任务，分j批，且i是第j批的最后一个的最小花费 得到方程 f[i][j]=min\\{f[k][j-1]+(t[i]+S*j)*(c[i]-c[k])\\}尝试优化dp 注意到j这一维作用并不是很大，只是为了消除后效性，因为后面的任务不知道自己被分在第几批，前面有过几次S 考虑改用费用提前计算来消除后效性使得状态只需i一维 改设f[i]表示前i个任务造成的最小代价，且i是新分出一批的最后一个 我们知道分出i这一批会新产生两部分代价，一部分是这新一批内部产生的$t[i]*(c[i]-c[j])$，另一部分是这一批开机的S对后面所有任务产生的影响 加起来就可以得到一个新的二维dp方程 f[i]=min\\{f[j]+t[i]*(c[i]-c[j])+S*(c[n]-c[j])\\}这已经可以使你通过洛谷上$O(n^2)$的数据了，但其实还可以继续优化 我们考虑斜率优化 先拆掉min并对上方的二维方程进行整理，得到$f[i]=f[j]-(S+t[i])c[j]+t[i]c[i]+S*c[n]$ 常规操作，假设现有两个决策点j和k，且k优于j，将两者代入可以得到 \\small{f[j]-(S+t[i])*c[j]+t[i]*c[i]+S*c[n]\\geq f[k]-(S+t[i])*c[k]+t[i]*c[i]+S*c[n]}继续整理： f[j]-(S+t[i])*c[j]\\geq f[k]-(S+t[i])*c[k]f[j]-f[k]\\geq (S+t[i])*(c[j]-c[k])\\frac{f[j]-f[k]}{c[j]-c[k]} \\geq S+t[i]发现左边的是个斜率，右边的满足单调性 所以就可以把这些东西用单调队列大胆维护了 再用每次的队首当作j来转移 dp被优化到了$O(n)$ 注意比较斜率的一个常规操作，将除法交换成乘法以避免精度误差 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define qn (q.size()-1) const int N=3e5+5; int n,s,t[N],c[N],f[N]; deque&lt;int&gt; q; signed main(){ read(n);read(s); for(int i=1,x,y;i&lt;=n;i++){ read(x);read(y); t[i]=t[i-1]+x; c[i]=c[i-1]+y; } q.push_back(0); for(int i=1;i&lt;=n;i++){ while(q.size()&gt;1&amp;&amp;(c[q[1]]-c[q[0]])*(t[i]+s)&gt;=(f[q[1]]-f[q[0]])) q.pop_front(); //不满足了就踢掉 f[i]=f[q[0]]-(s+t[i])*c[q[0]]+t[i]*c[i]+s*c[n]; //转移 while(q.size()&gt;1&amp;&amp;(f[i]-f[q[qn]])*(c[q[qn]]-c[q[qn-1]])&lt;=(f[q[qn]]-f[q[qn-1]])*(c[i]-c[q[qn]])) q.pop_back(); //维护最优 q.push_back(i); } write(f[n]); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"LOJ","slug":"LOJ","permalink":"https://blog.yzcthinktwice.com/tags/LOJ/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://blog.yzcthinktwice.com/tags/斜率优化/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P2569 [SCOI2010]股票交易","slug":"P2569 [SCOI2010]股票交易","date":"2019-12-04T12:08:00.000Z","updated":"2019-12-15T08:17:27.026Z","comments":true,"path":"2019/12/04/P2569 [SCOI2010]股票交易/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/04/P2569 [SCOI2010]股票交易/","excerpt":"","text":"P2569 [SCOI2010]股票交易 单调队列优化dp好题，难度约等于摆渡车 题解：f[i][j]表示前i天，手上剩有j只股票最多能赚的钱 初始f[i][0]=0，其它都赋-inf 转移需要分类讨论： 1. 从0只股票开始买直接计算花多少钱即可$f[i][j]=-AP_i*j$ 2. 不进行任何买卖直接从前一天的所有状态继承$f[i][j]=f[i-1][j]$ 3. 从之前几天的基础上买入股票首先要明确f[i][]是从f[i-w-1][]转移的 因为区间$[1,i-w-1)$内的状态，都可以通过情况2转移到f[i-w-1][]，所以只考虑这一天就够了 设第i-w-1天剩余k只股票，我们可以得到如下方程 $f[i][j]=\\max \\{ f[i-w-1][k]-(j-k) * AP_i | k \\in [j-AS_i,j) \\}$ 复杂度是$O(nm^2)$的，所以考虑优化方程 展开 $f[i][j]=\\max \\{ f[i-w-1][k]-j AP_i+k AP_i | k \\in [j-AS_i,j) \\}$ 提出 $f[i][j]=\\max \\{ f[i-w-1][k]+k AP_i | k \\in [j-AS_i,j) \\}-j AP_i$ 此时发现唯一变量k的限制范围类似滑动窗口，且与k相关的值具有单调性，所有可以用单调队列维护k 4. 从之前几天的基础上卖出股票朴素方程如下： $f[i][j]=\\max \\{ f[i-w-1][k]+(k-j) * BP_i | k \\in (j,j+BS_i] \\}$ 化简后得到： $f[i][j]=\\max \\{ f[i-w-1][k]+k BP_i | k \\in (j,j+BS_i] \\}-j BP_i$ 与情况3同理可以用单调队列进行维护 特别的，情况3、4转移时为了让所有元素都能正常进出队列，要从较劣的一侧开始转移，即买入用顺序枚举，卖出用逆序枚举 显然的，f[i][j]的最终取值就是上述四种情况转移过来的最大值 最终答案就是f[n][0]，因为明显最后只有把股票都卖光才是最优的 代码#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=2e3+5; int f[N][N],n,m,w,ap,bp,as,bs; signed main(){ read(n);read(m);read(w); memset(f,128,sizeof f); for(int i=1;i&lt;=n;i++){ read(ap);read(bp);read(as);read(bs); f[i][0]=0; for(int j=1;j&lt;=as;j++) //从无股票的状态开始购买 f[i][j]=-ap*j; for(int j=0;j&lt;=m;j++) //不进行买卖，直接从上一天转移 f[i][j]=max(f[i][j],f[i-1][j]); if(i&lt;=w) continue; //防止负下标 deque&lt;int&gt; buy; for(int j=0;j&lt;=m;j++){ //从前面几天的基础上买入，正向转移 while(!buy.empty()&amp;&amp;buy.front()&lt;j-as) buy.pop_front(); //弹掉不在范围内的 while(!buy.empty()&amp;&amp;f[i-w-1][buy.back()]+buy.back()*ap&lt;=f[i-w-1][j]+j*ap) buy.pop_back(); //弹掉不优的 buy.push_back(j); //加入新的 f[i][j]=max(f[i][j],f[i-w-1][buy.front()]+buy.front()*ap-j*ap); //转移 } deque&lt;int&gt; sell; for(int j=m;j&gt;=0;j--){ //从前面几天的基础上卖出，反向转移 while(!sell.empty()&amp;&amp;sell.front()&gt;j+bs) sell.pop_front(); while(!sell.empty()&amp;&amp;f[i-w-1][sell.back()]+sell.back()*bp&lt;=f[i-w-1][j]+j*bp) sell.pop_back(); sell.push_back(j); f[i][j]=max(f[i][j],f[i-w-1][sell.front()]+sell.front()*bp-j*bp); } } write(f[n][0]); //最优解最后肯定是全卖完的 }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"单调队列","slug":"单调队列","permalink":"https://blog.yzcthinktwice.com/tags/单调队列/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW15 汽车加油驾驶问题","slug":"FLOW15 汽车加油驾驶问题","date":"2019-12-03T12:49:15.000Z","updated":"2019-12-15T08:11:38.720Z","comments":true,"path":"2019/12/03/FLOW15 汽车加油驾驶问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW15 汽车加油驾驶问题/","excerpt":"","text":"FLOW15 汽车加油驾驶问题 模型：分层图最短路径-&gt;最短路径 题意：给定一个 $N×N$ 的方形网格，设其左上角为起点，坐标为 $(1,1)$ ，X 轴向右为正， Y 轴向下为正，每个方格边长为 1 。 一辆汽车从起点出发驶向右下角终点 $(N,N)$ 。 在若干个网格交叉点处，设置了油库。汽车在行驶过程中应遵守如下规则：汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边；出发时汽车已装满油，在起点与终点处不设油库； 汽车经过一条网格边时，若其 X 坐标或 Y 坐标减小，则应付费用 $B$ ，否则免付费用； 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$；在需要时可在网格点处增设油库，并付增设油库费用 $C$ (不含加油费用 $A$ )。 求出汽车从起点出发到达终点的一条所付费用最少的行驶路线。 题解：又是一道假网络流题 一道分层图最短路题 对于k步的条件，我们将原图拆成k+1层图，从下到上第i层表示此时的油够走k-i+1步 对于每个格子 都要从下往上将自己的每一层都连起来，代价为0 向下向右连边没有代价，向上向左连边代价为$B$ 对于加油站 这格上的每一层都要向第一层连边，代价为$A$ 向四周连边时，都是从自己的第一层，到目标的第二层，因为从自己这出去肯定是满油的 对于普通格 自己的每一层i都要向四周的更高层i+1连边，因为剩余多少步数都是有可能的 还要从自己的每一层向自己的第一层连边，代价为$A+C$，意思是建个加油站加满油 跑一遍最短路，再从每一层的终点处搜集最小的答案即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=2e5+5; int n,k,a,b,c,dis[N],h[N],en,ans=0x3f3f3f3f; struct edge{ int n,v,w; }e[60*N]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } int calc(int x,int y,int lv){ return n*n*(lv-1)+(x-1)*n+y; } struct node{ int x,v; inline bool operator &lt; (const node &amp;nt) const { return v&gt;nt.v; } }; void dij(int s){ priority_queue&lt;node&gt; q; memset(dis,0x3f,sizeof dis); dis[s]=0; q.push((node){s,0}); while(!q.empty()){ node x=q.top(); q.pop(); if(dis[x.x]!=x.v) continue; for(int i=h[x.x];i;i=e[i].n){ int y=e[i].v; if(dis[x.x]+e[i].w&lt;dis[y]){ dis[y]=dis[x.x]+e[i].w; q.push((node){y,dis[y]}); } } } } signed main(){ read(n);read(k);read(a);read(b);read(c); for(int i=1,x;i&lt;=n;i++) for(int j=1;j&lt;=n;j++){ read(x); for(int l=1;l&lt;=k;l++) add(calc(i,j,l),calc(i,j,l+1),0); if(x){ for(int l=2;l&lt;=k+1;l++) add(calc(i,j,l),calc(i,j,1),a); if(i&lt;n) add(calc(i,j,1),calc(i+1,j,2),0); if(j&lt;n) add(calc(i,j,1),calc(i,j+1,2),0); if(i&gt;1) add(calc(i,j,1),calc(i-1,j,2),b); if(j&gt;1) add(calc(i,j,1),calc(i,j-1,2),b); } else{ for(int l=1;l&lt;=k;l++){ if(i&lt;n) add(calc(i,j,l),calc(i+1,j,l+1),0); if(j&lt;n) add(calc(i,j,l),calc(i,j+1,l+1),0); if(i&gt;1) add(calc(i,j,l),calc(i-1,j,l+1),b); if(j&gt;1) add(calc(i,j,l),calc(i,j-1,l+1),b); } for(int l=2;l&lt;=k+1;l++) add(calc(i,j,l),calc(i,j,1),a+c); } } dij(calc(1,1,1)); for(int i=1;i&lt;=k+1;i++) ans=min(ans,dis[calc(n,n,i)]); write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"最短路","slug":"最短路","permalink":"https://blog.yzcthinktwice.com/tags/最短路/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW14 孤岛营救问题","slug":"FLOW14 孤岛营救问题","date":"2019-12-03T12:49:14.000Z","updated":"2019-12-15T08:15:05.320Z","comments":true,"path":"2019/12/03/FLOW14 孤岛营救问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW14 孤岛营救问题/","excerpt":"","text":"FLOW14 孤岛营救问题 模型：分层图最短路径-&gt;最短路径 题意：迷宫的外形是一个长方形，其南北方向被划分为 $n$ 行，东西方向被划分为 $m$ 列， 于是整个迷宫被划分为 $n×m$ 个单元。南北或东西方向相邻的 2 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成 $p$ 类， 打开同一类的门的钥匙相同，不同类门的钥匙不同。 大兵瑞恩被关押在 $(n,m)$ 单元里，并已经昏迷。迷宫只有一个入口， 在 $(1,1)$ 单元。麦克从一个单元移动到另一个 相邻单元的时间为 1，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。 试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。 题解：又是一道假网络流题 一道经典的状压bfs 把钥匙压成二进制，从(1,1)开始向四周bfs，对每个点的每个状态记个v数组，记录有没有走过 如果走到(n,m)就输出步数 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=12,S=1&lt;&lt;11; const int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1}; int loc[N][N][N][N],key[N][N],n,m,k; bool v[N][N][S]; struct situ{ int x,y,s,step; }; int bfs(){ queue&lt;situ&gt; q; q.push((situ){1,1,key[1][1],0}); v[1][1][key[1][1]]=1; while(!q.empty()){ situ now=q.front(); q.pop(); int x=now.x,y=now.y; if(x==n&amp;&amp;y==m) return now.step; for(int i=0;i&lt;4;i++){ int nx=x+dx[i],ny=y+dy[i]; if(nx&lt;1||ny&lt;1||nx&gt;n||ny&gt;m) continue; if(loc[x][y][nx][ny]==-1) continue; if(loc[x][y][nx][ny]!=(loc[x][y][nx][ny]&amp;now.s)) continue; int ns=now.s|key[nx][ny]; if(v[nx][ny][ns]) continue; v[nx][ny][ns]=1; q.push((situ){nx,ny,ns,now.step+1}); } } return -1; } signed main(){ read(n);read(m);read(k);read(k); while(k--){ int x,y,xx,yy; read(x);read(y);read(xx);read(yy); read(loc[x][y][xx][yy]); if(!loc[x][y][xx][yy]) loc[x][y][xx][yy]=-1; else loc[x][y][xx][yy]=1&lt;&lt;loc[x][y][xx][yy]-1; loc[xx][yy][x][y]=loc[x][y][xx][yy]; } read(k); while(k--){ int x,y,z; read(x);read(y);read(z); key[x][y]|=1&lt;&lt;z-1; } write(bfs()); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://blog.yzcthinktwice.com/tags/状态压缩/"},{"name":"BFS","slug":"BFS","permalink":"https://blog.yzcthinktwice.com/tags/BFS/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW12 软件补丁问题","slug":"FLOW12 软件补丁问题","date":"2019-12-03T12:48:12.000Z","updated":"2019-12-15T08:15:01.283Z","comments":true,"path":"2019/12/03/FLOW12 软件补丁问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW12 软件补丁问题/","excerpt":"","text":"FLOW12 软件补丁问题 模型：最小转移代价-&gt;最短路径 题意：某公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了一批共 $m$ 个补丁程序。对于每一个补丁 $i$ ，都有 2 个与之相应的错误集合 $B_1(i)$ 和 $B_2(i)$ ，使得仅当软件包含 $B_1(i)$ 中的所有错误，而不包含 $B_2(i)$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误 $F_1(i)$ ，而同时加入另一些错误 $F_2(i)$。另外，每个补丁都耗费一定的时间。 试设计一个算法，利用公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。 题解：又是一道假网络流题 一道巧妙的状压最短路 将每一种是否存在的状态各自看做一个节点 预处理出题面所说的四个集合$B_1$,$B_2$,$F_1$,$F_2$压缩后的状态 看看对于每种状态在使用了某个补丁后，会演变出什么新状态，据此连上一条边 由于边数会很多，所以可以在做最短路的同时对于当前状态，枚举每个补丁，看看会产生哪些新边，逐一处理 显然的，最短路起点为全1状态，终点为全0状态 最短路距离即答案 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=25,M=105,S=1&lt;&lt;20; int dis[S],n,m,cost[M],f1[M],f2[M],b1[M],b2[M]; char a[N],b[N]; struct node{ int x,v; inline bool operator &lt; (const node &amp;nt) const { return v&gt;nt.v; } }; void dij(int s){ memset(dis,0x3f,sizeof dis); dis[s]=0; priority_queue&lt;node&gt; q; q.push((node){s,0}); while(!q.empty()){ node x=q.top(); q.pop(); if(dis[x.x]!=x.v) continue; for(int i=1;i&lt;=m;i++) if((b1[i]&amp;x.x)==b1[i]&amp;&amp;(b2[i]&amp;x.x)==0){ int y=((x.x|f1[i])^f1[i])|f2[i]; if(dis[x.x]+cost[i]&lt;dis[y]){ dis[y]=dis[x.x]+cost[i]; q.push((node){y,dis[y]}); } } } } signed main(){ read(n);read(m); for(int i=1;i&lt;=m;i++){ read(cost[i]); scanf(&quot;%s%s&quot;,a,b); for(int j=0;j&lt;n;j++){ if(a[j]==&#39;+&#39;) b1[i]|=1&lt;&lt;j; if(a[j]==&#39;-&#39;) b2[i]|=1&lt;&lt;j; if(b[j]==&#39;-&#39;) f1[i]|=1&lt;&lt;j; if(b[j]==&#39;+&#39;) f2[i]|=1&lt;&lt;j; } } dij((1&lt;&lt;n)-1); if(dis[0]==0x3f3f3f3f) dis[0]=0; write(dis[0]); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://blog.yzcthinktwice.com/tags/状态压缩/"},{"name":"最短路","slug":"最短路","permalink":"https://blog.yzcthinktwice.com/tags/最短路/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW7 试题库问题","slug":"FLOW7 试题库问题","date":"2019-12-03T12:45:07.000Z","updated":"2019-12-15T08:14:25.928Z","comments":true,"path":"2019/12/03/FLOW7 试题库问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW7 试题库问题/","excerpt":"","text":"FLOW7 试题库问题 模型：二分图多重匹配-&gt;网络最大流 题意：假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。 题解： 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x3f3f3f3f; const int N=2050,M=1e6+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans,tot; bool v[N]; struct edge{ int n,v,f; }e[N+M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void exadd(int x,int y,int z){ add(x,y,z); add(y,x,0); } bool bfs(int s,int aim){ memset(d,0,sizeof d); memcpy(cur,h,sizeof cur); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].f){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].f){ int flow=dfs(y,min(rest,e[i].f),aim); rest-=flow; e[i].f-=flow; e[i^1].f+=flow; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(m);read(n); s=1,t=n+m+2; for(int i=1,x;i&lt;=m;i++) exadd(i+s+n,t,read(x)),tot+=x; for(int i=1,nm;i&lt;=n;i++){ exadd(s,i+s,1); read(nm); for(int j=1,x;j&lt;=nm;j++) exadd(i+s,read(x)+s+n,1); } if(dinic(s,t)^tot){ printf(&quot;No Solution!&quot;); return 0; } for(int i=1;i&lt;=m;i++){ if(i^1) puts(&quot;&quot;); write(i);putchar(&#39;:&#39;); int x=i+s+n; for(int i=h[x];i;i=e[i].n) if(e[i].f){ putchar(&#39; &#39;); write(e[i].v-s); } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"https://blog.yzcthinktwice.com/tags/二分图匹配/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW6 最长不下降子序列问题","slug":"FLOW6 最长不下降子序列问题","date":"2019-12-03T12:45:06.000Z","updated":"2019-12-15T08:14:44.758Z","comments":true,"path":"2019/12/03/FLOW6 最长不下降子序列问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW6 最长不下降子序列问题/","excerpt":"","text":"FLOW6 最长不下降子序列问题 模型：最多不相交路径-&gt;网络最大流 题意：给定正整数序列$x_1 \\sim x_n$ ， 计算其最长不下降子序列的长度 $s$。 计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。 如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为 $s$ 的不下降子序列。 题解：将“与之关联的不下降子序列的数量”看成本问题中的“流” 自然的，先拆点，拆成出点和入点 Q1：第一问设f[i]表示以i结尾的最长不下降子序列的长度，$O(n^2)$DP，轻松解决 设此问答案为ans1 Q2：第二问采用网络最大流 因为一个点只能有一次出入，所以此问中的所有边的容量都是为1的 首先，常规操作，在每个点内部（也就是从入点向出点）连边 考虑水流的源点，其f[i]必然是等于ans1的，于是从超级源点向所有源点连边 考虑水流的汇点，其f[i]必然是等于1的，于是从所有汇点向超级汇点连边 考虑水流的存在需满足的要求，对于可以存在水流的点i和j(i&lt;j)，$f[i]+1==f[j]$且$a[i]&lt;=a[j]$，然后对于所有的i,j关系连边 跑一遍最大流，即可得出ans2 Q3：因为1和n能用多次，所以在Q2网络图的基础上将与1或n相关联的边的容量修改为inf 重新跑一遍最大流，即可得出ans3 注意特判ans1==1的情况 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x3f3f3f3f; const int N=1050,M=3e3+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans,ma,ans1,ans2,ans3,f[N],a[N]; bool v[N]; struct edge{ int n,v,f; }e[N+M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void exadd(int x,int y,int z){ add(x,y,z); add(y,x,0); } bool bfs(int s,int aim){ memset(d,0,sizeof d); memcpy(cur,h,sizeof cur); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].f){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].f){ int flow=dfs(y,min(rest,e[i].f),aim); rest-=flow; e[i].f-=flow; e[i^1].f+=flow; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(n); s=1,t=n+n+2; for(int i=1;i&lt;=n;i++){ read(a[i]); f[i]=1; for(int j=1;j&lt;i;j++) if(a[j]&lt;=a[i]) f[i]=max(f[i],f[j]+1); ans1=max(ans1,f[i]); } if(ans1==1){ write(1);puts(&quot;&quot;); write(n);puts(&quot;&quot;); write(n); return 0; } for(int i=1;i&lt;=n;i++){ exadd(i+s,i+s+n,1); if(f[i]==1) exadd(s,i+s,1); if(f[i]==ans1) exadd(i+s+n,t,1); for(int j=i+1;j&lt;=n;j++) if(f[j]==f[i]+1&amp;&amp;a[j]&gt;=a[i]) exadd(i+s+n,j+s,1); } ans2=dinic(s,t); exadd(1+s,1+s+n,oo); exadd(s,1+s,oo); for(int i=2;i&lt;=en;i+=2) e[i].f+=e[i^1].f,e[i^1].f=0; if(f[n]==ans1){ exadd(n+s,n+s+n,oo); exadd(n+s+n,t,oo); } ans3=dinic(s,t); write(ans1);puts(&quot;&quot;); write(ans2);puts(&quot;&quot;); write(ans3); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW5 圆桌问题","slug":"FLOW5 圆桌问题","date":"2019-12-03T12:43:05.000Z","updated":"2019-12-15T08:14:56.783Z","comments":true,"path":"2019/12/03/FLOW5 圆桌问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW5 圆桌问题/","excerpt":"","text":"FLOW5 圆桌问题 模型：二分图多重匹配-&gt;网络最大流 题意：假设有来自 $n$ 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 $r_i$ 。会议餐厅共有 $m$ 张餐桌，每张餐桌可容纳 $c_i$ 个代表就餐。 为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。 试给出满足要求的代表就餐方案。 题解：将“人”看成本问题中的“流” 显然的，“人”是从“单位”流出，在一张餐桌上汇合的 因此从源点向每个单位连条容量为单位人数的边，从每张桌子向汇点连条容量为桌子容量的边 而桌子与对应单位的边的容量为1（因为一张桌子一个单位至多一人） 跑一遍最大流，用超级汇点统计一下能放的人数，不等于餐桌可容纳人数总数的话就代表是不合法的 然后在残量网络里继续处理 枚举桌子，再依次枚举单位，看看对应的边上有无流量，这对应着这张桌子上有没有这个单位的人 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x3f3f3f3f; const int N=505,M=1e5+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans,ma; bool v[N]; struct edge{ int n,v,f; }e[N+M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void exadd(int x,int y,int z){ add(x,y,z); add(y,x,0); } bool bfs(int s,int aim){ memset(d,0,sizeof d); memcpy(cur,h,sizeof cur); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].f){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].f){ int flow=dfs(y,min(rest,e[i].f),aim); rest-=flow; e[i].f-=flow; e[i^1].f+=flow; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(m);read(n); s=1,t=m+n+2; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) exadd(i+s,j+s+n,1); for(int i=1,x;i&lt;=m;i++) exadd(i+s+n,t,read(x)),ma+=x; for(int i=1,x;i&lt;=n;i++) exadd(s,i+s,read(x)); if(dinic(s,t)^ma){ write(0); return 0; } write(1); for(int i=1;i&lt;=m;i++){ puts(&quot;&quot;); int x=i+s+n; for(int i=h[x];i;i=e[i].n) if(e[i].f) write(e[i].v-s),putchar(&#39; &#39;); } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW4 魔术球问题","slug":"FLOW4 魔术球问题","date":"2019-12-03T12:32:04.000Z","updated":"2019-12-15T08:14:39.460Z","comments":true,"path":"2019/12/03/FLOW4 魔术球问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW4 魔术球问题/","excerpt":"","text":"FLOW4 魔术球问题 模型：有向无环图最小路径覆盖-&gt;网络最大流 题意：假设有 n 根柱子，按下述规则在这 n 根柱子中依次放入编号为 1,2,3,4,⋯ 的球：每次只能在某根柱子的最上面放球；在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。 试计算出在 n 根柱子上最多能放多少个球。 题解：又是一道假网络流题 如果是网络流做法的话，应该是将每个球看成点，把符合条件的“关系”看成有向边，跑一遍有向无环图最小路径覆盖（方法见FLOW3 最小路径覆盖问题） 但我选择了贪心来解决这题（主要是代码方便，懒得去搞网络流了。。。） 假设能放m个球，贪心思路就是对于1..m每个球，枚举每根柱子，能放就放，不能放新开一个，直到柱子开完为止 显然的，复杂度$O(nm)$ 贪心正确性不会证，暂时也看不懂，但可以先放出两个版本的证明： 版本一，版本二 另外，其实m的值也是可以$O(1)$计算的 具体的通项公式可以见OEIS A047838（反正我也不会证。。。） 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } vector&lt;int&gt; ans[60]; int n,m; bool check(int x){ return (int)sqrt(x)*(int)sqrt(x)==x; } signed main(){ read(n); m=(n+1)*(n+1)/2-1; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) if(ans[j].empty()||check(ans[j][ans[j].size()-1]+i)){ ans[j].push_back(i); break; } write(m); for(int i=1;i&lt;=n;i++){ puts(&quot;&quot;); for(int j=0;j&lt;ans[i].size();j++){ write(ans[i][j]); if(j!=ans[i].size()-1) putchar(&#39; &#39;); } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://blog.yzcthinktwice.com/tags/贪心/"},{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW3 最小路径覆盖问题","slug":"FLOW3 最小路径覆盖问题","date":"2019-12-03T12:31:03.000Z","updated":"2019-12-15T08:14:49.155Z","comments":true,"path":"2019/12/03/FLOW3 最小路径覆盖问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW3 最小路径覆盖问题/","excerpt":"","text":"FLOW3 最小路径覆盖问题 模型：有向无环图最小路径覆盖-&gt;网络最大流 题意：给定有向图 $G=(V,E)$。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个顶点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。$P$ 中路径可以从 $V$ 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。$G$ 的最小路径覆盖是 $G$ 的所含路径条数最少的路径覆盖。 求一个有向无环图 $G$ 的最小路径覆盖。 题解：将“一条路径”看成本问题中的“流” 自然的，对图进行拆点操作，拆成进点和出点 题目要求两条路径无交点，也就是说每个点只有一个进或一个出，每条边也都只能经过一次 因此从源点向每个进点连条容量1的边，从每个出点向汇点连条容量1的边 对于每条读入的边$(u,v)$，从u的出点向v的进点连条容量1的边 跑遍最大流 最小路径覆盖数=点数-最大流 证明略去，个人认为这与“无环图中森林数=点数-边数”基本是一个道理 对于方案的输出，因为一条边只有选和不选两种选择，所以只需要在残量网络上跑一遍，将在同一个联通块中的点一起输出即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x3f3f3f3f; const int N=405,M=6e3+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans; bool v[N]; struct edge{ int n,v,f; }e[N+M&lt;&lt;1]; void add(int x,int y,int z){ e[++en]=(edge){h[x],y,z}; h[x]=en; } void exadd(int x,int y,int z){ add(x,y,z); add(y,x,0); } bool bfs(int s,int aim){ memset(d,0,sizeof d); memcpy(cur,h,sizeof cur); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].f){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].f){ int flow=dfs(y,min(rest,e[i].f),aim); rest-=flow; e[i].f-=flow; e[i^1].f+=flow; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } void print(int x){ for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==s||y==t) continue; if(e[i].f) continue; v[y-n-1]=1; putchar(&#39; &#39;);write(y-n-1); print(y-n); } } signed main(){ read(n);read(m); s=1,t=n*2+2; for(int i=1,x,y;i&lt;=m;i++){ read(x);read(y); exadd(x+s,y+s+n,1); } for(int i=1;i&lt;=n;i++) exadd(s,i+1,1),exadd(i+n+s,t,1); ans=n-dinic(s,t); for(int i=1;i&lt;=n;i++) if(!v[i]){ write(i); print(i+s); puts(&quot;&quot;); } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW2 太空飞行计划问题","slug":"FLOW2 太空飞行计划问题","date":"2019-12-03T12:30:02.000Z","updated":"2019-12-15T08:14:14.184Z","comments":true,"path":"2019/12/03/FLOW2 太空飞行计划问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW2 太空飞行计划问题/","excerpt":"","text":"FLOW2 太空飞行计划问题 模型：最大权闭合图-&gt;网络最小割 题意：现已确定了一个可供选择的实验集合 $E = \\{ E_1, E_2, \\cdots, E_m \\}$，和进行这些实验需要使用的全部仪器的集合 $I = \\{ I_1, I_2, \\cdots, I_n \\}$。实验 $E_j$ 需要用到的仪器是 $I$ 的子集 $R_j \\subseteq I$。 配置仪器 $I_k$ 的费用为 $c_k$ 美元。实验 $E_j$ 的赞助商已同意为该实验结果支付 $p_j$ 美元。对于给定的实验和仪器配置情况，找出净收益最大的试验计划。 题解：最大权闭合子图例题 可以从 $S$ 向每个实验连一条容量为 $p_i$ 的边，每个实验向所需要的仪器连一条容量为 $inf$ 的边，每个仪器向 $T$ 连一条容量为 $c_i$ 的边 假设所有实验都做，再计算出网络图的最小割，最小割就是要花费的钱 答案就是总的能赚的钱减去花费的钱 为什么要看做最小割呢？因为如果某个实验的收益为负数，但是它用到的仪器能为别的实验所用，那么就相当于你花了这个实验的赞助商给你的钱为别的实验买仪器，具象化在网络图上，就是仪器那个点给这个实验一个流，把这个实验流出去的抵消掉了。当然，也会存在那种无论怎么买仪器都不划算的实验，这样的实验有一个特点，因为它不能供给仪器的需求，所以源点到它的残流一定是0，就是说不管是正向边还是反向边都是0，同样的那些可以供给的，源点到它的残留一定大于0，也就是正向边或者反向边大于0，说明做这个实验能赚钱。 然后来看所选择实验和仪器的输出 考虑用dinic跑网络流，注意到最后一遍跑完分层图后的有“存在”点都是最“邻近”超级源点和超级汇点的，也就是采取最小割后，这些点都是与两个超级点在同一集合中的 所以在网络流后枚举一遍每个点在分层图中的深度，有深度（存在）就表示要选择，输出即可 代码：#include &lt;bits/stdc++.h&gt; #define fill(x,y) memset(x,y,sizeof x) #define copy(x,y) memcpy(x,y,sizeof x) using namespace std; inline int read(int &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } inline void write(int x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x7fffffff; const int N=100+5,M=N*N+5; int en=1,h[N],d[N],n,m,s,t,use,cur[N],ans; struct edge{int n,v,w;}e[M&lt;&lt;1]; inline void add(int x,int y,int z){e[++en]=(edge){h[x],y,z};h[x]=en;} inline void exadd(int x,int y,int z){add(x,y,z);add(y,x,0);} bool bfs(int s,int aim){ fill(d,0); copy(cur,h); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].w){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].w){ int tp=dfs(y,min(rest,e[i].w),aim); rest-=tp; e[i].w-=tp; e[i^1].w+=tp; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(n);read(m); s=0;t=n+m+1; for(int i=1,x;i&lt;=n;i++){ read(x); ans+=x; exadd(s,i,x); for(;;){ char c; scanf(&quot;%d%c&quot;,&amp;x,&amp;c); exadd(i,n+x,oo); if(c==&#39;\\n&#39;||c==&#39;\\r&#39;) break; } } for(int i=1,x;i&lt;=m;i++){ read(x); exadd(n+i,t,x); } ans-=dinic(s,t); for(int i=1;i&lt;=n;i++) if(d[i]) write(i),putchar(&#39; &#39;); puts(&quot;&quot;); for(int i=1;i&lt;=m;i++) if(d[i+n]) write(i),putchar(&#39; &#39;); puts(&quot;&quot;); write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"网络流","slug":"网络流","permalink":"https://blog.yzcthinktwice.com/tags/网络流/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"FLOW1 飞行员配对方案问题","slug":"FLOW1 飞行员配对方案问题","date":"2019-12-03T12:29:01.000Z","updated":"2019-12-15T08:14:53.024Z","comments":true,"path":"2019/12/03/FLOW1 飞行员配对方案问题/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/12/03/FLOW1 飞行员配对方案问题/","excerpt":"","text":"FLOW1 飞行员配对方案问题 模型：二分图最大匹配-&gt;网络最大流 题意：每架飞机需要两个驾驶员，一个正驾驶员和一个副驾驶员。由于种种原因，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。两个正驾驶员或两个副驾驶员都不能同机飞行。 题解：二分图匹配裸题 代码：#include &lt;bits/stdc++.h&gt; #define fill(x,y) memset(x,y,sizeof x) #define copy(x,y) memcpy(x,y,sizeof x) using namespace std; inline int read(int &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } inline void write(int x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int oo=0x7fffffff; const int N=2000+5,M=N*N+5; int en=1,h[N],d[N],na,nb,m,s,t,use,cur[N]; struct edge{int n,v,w;}e[M&lt;&lt;1]; inline void add(int x,int y,int z){e[++en]=(edge){h[x],y,z};h[x]=en;} inline void exadd(int x,int y,int z){add(x,y,z);add(y,x,0);} bool bfs(int s,int aim){ fill(d,0); copy(cur,h); queue&lt;int&gt; q; q.push(s); d[s]=1; while(!q.empty()){ int x=q.front(); q.pop(); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(d[y]==0&amp;&amp;e[i].w){ d[y]=d[x]+1; if(y==aim) return 1; q.push(y); } } } return 0; } int dfs(int x,int flow,int aim){ if(x==aim) return flow; int rest=flow; for(int &amp;i=cur[x];i&amp;&amp;rest;i=e[i].n){ int y=e[i].v; if(d[y]==d[x]+1&amp;&amp;e[i].w){ int tp=dfs(y,min(rest,e[i].w),aim); rest-=tp; e[i].w-=tp; e[i^1].w+=tp; } } return flow-rest; } int dinic(int s,int t){ int res=0; while(bfs(s,t)) res+=dfs(s,oo,t); return res; } signed main(){ read(na);read(nb); nb-=na; for(int x,y;;){ read(x);read(y); if(x==-1) break; exadd(x+1,y+1,1); } for(int i=1;i&lt;=na;i++) exadd(1,i+1,1); for(int i=1;i&lt;=nb;i++) exadd(na+1+i,na+nb+2,1); int ans=dinic(1,na+nb+2); if(ans==0){puts(&quot;No Solution!&quot;);return 0;} write(ans);puts(&quot;&quot;); for(int i=2;i&lt;=en;i+=2){ int x=e[i].v,y=e[i^1].v; if(x!=1&amp;&amp;y!=1&amp;&amp;x!=na+nb+2&amp;&amp;y!=na+nb+2&amp;&amp;e[i^1].w) write(y-1),putchar(&#39; &#39;),write(x-1),putchar(&#39;\\n&#39;); } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"网络流二十四题","slug":"网络流二十四题","permalink":"https://blog.yzcthinktwice.com/tags/网络流二十四题/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"https://blog.yzcthinktwice.com/tags/二分图匹配/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1260C Infinite Fence","slug":"CF1260C Infinite Fence","date":"2019-11-29T11:16:01.000Z","updated":"2019-12-15T08:11:34.186Z","comments":true,"path":"2019/11/29/CF1260C Infinite Fence/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/29/CF1260C Infinite Fence/","excerpt":"","text":"CF1260C Infinite Fence 数学结论题，现场却卡得我基本掉色 难度在于对数学式的敏感度 题解：假设r&lt;=b（如果不是就交换） 首先思考r，b互质的情况，发现一定会存在第pos个木板涂蓝色，而第pos+1个木板涂成红色的情况 也就是说$rx-by=1$一定有正整数解存在，这一点可以用裴蜀定理简单的证明 （在P1082 同余方程的题解里，你也许可以得到更好的证明） 这意味着如果要OBEY，那么区间[pos,pos+b]中的红色木板数量一定要小于k，也就是 (k-1)*r+1 \\geq b（该式的意思是pos以后的k-1块红木板要能够卡满，甚至超过这个长度为b的区间） 此时又可以发现对于r，b不互质的情况，如果我们只看那些能被gcd(r,b)整除的木板，它们的情况又是与上述情况相同的 换句话说，只要先将r，b都除去gcd(r,b)使两者互质，再套用上述判定式即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long int t,r,b,k; void doit(){ read(r);read(b);read(k); int gcd=__gcd(r,b); r/=gcd; b/=gcd; if(r&gt;b) swap(r,b); if((k-1)*r+1&gt;=b) puts(&quot;OBEY&quot;); else puts(&quot;REBEL&quot;); } signed main(){ read(t); while(t--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"},{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1149B Three Religions","slug":"CF1149B Three Religions","date":"2019-11-29T11:08:01.000Z","updated":"2019-12-15T08:17:10.072Z","comments":true,"path":"2019/11/29/CF1149B Three Religions/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/29/CF1149B Three Religions/","excerpt":"","text":"CF1149B Three Religions 一道新颖的dp好题 题意：有三个字符串$s_1,s_2,s_3$和一个主串$s$，每次操作改变一个$s_i$ （插入或删除字符），每次操作完之后问$s$是否可以分成3个子序列正好是$s_1,s_2,s_3$ 。任意时候$|s_i|\\leq 250$。 题解：设f[i][j][k]表示A串匹配到第i个字符，B串匹配到第j个字符，C串匹配到第k个字符时，在模式串中的最短距离，即最左点（串的下标都从1开始） 预处理出nxt[i][c]，表示模式串中，[i,n]区间内，c字符第一次出现的位置 下面是一张cf官方的解释nxt数组的图，它的下标从0开始，也许可以方便理解 初始化$f[i][j][k]=n+1,f[0][0][0]=0$，意思是假设怎样都匹配失败，都不去匹配才能成功 转移方程如下： ${f[i][j][k]=\\min\\left \\{nxt[f[i-1][j][k]+1][s[1][i]],nxt[f[i][j-1][k]+1][s[2][j]],nxt[f[i][j][k-1]+1][s[3][k]] \\right \\}}$ 意思是，尝试从A串中加个字符找后续位置，从B串中加个字符找后续位置,从C串中加个字符找后续位置，从这三个位置中的最左边的一个那转移 对于插入操作，注意到新增加的状态只有 新字符与另外两个串的每个位置 这至多250*250种状态，对于这些新状态重新跑一遍dp即可 对于删除操作，直接减小相应串长即可 对于答案ans=f[len[1]][len[2]][len[3]]，意思就是三个串全部匹配完后，在模式串中的最左点 当ans&lt;=n时，说明是可以在模式串中被匹配完的，输出YES 否则ans=n+1就输出NO 特别注意处理nxt数组时，nxt[n+1][]和nxt[n+2][]都要赋为n+1 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5,M=255; char p[N]; int s[4][M],nxt[N][28],f[M][M][M],n,q,len[4]; /*预处理出nxt[][]数组*/ void init(){ for(int i=0;i&lt;26;i++) nxt[n+1][i]=nxt[n+2][i]=n+1; //注意这边的[n+2] for(int i=n;i;i--) for(int j=0;j&lt;26;j++){ if(p[i]==j+&#39;a&#39;) nxt[i][j]=i; else nxt[i][j]=nxt[i+1][j]; } } void doit(){ char ch;cin&gt;&gt;ch; int id;read(id); if(ch==&#39;+&#39;){ cin&gt;&gt;ch; s[id][++len[id]]=ch-&#39;a&#39;; for(int i=(id==1?len[1]:0);i&lt;=len[1];i++) //三目表达式部分意思是，如果是这个串被修改，那它只要计算新的一位，否则就都要从头开始 for(int j=(id==2?len[2]:0);j&lt;=len[2];j++) for(int k=(id==3?len[3]:0);k&lt;=len[3];k++){ int &amp;now=f[i][j][k]; now=n+1; //都先假设不可能 if(i) now=min(now,nxt[f[i-1][j][k]+1][s[1][i]]); //A串转移 if(j) now=min(now,nxt[f[i][j-1][k]+1][s[2][j]]); //B串转移 if(k) now=min(now,nxt[f[i][j][k-1]+1][s[3][k]]); //C串转移 } } else{ len[id]--; //直接删长度 } if(f[len[1]][len[2]][len[3]]&lt;=n) puts(&quot;YES&quot;); //最左点在n以内就可行 else puts(&quot;NO&quot;); } signed main(){ read(n);read(q); scanf(&quot;%s&quot;,p+1); init(); while(q--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1253E Antenna Coverage","slug":"CF1253E Antenna Coverage","date":"2019-11-29T11:06:01.000Z","updated":"2019-12-15T08:17:36.126Z","comments":true,"path":"2019/11/29/CF1253E Antenna Coverage/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/29/CF1253E Antenna Coverage/","excerpt":"","text":"CF1253E Antenna Coverage 一道难度2200的dp题 题意：街道上有$n$个天线。第$i$个天线的位置为$x_i$ ，以及一个范围值$s_i$ ；第$i$个天线的覆盖范围是$[x_i-s_i,x_i+s_i]$ 每次操作，你可以花费1代价，使得第$i$个天线的$s_i$增加一。每个天线都可以进行多次操作。现在请问你最少需要花费多少代价，使$[1,m]$编号内的每一个位置都被至少一个天线覆盖。 题解：f[i]表示覆盖1~i的最小代价 初始化f[i]=i，因为转移方向从左往右，在不考虑某点右方天线的情况下，最坏都可以看成是从f[0]转移的 转移枚举1~m每个点，再分别对每个点枚举所有天线，分类讨论： 若天线在它左边，由于从左向右转移的原则和局部最优解的性质，就可以不用判能否覆盖，直接从它的最大右覆盖处转移即可 $f[i]=min(f[i],f[max(0,x[j]-s[j]-1)])$ 若天线在它右边，则就要从它对于这个天线的左边的对称点转移，如果在天线半径之外，还要加上个代价 $f[i]=min(f[i],f[max(0,2*x[j]-i-1)]+max(0,i-x[j]-s[j]))$ 答案是f[m] 如果无法理解转移，可以看看下面这张图，是我从这里偷来的qwq 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int n,m,x[N],s[N],f[N]; signed main(){ read(n);read(m); for(int i=1;i&lt;=n;i++) read(x[i]),read(s[i]); for(int i=1;i&lt;=m;i++) f[i]=i; //初始化 for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++){ if(i&gt;=x[j]) f[i]=min(f[i],f[max(0,2*x[j]-i-1)]/*对称点处*/+max(0,i-x[j]-s[j])/*若超出还要补上额外代价*/); //在天线右边 else f[i]=min(f[i],f[max(0,x[j]-s[j]-1)]/*因为局部最优解，所以可以直接从边界转移*/); //在天线左边 } write(f[m]); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1257E The Contest","slug":"CF1257E The Contest","date":"2019-11-28T04:16:01.000Z","updated":"2019-12-15T08:11:19.535Z","comments":true,"path":"2019/11/28/CF1257E The Contest/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/28/CF1257E The Contest/","excerpt":"","text":"CF1257E The Contest 一道锻炼前缀、后缀、差分、化式子能力的好题 题意：给你三个集合A,B,C，集合大小分别为an，bn，cn，且an+bn+cn=n 满足三个集合的并集正好是整数1~n 每次操作可以将一个任意集合中的任意数字扔到另一个集合中 问至少需要几次操作使得每个集合内的数字都是连贯的（空集也可以，且A中所有元素小于B中所有元素，B中所有元素小于C中所有元素 题解：为了满足题目要求，不妨假设A中含0到i，B中含i+1到j，C中含j+1到n+1（0和n+1是不存在的） 显然的，此时答案ans就是每个集合中不属于自己的元素的个数和 设a[i]表示A集合中含有数1~i的个数，b[i]与c[i]同理 利用差分的思想可以得出此时要扔进这三个集合的元素个数分别为$(b[i]+c[i])$，$(a[j]-a[i]+c[j]-c[i])$，$(a[n]-a[j]+b[n]-b[j])$ 加起来就得到 ans=(b[i]+c[i])+(a[j]-a[i]+c[j]-c[i])+(a[n]-a[j]+b[n]-b[j])移项 ans=(a[j]-a[i]+a[n]-a[j])+(b[i]+b[n]-b[j])+(c[i]+c[j]-c[i])抵消 ans=-a[i]+an+b[i]+bn-b[j]+c[j]ans=(b[i]-a[i])+(an+bn)+(c[j]-b[j]) \\ \\ [i","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"前缀","slug":"前缀","permalink":"https://blog.yzcthinktwice.com/tags/前缀/"},{"name":"后缀","slug":"后缀","permalink":"https://blog.yzcthinktwice.com/tags/后缀/"},{"name":"差分","slug":"差分","permalink":"https://blog.yzcthinktwice.com/tags/差分/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3147 [USACO16OPEN]262144","slug":"P3147 [USACO16OPEN]262144","date":"2019-11-28T04:13:01.000Z","updated":"2019-12-15T08:17:39.828Z","comments":true,"path":"2019/11/28/P3147 [USACO16OPEN]262144/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/28/P3147 [USACO16OPEN]262144/","excerpt":"","text":"P3147 [USACO16OPEN]262144 DP好题，状态比较难想 f[i][j]表示将位置为i的数合成数字j所需要达到的最右点 初始f[i][a[i]]=i+1 因为合并距离都是2幂次，所以转移可以用类似倍增的思想 循环j套i f[i][j]=f[f[i][j-1]][j-1]若f[i][j]不为0则说明i位置上j是可行的 最后统计可行j的最大值即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=262150; int n,ans,f[N][60]; signed main(){ read(n); for(int i=1,x;i&lt;=n;i++) f[i][read(x)]=i+1; //初始都在自己右边 for(int j=2;j&lt;=58;j++) for(int i=1;i&lt;=n;i++){ if(f[i][j]==0) f[i][j]=f[f[i][j-1]][j-1]; //类似倍增跳过去 if(f[i][j]&gt;0) ans=j; //可行就更新答案 } write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"USACO","slug":"USACO","permalink":"https://blog.yzcthinktwice.com/tags/USACO/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"LOJ6276 果树","slug":"LOJ6276 果树","date":"2019-11-28T04:10:01.000Z","updated":"2019-12-15T08:11:43.661Z","comments":true,"path":"2019/11/28/LOJ6276 果树/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/28/LOJ6276 果树/","excerpt":"","text":"LOJ6276 果树 思维难度较大，代码难度巨大，细节超多 题意：给定一棵树，每个点有个颜色，询问特殊路径的数量 其中，定义特殊路径$(u,v)$为从u到v每个点颜色都不同的路径 $(u,v)=(v,u)$ 特别的，每种颜色至多出现20次 题解：每种颜色至多20次显然是问题的突破口 这样我们可以先假设所有点两两都是满足的，然后在同种颜色集合内两两枚举节点，对与两者相关联的点统一做关系消除，因为只要同时经过这两点的路径都一定是不合法的 这种“关联”显然是连贯的，而树上连贯的关系又想到什么？dfs序！ 在本题中，由于关联是双向的，我们将dfs序拓展成矩阵，消除关系就相当于在矩阵上放矩形（打阴影） 最后答案就是没被覆盖的部分 求矩阵面积并你又想到了啥？扫描线+线段树！ 套用模板即可 然鹅细节最多的部分在下面： 我们对枚举的同色两点进行如下分类讨论： 假设$deep_x&lt;=deep_y$且$col_x=col_y$ 已知如下一棵树： dfs矩阵是这样的的： SIT1： 无祖先关系 在上图中，x=2，y=3 发现此时会因为这两点导致关系不成立的是x的子树和y的子树（见图上的两个蓝框 这两部分由于都是子树，因此在dfs序上都是连续的（见下图的蓝色部分和绿色部分 可以在矩阵上打上两块完整的矩形（见下图的灰色部分 代码中只要计算dfs序上连续部分的头和尾就就可以得到矩形的四个顶点 SIT2： 有祖先关系 在上图中，x=1，y=6，且x是y的祖先 发现此时会因为这两点导致关系不成立的是y的子树和整棵树刨去点2的子树后的部分（见图上的两个蓝框 而这个点2是什么呢？它是x的所有儿子中距离y最近的一个，可以表示为点z 因此蓝框部分又可以叫做y的子树和整棵树刨去z的子树后的部分 z的位置怎么计算呢？ 发现z是y的祖先，且已知z到y的距离，因此可以用倍增lca的方法预处理出每个点2幂次倍的祖先，此时再对z-y距离二进制分解，对等于1的二进制位做爬升处理 y的子树部分与SIT1相同 那整棵树刨去z的子树后的部分在dfs序上怎么得到呢？ 由于是刨去，因此该部分可能是两段不连续的区间 在下图中，红线部分是z的子树，绿色是y的子树，两种蓝色是刨去后剩下的两段 代码中可以先将绿色与深蓝色部分打阴影 处理好后再将绿色与浅蓝色部分打阴影 添加阴影上下边和求面积并时注意点与长度的关系，即处理好是否需要+1变成左闭右开区间 最后面积算好后记得除以2,因为$(u,v)=(v,u)$ 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int f[N][20],en,h[N],sz[N],id[N],n,cnt,len[N&lt;&lt;2],tag[N&lt;&lt;2],ln,d[N]; vector&lt;int&gt; col[N]; long long ans; struct edge{ int n,v; }e[N&lt;&lt;1]; /*阴影的上下边界线*/ struct line{ int l,r,h,op; //op=1是上线，op=-1是下线 inline bool operator &lt; (const line &amp;nt) const { return h&lt;nt.h; } }a[N&lt;&lt;6]; /*线段树部分*/ void pushup(int x,int l,int r){ if(tag[x]){ len[x]=r-l+1; } else{ if(l^r) len[x]=len[x&lt;&lt;1]+len[x&lt;&lt;1|1]; else len[x]=0; } } void up(int x,int l,int r,int p,int q,int v){ if(p&lt;=l&amp;&amp;r&lt;=q){ tag[x]+=v; pushup(x,l,r); return ; } int mid=l+r&gt;&gt;1; if(p&lt;=mid) up(x&lt;&lt;1,l,mid,p,q,v); if(q&gt;mid) up(x&lt;&lt;1|1,mid+1,r,p,q,v); pushup(x,l,r); } void add(int x,int y){ e[++en]=(edge){h[x],y}; h[x]=en; } /*预处理部分*/ void dfs(int x){ sz[x]=1; d[x]=d[f[x][0]]+1; id[x]=++cnt; for(int i=1;i&lt;=16;i++) f[x][i]=f[f[x][i-1]][i-1]; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==f[x][0]) continue; f[y][0]=x; dfs(y); sz[x]+=sz[y]; } } /*倍增lca*/ int lca(int x,int y){ for(int i=16;~i;i--) if(d[f[y][i]]&gt;=d[x]) y=f[y][i]; if(x==y) return x; for(int i=16;~i;i--) if(f[x][i]^f[y][i]){ x=f[x][i]; y=f[y][i]; } return f[x][0]; } /*二进制跳跃找祖先*/ int getf(int x,int k){ for(int i=16;~i;i--) if(k&gt;&gt;i&amp;1) x=f[x][i]; return x; } /*添加阴影的上下边界线*/ void addline(int x,int y,int xx,int yy){ //(x,y)是矩形的左上角，(xx,yy)是矩形的右下角 a[++ln]=(line){x,xx,y,1}; //上线 a[++ln]=(line){x,xx,yy+1,-1}; //下线 a[++ln]=(line){y,yy,x,1}; //对称过来的上线 a[++ln]=(line){y,yy,xx+1,-1}; //对称过来的下线 } signed main(){ read(n); for(int i=1,x;i&lt;=n;i++) col[read(x)].push_back(i); for(int i=1,x,y;i&lt;n;i++){ read(x);read(y); add(x,y); add(y,x); } /*预处理出dfs序和fa[][]等信息*/ dfs(1); /*打阴影*/ for(int i=1;i&lt;=n;i++) //枚举颜色 for(int j=0;j&lt;col[i].size();j++) for(int k=j+1;k&lt;col[i].size();k++){ //两两枚举点 int x=col[i][j],y=col[i][k]; if(d[x]&gt;d[y]) swap(x,y); int LCA=lca(x,y); if(LCA==x){ //x是y祖先的情况 int z=getf(y,d[y]-d[x]-1); //求z的位置 int xx=id[z]-1; int yy=id[y]+sz[y]-1; x=1; y=id[y]; /*(x,y)是矩形的左上角，(xx,yy)是矩形的右下角，下同*/ if(x&lt;=xx) addline(x,y,xx,yy); //前半段 x=id[z]+sz[z],xx=n; if(x&lt;=xx) addline(x,y,xx,yy); //后半段 } else{ int xx=id[x]+sz[x]-1,yy=id[y]+sz[y]-1; x=id[x];y=id[y]; addline(x,y,xx,yy); //完整的一段 } } /*求面积并部分，模板*/ sort(a+1,a+1+ln); for(int i=1;i&lt;ln;i++){ up(1,1,n,a[i].l,a[i].r,a[i].op); ans+=1ll*len[1]*(a[i+1].h-a[i].h); } write(1ll*(1+n)*n-ans&gt;&gt;1ll); //一块等腰直角三角形面积减去一半的阴影面积 } 如果你写挂了，就请多检查检查你的打阴影部分","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://blog.yzcthinktwice.com/tags/线段树/"},{"name":"LOJ","slug":"LOJ","permalink":"https://blog.yzcthinktwice.com/tags/LOJ/"},{"name":"dfs序","slug":"dfs序","permalink":"https://blog.yzcthinktwice.com/tags/dfs序/"},{"name":"扫描线","slug":"扫描线","permalink":"https://blog.yzcthinktwice.com/tags/扫描线/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"YOJ1 二人从空中落下","slug":"YOJ1 二人从空中落下","date":"2019-11-25T12:04:01.000Z","updated":"2019-12-15T08:17:31.552Z","comments":true,"path":"2019/11/25/YOJ1 二人从空中落下/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/25/YOJ1 二人从空中落下/","excerpt":"","text":"YOJ1 二人从空中落下 暂时没时间放上YOJ，先寄存在luogu上 几乎全原创的一道题，感受到了出题的艰难。。。 欢迎各位帮忙验题！ 题意:现有n个无区别的点，他们可能随机连边成为一棵特殊的树 这种树满足它的每个非叶子节点都有且只有两个儿子 现给出a和b 问这些点所生成的所有特殊的树，能满足高度$\\in\\left [ a,b \\right ]$的概率是多少（约定单个节点高度为1） 对998244353取模 题解：灵感来源于P1472奶牛家谱 一道简短的dp，暴力给了30 SUB1：a与b正好卡满所有可能情况，100%能安全降落 输出1即可 SUB2：从1到(n+1)/2枚举降落点进行爆搜 给出暴力的大致代码： int dfs(int cnt, int height){ if (cnt == 1) return height == 1; if (height &gt; (cnt + 1) / 2) return 0; if (height &lt;= 1) return 0; int state=0; for (int i(1); i &lt; cnt; i += 2){ for (int j(1); j &lt; height; ++j){ state += dfs(i, height - 1) * dfs(cnt - i - 1, j); state %= MOD; if (height - 1 != j){ state += dfs(i, height - 1) * dfs(cnt - i - 1, j); state %= MOD; } } } return state; } signed main(){ scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;a,&amp;b); m=n+1&gt;&gt;1; if(a&gt;m){ puts(&quot;0&quot;); return 0; } if(a==ceil(log2(n+1))&amp;&amp;b==m){ puts(&quot;1&quot;); return 0; } b=min(b,m); for(int i=1;i&lt;=m;i++) s[i]=s[i-1]+dfs(n,i); cout&lt;&lt;(((s[b]-s[a-1])%mod+mod)%mod)*fpow(s[m],mod-2,mod)%mod; return 0; } SUB3：给想出标程但没处理b导致RE的人 SUB4：给想出标程但没有差分答案的人 标算：令m=(n+1)/2 画图易知m是n个点的最大合法深度 设f[i][j]表示i个点深度小于等于j的树有几种 初始f[1][]=1 转移$O(n^2*m)$ 三层循环分别枚举深度，枚举总点数，枚举左子树分配点数 $f[i][k]=sum{f[j][k-1]*f[i-j-1][k-1]}$ 若j为左子树点数则i-j-1为右子树点数 乘法原理，两者相乘 答案的分子部分显然可以由f[n][b]-f[n][a-1]差分得到 而分母部分就是f[n][m] 要注意的是，有些点a,b很大，需要特判： 若a&gt;m则输出0，因为一种都不满足 否则若b&gt;m则需要先将b取min改为m再继续做，以防止RE爆下标，因为&gt;m的部分都一定是不满足的 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=1005,mod=998244353; int n,m,f[N][605],a,b; int fpow(int x,int y,int mod){ int res=1; for(;y;y&gt;&gt;=1,mod?(x*=x)%=mod:x*=x) if(y&amp;1) mod?(res*=x)%=mod:res*=x; return res; } signed main(){ read(n);read(a);read(b); m=(n+1)&gt;&gt;1; if(a&gt;m){ //对a特判 puts(&quot;0&quot;); return 0; } b=min(b,m); //对b特判 for(int i=1;i&lt;=m;i++) f[1][i]=1; //初始 for(int k=1;k&lt;=m;k++) //枚举深度 for(int i=3;i&lt;=n;i+=2) //枚举总点数 for(int j=1;j&lt;i;j+=2) //枚举左子树分配点数 (f[i][k]+=f[j][k-1]*f[i-j-1][k-1]%mod)%=mod; //累加 write((((f[n][b]-f[n][a-1])%mod+mod)%mod)*fpow(f[n][m],mod-2,mod)%mod); //差分得答案 }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"YOJ","slug":"YOJ","permalink":"https://blog.yzcthinktwice.com/tags/YOJ/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"ABC146F Sugoroku","slug":"ABC146F Sugoroku","date":"2019-11-25T00:31:01.000Z","updated":"2019-12-15T08:17:18.538Z","comments":true,"path":"2019/11/25/ABC146F Sugoroku/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/25/ABC146F Sugoroku/","excerpt":"","text":"ABC146F Sugoroku 题意：给定一个01串，从0出发，恰好到达n胜利，每次能走1~m步，且数字为1的位置不能走 问字典序最小的行走方法（即不仅走的次数要少，且越靠前走的步数越要少） 题解：套路题，思路不算难想 step 1:先设计dp考虑走的次数尽可能少的条件 设f[i]表示到i位置的最少步数 初始f[]=oo,f[0]=0 转移$f_i=\\min \\left \\{ f_j|i-j&lt;=m \\right \\}+1 (a_i==0)$ 复杂度$O(nm)$ 考虑优化dp 发现min部分就是个滑动窗口，于是上单调队列 复杂度降为$O(n)$ step2:考虑题目的另一个要求：靠前的步数要尽可能少 因为总步数不变，靠前的要少，也就是说靠后的要多 也就是用g[]记录每次dp转移是从哪个位置转来的，如有相同则取前者转移 最后在dp后倒着从g[n]开始遍历，类似链表，每次g[n]与n的差就是这次走的步数 反着输出即可 代码实现也很简单，因为单调队列的先进后出的性质可以保证队首的下标是最小的，直接塞到g[]中即可 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int n,m,a[N],f[N],g[N]; deque&lt;int&gt; q; vector&lt;int&gt; ans; signed main(){ read(n);read(m); for(int i=0;i&lt;=n;i++) scanf(&quot;%1d&quot;,&amp;a[i]),f[i]=0x3f3f3f3f; f[0]=0; f[n+1]=0x3f3f3f3f; q.push_back(0); //先塞个0进去 for(int i=1;i&lt;=n;i++) if(!a[i]){ //转移先决条件 g[i]=n+1; while(!q.empty()&amp;&amp;q.front()+m&lt;i) q.pop_front(); //维护单调队列 if(!q.empty()) g[i]=q.front(); //维护g[] f[i]=f[g[i]]+1; //转移f[] while(!q.empty()&amp;&amp;f[q.back()]&gt;f[i]) q.pop_back(); //维护单调队列 q.push_back(i); } if(f[n]&gt;n){ write(-1); //走不到n则无解 return 0; } for(;n;n=g[n]) ans.push_back(n-g[n]); //倒着类链表便利g[] for(int i=ans.size()-1;i&gt;=0;i--) write(ans[i]),putchar(&#39; &#39;); //再倒着输出步数 }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.yzcthinktwice.com/tags/AtCoder/"},{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"单调队列","slug":"单调队列","permalink":"https://blog.yzcthinktwice.com/tags/单调队列/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"ABC146E Rem of Sum is Num","slug":"ABC146E Rem of Sum is Num","date":"2019-11-24T14:31:01.000Z","updated":"2019-12-15T08:11:30.457Z","comments":true,"path":"2019/11/24/ABC146E Rem of Sum is Num/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/24/ABC146E Rem of Sum is Num/","excerpt":"","text":"ABC146E Rem of Sum is Num 一道巧妙的思维题，考验了对数学式的转化 题意:给出一个数列和常数k，求合法子序列的个数 其中合法子序列需要满足： \\sum_{i}^{j}{a_i} \\equiv j-i+1\\ \\left (\\mod k \\right ) 题解：比赛时毫无思路，赛后看了题解茅塞顿开 让我们来转化这个需要满足的式子，其中规定$s_i$表示1-i的前缀和： \\sum_{i}^{j}{a_i} \\equiv j-i+1 \\ (\\mod k )s_j - s_{i-1} \\equiv j-(i-1) \\ (\\mod k )s_j - s_i \\equiv j-i \\ (\\mod k )s_i-i = s_j-j \\ (j-i","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.yzcthinktwice.com/tags/AtCoder/"},{"name":"数学","slug":"数学","permalink":"https://blog.yzcthinktwice.com/tags/数学/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1223C Save the Nature","slug":"CF1223C Save the Nature","date":"2019-11-22T01:16:01.000Z","updated":"2019-12-15T08:11:06.573Z","comments":true,"path":"2019/11/22/CF1223C Save the Nature/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/22/CF1223C Save the Nature/","excerpt":"","text":"CF1223C Save the Nature 本文给出$O(nlog^2n)$和$O(nlogn)$的算法 首先二分答案的思路由询问内容的单调性可得，十分好想，一只log 重点在于check部分，有两种思路 1. 暴力sort两只log (156ms)思维难度低，代码难度低 关键是出题人没来卡 先O(n)扫一遍，得到每天的贡献（百分比） O(nlogn)从大到小排序，与每天的值配对 bool check(int n){ int sum=0; for(int i=1;i&lt;=n;i++){ b[i]=0; if(i%al==0) b[i]+=x; //有第一种贡献 if(i%be==0) b[i]+=y; //有第二种贡献 } sort(b+1,b+1+n,greater&lt;int&gt;()); //greater&lt;int&gt;()是自带的一个比较函数，用来从大到小排 for(int i=1;i&lt;=n;i++) sum+=a[i]*b[i]; //a[]在main()中均已除以100，直接暴力配对 return sum&gt;=k; } 2. lcm容斥一只log (62ms)跑的飞快，毕竟正解 我们发现如果有贡献，只有三种情况，即a的倍数,b的倍数,lcm(a,b)的倍数 方便起见，先做这么一件事： if(x&lt;y) swap(x,y),swap(al,be); 这样就保证lcm优于a,a优于b了 用除法算出a,b,lcm各有几个记为xn,yn,xyn 由容斥原理可得xn,yn都要减去xyn 使得可以保证a,b,lcm贡献互不相交 然后分三段按照lcm(x+y),a(x),b(y)的顺序扫一遍即可 bool check(int n){ int sum=0,xn=n/al,yn=n/be,xyn=n/lcm; //除法计算 xn-=xyn; //容斥 yn-=xyn; for(int i=1;i&lt;=xyn;i++) sum+=(x+y)*a[i]; //lcm段 for(int i=xyn+1;i&lt;=xyn+xn;i++) sum+=x*a[i]; //a段 for(int i=xyn+xn+1;i&lt;=xyn+xn+yn;i++) sum+=y*a[i]; //b段 return sum&gt;=k; } 代码两只log#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=2e5+5; int q,n,a[N],b[N],k,x,y,be,al; bool check(int n){ int sum=0; for(int i=1;i&lt;=n;i++){ b[i]=0; if(i%al==0) b[i]+=x; if(i%be==0) b[i]+=y; } sort(b+1,b+1+n,greater&lt;int&gt;()); for(int i=1;i&lt;=n;i++) sum+=a[i]*b[i]; return sum&gt;=k; } void doit(){ read(n); for(int i=1;i&lt;=n;i++) read(a[i]),a[i]/=100; sort(a+1,a+1+n,greater&lt;int&gt;()); read(x);read(al); read(y);read(be); read(k); int l=1,r=n,ans=-1; while(l&lt;=r){ int mid=l+r&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } write(ans);puts(&quot;&quot;); } signed main(){ read(q); while(q--) doit(); } 一只log#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } #define int long long const int N=2e5+5; int q,n,a[N],b[N],k,x,y,be,al,lcm; bool check(int n){ int sum=0,xn=n/al,yn=n/be,xyn=n/lcm; xn-=xyn; yn-=xyn; for(int i=1;i&lt;=xyn;i++) sum+=(x+y)*a[i]; for(int i=xyn+1;i&lt;=xyn+xn;i++) sum+=x*a[i]; for(int i=xyn+xn+1;i&lt;=xyn+xn+yn;i++) sum+=y*a[i]; return sum&gt;=k; } void doit(){ read(n); for(int i=1;i&lt;=n;i++) read(a[i]),a[i]/=100; sort(a+1,a+1+n,greater&lt;int&gt;()); read(x);read(al); read(y);read(be); if(x&lt;y) swap(x,y),swap(al,be); lcm=al*be/__gcd(al,be); read(k); int l=1,r=n,ans=-1; while(l&lt;=r){ int mid=l+r&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } write(ans);puts(&quot;&quot;); } signed main(){ read(q); while(q--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"二分答案","slug":"二分答案","permalink":"https://blog.yzcthinktwice.com/tags/二分答案/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF949C Data Center Maintenance","slug":"CF949C Data Center Maintenance","date":"2019-11-21T06:36:01.000Z","updated":"2019-12-15T08:11:13.825Z","comments":true,"path":"2019/11/21/CF949C Data Center Maintenance/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/21/CF949C Data Center Maintenance/","excerpt":"","text":"CF949C Data Center Maintenance 这题如果没有搞清楚题意，其实结论是并不“显然”的 题目其实是让你主动推迟有且仅有一个点，并将所有会因此受影响的点也都连锁着推迟下去，问最少会有几个点推迟 注意这个”主动推迟“，这意味着即使已经满足条件了你还是得要推迟一个点 搞懂了题意，接下来的思路就好理解了 我们发现“推迟”是一种单向关系，即，如果我使你不得不推迟，而你却不会使我不得不推迟 将这种单向关系转成图论的单向边 边的是否添加，即询问两者的是否满足 u_x +1 \\equiv x_y \\ \\ ( mod {h} )发现一个点只要有出度那它肯定不是最优的 如A-&gt;B，选A必带B，选B可无A 所以首先可以确定答案节点没有出度的 其次，由于强联通分量里的点都是可以互相到达的，所以只要其一推迟，另外的都得推迟 于是缩点，经保留size 问题变成在DAG上找一个没有出度的最小的点 $O(n)$扫一遍即可 #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int h[N],en,H,n,m,scc[N],dfn[N],low[N],st[N],lim,cnt,du[N],sn,ans,sz[N],a[N]; bool v[N]; struct edge{ int n,u,v; }e[N]; void add(int x,int y){ e[++en]=(edge){h[x],x,y}; h[x]=en; } void tarjan(int x){ //找强联通分量 low[x]=dfn[x]=++cnt; v[x]=1; st[++lim]=x; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); } else{ if(v[y]) low[x]=min(low[x],dfn[y]); } } if(low[x]==dfn[x]){ int top; sn++; for(;;){ top=st[lim--]; scc[top]=sn; v[top]=0; sz[sn]++; if(top==x) return ; } } } signed main(){ read(n);read(m);read(H); for(int i=1;i&lt;=n;i++) read(a[i]); for(int i=1,x,y;i&lt;=m;i++){ read(x);read(y); if((a[x]+1)%H==a[y]) add(x,y); //边的添加（关系的判断） if((a[y]+1)%H==a[x]) add(y,x); } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=en;i++){ int x=scc[e[i].u],y=scc[e[i].v]; //根据原先加的边判定出度 if(x^y) du[x]++; } sz[0]=0x3f3f3f3f; for(int i=1;i&lt;=sn;i++) if(!du[i]){ if(sz[i]&lt;sz[ans]) ans=i; //取无出度节点的最小size } write(sz[ans]);puts(&quot;&quot;); for(int i=1;i&lt;=n;i++) if(scc[i]==ans) //是这个强联通分量的就输出 write(i),putchar(&#39; &#39;); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"tarjan","slug":"tarjan","permalink":"https://blog.yzcthinktwice.com/tags/tarjan/"},{"name":"强联通分量","slug":"强联通分量","permalink":"https://blog.yzcthinktwice.com/tags/强联通分量/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P1156 垃圾陷阱","slug":"P1156 垃圾陷阱","date":"2019-11-19T01:22:45.000Z","updated":"2019-12-15T08:17:14.851Z","comments":true,"path":"2019/11/19/P1156 垃圾陷阱/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/19/P1156 垃圾陷阱/","excerpt":"","text":"P1156 垃圾陷阱 先将垃圾按时间排序 分类讨论 先假设能逃出去 设f[i][j]表示前i个垃圾叠成高度j时的最长生存时间 初始f[0][0]=10 类背包转移 注意濒死也是能转移的，即f[][]&lt;0才无法转移 转移时超过高度就输出当前时间 再模拟逃不出去 计算最长存活时间 #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=105,M=105; int n,m,f[N][M]; struct trash{ int t,f,h; inline bool operator &lt; (const trash &amp;nt) const { return t&lt;nt.t; } }a[N]; signed main(){ read(m);read(n); for(int i=1;i&lt;=n;i++){ read(a[i].t); read(a[i].f); read(a[i].h); } sort(a+1,a+1+n); memset(f,-1,sizeof f); f[0][0]=10; for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=m;j++) if(f[i-1][j]&gt;=0){ if(j+a[i].h&gt;=m&amp;&amp;f[i-1][j]+a[i-1].t&gt;=a[i].t){ write(a[i].t); return 0; } if(f[i-1][j]+a[i-1].t&gt;=a[i].t){ f[i][j+a[i].h]=f[i-1][j]+a[i-1].t-a[i].t; f[i][j]=max(f[i][j],f[i-1][j]+a[i-1].t-a[i].t+a[i].f); } } } m=10; for(int i=1;i&lt;=n;i++){ if(m+a[i-1].t&lt;a[i].t){ write(m+a[i-1].t); return 0; } m-=a[i].t-a[i-1].t; m+=a[i].f; } write(m+a[n].t); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P1220 关路灯","slug":"P1220 关路灯","date":"2019-11-19T00:34:04.000Z","updated":"2019-12-15T08:16:55.564Z","comments":true,"path":"2019/11/19/P1220 关路灯/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/19/P1220 关路灯/","excerpt":"","text":"P1220 关路灯 已被关的区间是封闭连续的，加之还要知道人是在左端点还是在右端点， 所以设f[i][j][0/1]表示现在[i,j]被关闭的最小花费，且0人在左端点，1人在右端点 初始f[st][st][0/1]=0，其他=oo 转移的费用通过两点路程差*左右两段未被关的区间的功率之和 功率和可通过前缀和计算 ans=min(f[1][n][0],f[1][n][1]) #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=55; int n,st,p[N],s[N],f[N][N][2]; inline int que(int l,int r){ return s[r]-s[l-1]; } signed main(){ read(n);read(st); for(int i=1;i&lt;=n;i++){ read(p[i]); read(s[i]); s[i]+=s[i-1]; } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i!=st||j!=st) f[i][j][0]=f[i][j][1]=0x3f3f3f3f; for(int j=st;j&lt;=n;j++) for(int i=j-1;i&gt;=1;i--){ f[i][j][0]=min(f[i+1][j][0]+(p[i+1]-p[i])*(que(1,i)+que(j+1,n)),f[i+1][j][1]+(p[j]-p[i])*(que(1,i)+que(j+1,n))); f[i][j][1]=min(f[i][j-1][0]+(p[j]-p[i])*(que(1,i-1)+que(j,n)),f[i][j-1][1]+(p[j]-p[j-1])*(que(1,i-1)+que(j,n))); } write(min(f[1][n][0],f[1][n][1])); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P1373 小a和uim之大逃离","slug":"P1373 小a和uim之大逃离","date":"2019-11-18T23:53:01.000Z","updated":"2019-12-15T08:17:02.727Z","comments":true,"path":"2019/11/19/P1373 小a和uim之大逃离/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/19/P1373 小a和uim之大逃离/","excerpt":"","text":"P1373 小a和uim之大逃离 f[i][j][p][0/1]表示到(i,j)时两人差为p且最后一步是0/1走的的方案数, 初始f[i][j][a[i][j]][0]=1 ans=sum{f[i][j][0][1]} #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ x=0;char c=getchar();bool f=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0){putchar(&#39;-&#39;),write(-x);} else{if(x&gt;9)write(x/10);putchar(&#39;0&#39;+x%10);} } const int mod=1e9+7; const int N=805; int n,m,k,f[N][N][18][2],a[N][N]; long long ans; signed main(){ read(n);read(m);read(k);k++; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ read(a[i][j]); f[i][j][a[i][j]][0]=1; } } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int p=0;p&lt;k;p++){ if(i&gt;1){ (f[i][j][p][0]+=f[i-1][j][(p-a[i][j]+k)%k][1])%=mod; (f[i][j][p][1]+=f[i-1][j][(p+a[i][j])%k][0])%=mod; } if(j&gt;1){ (f[i][j][p][0]+=f[i][j-1][(p-a[i][j]+k)%k][1])%=mod; (f[i][j][p][1]+=f[i][j-1][(p+a[i][j])%k][0])%=mod; } } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) (ans+=f[i][j][0][1])%=mod; write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3398 仓鼠找sugar","slug":"P3398 仓鼠找sugar","date":"2019-11-12T13:33:01.000Z","updated":"2019-12-15T08:10:04.903Z","comments":true,"path":"2019/11/12/P3398 仓鼠找sugar/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/12/P3398 仓鼠找sugar/","excerpt":"","text":"P3398 仓鼠找sugar 模板题，询问树上两链是否有交 算法：给出性质：若两树链有交，则必有其中一条链的端点的lca在另一条链上，记为P 由这个性质题目一下变水了。。。 那如何判断一个点是否在一条链上呢？ 设a-b链lca为c，x-y链lca为z，且$d_c&gt;d_z$ WAY1. dis(x,a)+dis(x,b)=dis(a,b)显然的，不等就成三角形了 read(x),read(y),read(u),read(v); int z=lca(x,y),w=lca(u,v); if(d[z]&gt;d[w]){ swap(x,u); swap(y,v); swap(z,w); } if(dis(w,x)+dis(w,y)==dis(x,y)) puts(&quot;Y&quot;); else puts(&quot;N&quot;); WAY2. x是x-a的lca或x是x-b的lca反证易得 read(x),read(y),read(u),read(v); int z=lca(x,y),w=lca(u,v); if(d[z]&gt;d[w]){ swap(x,u); swap(y,v); swap(z,w); } if(lca(w,x)==w||lca(w,y)==w) puts(&quot;Y&quot;); else puts(&quot;N&quot;); 证明：当然手画树猜结论是大多数人的选择 我们容易发现，如果相交，记 $x=lca(a,b)$,$y=lca(c,d)$，则必有x在c-d路径上或y在a-b路径上 首先易知两点的lca在其路径上。如果路径相交，那么x要么在相交的路径上，要么不在。我们不妨记相交的那段为e-f 如果不在，由对称性，不妨设x靠近a，那么有a到x深度递减，b到e、e到f、f到x深度递减；同样，肯定有c到f、d到e深度递减，由此可知，y必定为f，由此得证 代码：#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5,M=N&lt;&lt;1; int n,m,en,h[N],s[N],sz[N],f[N],top[N],d[N]; struct edge{int n,v;}e[M]; inline void add(const int &amp;x,const int &amp;y){ e[++en]=(edge){h[x],y}; h[x]=en; } void dfs1(int x){ sz[x]=1; d[x]=d[f[x]]+1; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==f[x]) continue; f[y]=x; dfs1(y); sz[x]+=sz[y]; if(sz[s[x]]&lt;sz[y]) s[x]=y; } } void dfs2(int x,int TOP){ top[x]=TOP; if(s[x]) dfs2(s[x],TOP); for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(y==f[x]||y==s[x]) continue; dfs2(y,y); } } inline int lca(int x,int y){ while(top[x]^top[y]) if(d[top[x]]&gt;d[top[y]]) x=f[top[x]]; else y=f[top[y]]; return d[x]&lt;d[y]?x:y; } void doit(){ int x,y,u,v; read(x),read(y),read(u),read(v); int z=lca(x,y),w=lca(u,v); if(d[z]&gt;d[w]){ swap(x,u); swap(y,v); swap(z,w); } if(lca(w,x)==w||lca(w,y)==w) puts(&quot;Y&quot;); else puts(&quot;N&quot;); } signed main(){ read(n);read(m); for(int i=1,x,y;i&lt;n;i++){ read(x);read(y); add(x,y); add(y,x); } dfs1(1); dfs2(1,1); while(m--) doit(); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"LCA","slug":"LCA","permalink":"https://blog.yzcthinktwice.com/tags/LCA/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"nim游戏及变体","slug":"nim游戏及变体","date":"2019-11-11T13:58:01.000Z","updated":"2019-12-15T08:09:59.259Z","comments":true,"path":"2019/11/11/nim游戏及变体/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/11/nim游戏及变体/","excerpt":"","text":"PART1. 经典nim出处 问题：有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利 算法：若每堆石子数的异或和不为0，则先手必胜 证明：由于nim游戏的sg值与石子数相等，所以由SG定理可以方便的得到 例题：P2197 【模板】nim游戏 PART2. 分裂nim出处 新规则：每次取完石子后，可以将取的那一堆的石子 分为多堆，也可以不分 算法：与经典无异 证明：如果异或和不为0，那先手不用分某一堆石子，同Nim游戏 如果异或和为0， 不执行分裂操作则先手必败，同Nim游戏 若执行分裂操作，如果能够证明执行分裂操作的后继局面异或和依然不为0，那么结论成立 采用反证法，证明如果分裂后异或和为0 会产生矛盾 a1 xor a2 xor a3 xor ……xor an=0 a1=a2 xor a3 xor ……xor an 假设我们取的那一堆是第1堆，取完之后还有b1个，b1&lt;a1 将b1分为x+y 若x xor y xor a2 xor a3 xor ……xor an=0 则 x xor y=a2 xor a3 xor …… xor an 所以x xor y = a1 又因为异或是不进位的加法，所以x xor y&lt;=b1&lt;a1产生矛盾 PART3. 阶梯nim出处 新规则：取的石子不是拿出而是从第i堆放入第i-1堆 算法：将每个奇数位置的数x看成一堆有x个石子的石子堆，然后玩Nim游戏。 证明： 拿走某一堆石子的一部分，相当于将某个奇位置的石子移动到它左边的偶位置上。 如果大家都只动奇位置的石子，那么这等价于两人在玩Nim游戏。 但如果有人想打破规则呢？ 假设Nim游戏先手必胜，那么先手肯定优先玩Nim游戏；如果后手试图破坏局面，将某个偶位置上的若干石子移动到了左边的奇位置i上，那么先手可以将这若干个刚移到i的石子继续移动到i左边的偶位置上，对Nim局面依然没有任何影响，除非后手回头来继续动奇位置的石子，那也只能是输。 那么如果Nim游戏先手必败，也是同理，后手可以用相同的方式迫使先手玩Nim游戏，直到输为止。 因此，奇数位置的石子的相关信息，就直接决定了阶梯Nim问题的结果。 例题：POJ1704 Georgia and Bob PART4. 树上阶梯nim新规则：在阶梯nim的基础上赋予各节点树的顺序 算法：对深度为奇数的所有点玩Nim游戏。 证明： 根据SG定理，在阶梯nim的基础上做异或合并即可 例题： 这个文档的T3","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://blog.yzcthinktwice.com/tags/博弈论/"},{"name":"教程","slug":"教程","permalink":"https://blog.yzcthinktwice.com/tags/教程/"},{"name":"nim游戏","slug":"nim游戏","permalink":"https://blog.yzcthinktwice.com/tags/nim游戏/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"LIS，LCS与树状数组","slug":"LIS，LCS与树状数组","date":"2019-11-03T12:50:01.000Z","updated":"2019-12-15T08:09:35.446Z","comments":true,"path":"2019/11/03/LIS，LCS与树状数组/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/03/LIS，LCS与树状数组/","excerpt":"","text":"模拟赛中出到了类似题，特意在网上搜索学习，并有所感想 本文由此获得启发，特此感谢 PART1. LIS从P1439 【模板】最长公共子序列开始 50pt的$O(n^2)$算法很容易想，即设f[i]表示到i结束的最长LIS的长度 f[i]=\\max \\left \\{ f[j] | a_j","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://blog.yzcthinktwice.com/tags/教程/"},{"name":"LIS","slug":"LIS","permalink":"https://blog.yzcthinktwice.com/tags/LIS/"},{"name":"LCS","slug":"LCS","permalink":"https://blog.yzcthinktwice.com/tags/LCS/"},{"name":"树状数组","slug":"树状数组","permalink":"https://blog.yzcthinktwice.com/tags/树状数组/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3657 [USACO17FEB]Why Did the Cow Cross the Road II P","slug":"P3657 [USACO17FEB]Why Did the Cow Cross the Road II P","date":"2019-11-03T12:28:01.000Z","updated":"2019-12-15T08:17:05.786Z","comments":true,"path":"2019/11/03/P3657 [USACO17FEB]Why Did the Cow Cross the Road II P/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/03/P3657 [USACO17FEB]Why Did the Cow Cross the Road II P/","excerpt":"","text":"P3657 Why Did the Cow Cross the Road II P LCS是本题比较直观的一种思路，即将普通LCS（最长公共子序列）的相等的条件改为差的绝对值&lt;=4 众所周知，求LCS有两种$O(nlogn)$方法 一种是映射，另一种是DP优化 因为差的绝对值&lt;=4的条件会使映射变得复杂，我们这里采用DP优化的方法 该方法具体可以见[noip科普]关于LIS和一类可以用树状数组优化的DP 要注意的是，该方法中要记录b[]中各值可合法对应的值在a[]的位置，这个位置是需要通过排序来保证有序的 #include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e5+5; int a[N],b[N],n,f[N],ans,pos[N]; vector&lt;int&gt; p[N]; struct BIT{ //树状数组模板 #define lowbit(x) (x&amp;(-x)) int a[N]; void up(int x,int v){ while(x&lt;=n){ a[x]=max(a[x],v); x+=lowbit(x); } } int que(int x){ int res=0; while(x){ res=max(res,a[x]); x-=lowbit(x); } return res; } }ma; signed main(){ read(n); for(int i=1,x;i&lt;=n;i++){ read(x); pos[x]=i; //记录某值的位置 } for(int i=1;i&lt;=n;i++){ read(b[i]); for(int j=max(1,b[i]-4);j&lt;=min(n,b[i]+4);j++) p[i].push_back(pos[j]); //记录b[]值合法对应值的位置 sort(p[i].begin(),p[i].end()); //排序使之保证有序 } for(int i=1;i&lt;=n;i++) for(int j=p[i].size()-1;j&gt;=0;j--){ //按位置搞LCS int pos=p[i][j]; f[pos]=ma.que(pos-1)+1; ma.up(pos,f[pos]); } for(int i=1;i&lt;=n;i++) ans=max(ans,f[i]); //得到答案 write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://blog.yzcthinktwice.com/tags/动态规划/"},{"name":"LCS","slug":"LCS","permalink":"https://blog.yzcthinktwice.com/tags/LCS/"},{"name":"树状数组","slug":"树状数组","permalink":"https://blog.yzcthinktwice.com/tags/树状数组/"},{"name":"USACO","slug":"USACO","permalink":"https://blog.yzcthinktwice.com/tags/USACO/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF上蓝！","slug":"CF上蓝！","date":"2019-11-01T23:30:00.000Z","updated":"2019-12-15T08:10:21.987Z","comments":true,"path":"2019/11/02/CF上蓝！/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/11/02/CF上蓝！/","excerpt":"","text":"令人激动！ 自己动手，丰衣足食 CF round #597我终于上蓝了！ 每题都很有思路，除了最后的两个dp题 没有任何罚时，D甚至是洛谷原题（打井），并且没来卡kruskal。。。 挺幸运的，见这里 全球rating 272，涨了161分","categories":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}]},{"title":"CF1239D Catowice City","slug":"CF1239D Catowice City","date":"2019-10-29T14:11:01.000Z","updated":"2019-12-15T08:10:10.061Z","comments":true,"path":"2019/10/29/CF1239D Catowice City/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/10/29/CF1239D Catowice City/","excerpt":"","text":"CF1239D Catowice City 说在前面的：其实本题在答案的统计上并没有另两篇题解讲的那么麻烦 如果你真正搞懂了tarjan，你会明白如果一个强连通分量有出边，由于它dfs的性质，一定会继续向下遍历，直到找到一个没有出度的强连通分量 因此，第一个被找到的强联通分量一定是没有出度的！ 这样其余两篇题解的做法在过程上还可以被大幅简化 题解首先，一个很简单的问题：为什么n个不可以都是猫呢？ 因为必须至少有一个人 那么我们就必须把这个人放到无法产生任何影响的地方去 即一个人群（或仅一个人） 这个人群必须满足不会再对后续产生影响（因为连猫不合法，连人不如换个部分做人群） 即无出度 同时人群中也要保持强联通，因为如果有人不强联通，他就可以被分离出看成猫 因此问题转化为在一个有向图中找一个没有出度的强连通分量 在这个没有出度的强联通分量里的都是人，否则是猫 而我之前又说过第一个被找到的强联通分量一定是没有出度的，因此编号为1的强连通分量就是我们要找的 另外，显然的，如果只有一个强连通分量就是不合法的 代码#include &lt;bits/stdc++.h&gt; using namespace std; template&lt;class t&gt; inline t read(t &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } template&lt;class t&gt; inline void write(t x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=1e6+5; int h[N],st[N],lim,dfn[N],low[N],cnt,en,scc[N],sn,n,m,t,sz[N]; bool v[N]; struct edge{int n,v;}e[N]; inline void add(int x,int y){e[++en]=(edge){h[x],y};h[x]=en;} void tarjan(int x){ //tarjan模板 v[x]=1; st[++lim]=x; dfn[x]=low[x]=++cnt; for(int i=h[x];i;i=e[i].n){ int y=e[i].v; if(!dfn[y]){ tarjan(y); low[x]=min(low[x],low[y]); } else{ if(v[y]) low[x]=min(low[x],dfn[y]); } } if(dfn[x]==low[x]){ int top; sn++; for(;;){ top=st[lim--]; v[top]=0; scc[top]=sn; sz[sn]++; //sz[]是强连通分量的大小 if(top==x) break; } } } void doit(){ read(n);read(m); sn=cnt=en=lim=0; for(int i=1;i&lt;=n;i++) h[i]=sz[i]=dfn[i]=0; for(int i=1,x,y;i&lt;=m;i++){ read(x);read(y); if(x==y) continue; //自己和自己的猫可忽略 add(x,y); } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); if(sn==1){ //只有一个强连通分量，不合法 puts(&quot;No&quot;); return ; } printf(&quot;Yes\\n%d %d\\n&quot;,sz[1],n-sz[1]); //sz[1]是人的个数，减一减得到猫数 for(int i=1;i&lt;=n;i++) if(scc[i]==1) write(i),putchar(&#39; &#39;);puts(&quot;&quot;); //第一个的都是人 for(int i=1;i&lt;=n;i++) if(scc[i]!=1) write(i),putchar(&#39; &#39;);puts(&quot;&quot;); //否则是猫 } signed main(){ read(t); while(t--) doit(); } (ps.本题清零初始化用memset会T在第三个点，要改用for)","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"缩点","slug":"缩点","permalink":"https://blog.yzcthinktwice.com/tags/缩点/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://blog.yzcthinktwice.com/tags/强连通分量/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P3294 [SCOI2016]背单词","slug":"P3294 [SCOI2016]背单词","date":"2019-10-28T14:28:01.000Z","updated":"2019-12-15T08:09:53.146Z","comments":true,"path":"2019/10/28/P3294 [SCOI2016]背单词/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/10/28/P3294 [SCOI2016]背单词/","excerpt":"","text":"P3294 【SCOI2016】背单词 题意（已用贪心思路简化）给定n个单词$s_i$，请重排序列，使每个单词的存在的后缀都在前面 设$s_j$为离$s_i$最近的后缀字符串 定义$a_i=i-j$ $ans=min(\\sum a_i)$ 题解后缀显然没有前缀来的容易处理，所以自然想到翻转每个单词，建出trie树 下面是个例子： 6 a ca ea gda hda ifb 1. 建出trie树(红点是颠倒后每个单词的末尾，注意根也是）： void ins(char *s){ int x=0; for(int i=0;s[i];i++){ if(!a[x].nt[s[i]-&#39;a&#39;]) a[x].nt[s[i]-&#39;a&#39;]=++cnt; x=a[x].nt[s[i]-&#39;a&#39;]; } a[x].tag=1; //tag==1说明是红点 } 2. 重构树跳过白点，保留红点（白点无用，可以忽略） void doit(int x){ if(a[x].tag&amp;&amp;x){ g[last[x]].push_back(x); //g[x][]存重构树中点x的儿子们 last[x]=x; //last[x]是原树里x节点上方离它最近的红点（包括自己） } for(int i=0;i&lt;26;i++) if(a[x].nt[i]){ last[a[x].nt[i]]=last[x]; doit(a[x].nt[i]); } } 3. dfs遍历重构树，并将直接祖先相同的子树按节点数从小到大排序 inline bool cmp(const int &amp;x,const int &amp;y){ return sz[x]&lt;sz[y]; } void dfs(int x){ sz[x]=1; //sz[x]是以x为根的子树的大小 for(int i=0;i&lt;g[x].size();i++){ dfs(g[x][i]); sz[x]+=sz[g[x][i]]; } sort(g[x].begin(),g[x].end(),cmp); } 4. 根据题意遍历重构树，用dfs序得到答案void getans(int x){ int dfn=cnt++; //dfn是父亲的dfs序，cnt是节点自己的dfs序 for(int i=0;i&lt;g[x].size();i++){ ans+=cnt-dfn; //两者相减就是题意里的ai getans(g[x][i]); } } 思路背后的理由Q1. 为什么题意可以这样简化？三条规则，规则一显然是可以被避免且没有后两种优的，规则二可以看做规则三的特殊情况，简单起见，只考虑规则三即可 Q2. 排序的正确性？花费与最后一个填入的后缀有关,那么这个后缀的位置离当前位置越近越好,也就是应该有尽量少的单词夹在两个中间,所以我们应该选下属单词最少的那个进行拓展，而下属单词的多少就等价于重构树中子树的大小。 Q3. dfs序的正确性？这里引用 @坐山客 的题解： 考虑重新建树之后，i节点的子树中的所有节点的后缀都是i 如果同一深度上有不止一棵子树，那么我们先在一棵上取出一个叶子节点j，再取出一个根节点i，我们发现如果j&gt;i的话肯定不如i&lt;j优秀 因为调整之后i的子树上所有节点对花费的贡献-=子树大小，j对花费的贡献+1，所以我们可以看到j&gt;i的花费&lt;=i&gt;j的情况 最后我们经过所有的调整可以发现序列变成了dfs序 所以dfs序最优 完整代码将以上各步骤代码合在一起就是： tips. ANS要用long long!!! #include &lt;bits/stdc++.h&gt; using namespace std; inline int read(int &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } inline void write(long long x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int L=5.1e5+5; struct node{ //trie树的每个节点 int nt[26]; bool tag; }; long long ans; int cnt,last[L],sz[L],n; vector&lt;int&gt; g[L]; char s[L]; struct trie{ //trie及所需操作 node a[L]; int cnt; void ins(char *s){ //建树 int x=0; for(int i=0;s[i];i++){ if(!a[x].nt[s[i]-&#39;a&#39;]) a[x].nt[s[i]-&#39;a&#39;]=++cnt; x=a[x].nt[s[i]-&#39;a&#39;]; } a[x].tag=1; } void doit(int x){ //重构树 if(a[x].tag&amp;&amp;x){ g[last[x]].push_back(x); last[x]=x; } for(int i=0;i&lt;26;i++) if(a[x].nt[i]){ last[a[x].nt[i]]=last[x]; doit(a[x].nt[i]); } } }tr; inline bool cmp(const int &amp;x,const int &amp;y){ return sz[x]&lt;sz[y]; } void dfs(int x){ //重排重构树 sz[x]=1; for(int i=0;i&lt;g[x].size();i++){ dfs(g[x][i]); sz[x]+=sz[g[x][i]]; } sort(g[x].begin(),g[x].end(),cmp); } void getans(int x){ //统计答案 int dfn=cnt++; for(int i=0;i&lt;g[x].size();i++){ ans+=cnt-dfn; getans(g[x][i]); } } signed main(){ read(n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s); reverse(s,s+strlen(s)); //反转单词 tr.ins(s); } tr.a[0].tag=1; //根也是红点 tr.doit(0); dfs(0); getans(0); write(ans); }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://blog.yzcthinktwice.com/tags/贪心/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"},{"name":"字典树","slug":"字典树","permalink":"https://blog.yzcthinktwice.com/tags/字典树/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"P2658 【汽车拉力比赛】","slug":"P2658 【汽车拉力比赛】","date":"2019-10-27T14:49:01.000Z","updated":"2019-12-15T08:08:43.107Z","comments":true,"path":"2019/10/27/P2658 【汽车拉力比赛】/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/10/27/P2658 【汽车拉力比赛】/","excerpt":"","text":"P2658 【汽车拉力比赛】并查集的思路很多人已经讲过了，我这里提供几个并查集方法的（常数）优化 路径压缩&amp;按秩合并 int getf(int x){ if(f[x]==x) return x; return f[x]=getf(f[x]); } void unite(int x,int y){ int fx=getf(x),fy=getf(y); if(fx==fy) return; if(rk[fx]&lt;rk[fy]) f[fx]=fy; else f[fy]=fx; if(rk[fx]==rk[fy]) rk[fx]++; } 路径压缩应该很多人都加了吧。。。 四个方向（上下左右）-&gt;两个方向（下右） 边是双向的，而且是网格图，因此是有个层次性的，无需重复地双向都unite 将每个路标的fa与第一个路标的fa比较 可以节约一半的getf 另外，感觉自己的码风还挺好理解的。。。 #include &lt;bits/stdc++.h&gt; using namespace std; inline int read(int &amp;x){ char c=getchar();bool f=0;x=0; while(!isdigit(c)) f|=c==&#39;-&#39;,c=getchar(); while(isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); if(f) x=-x;return x; } inline void write(int x){ if(x&lt;0) putchar(&#39;-&#39;),write(-x); else{if(x&gt;9) write(x/10);putchar(&#39;0&#39;+x%10);} } const int N=505; int n,m,f[N*N],ans,rk[N*N],a[N][N],l,r; vector&lt;int&gt; tag; inline int hash(int x,int y){ return (x-1)*m+y; } inline int getf(int x){ if(f[x]==x) return x; return f[x]=getf(f[x]); //路径压缩 } inline void unite(int x,int y){ int fx=getf(x),fy=getf(y); if(fx==fy) return; if(rk[fx]&lt;rk[fy]) f[fx]=fy; //按秩合并 else f[fy]=fx; if(rk[fx]==rk[fy]) rk[fx]++; } inline bool check(int k){ for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) f[hash(i,j)]=hash(i,j),rk[hash(i,j)]=1; //并查集初始化 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ if(abs(a[i][j]-a[i+1][j])&lt;=k&amp;&amp;i+1&lt;=n) //向下unite(hash(i,j),hash(i+1,j)); if(abs(a[i][j]-a[i][j+1])&lt;=k&amp;&amp;j+1&lt;=m) //向右 unite(hash(i,j),hash(i,j+1)); } int fa=getf(tag[0]); //先得到第一个fa for(int i=1;i&lt;tag.size();i++) if(getf(tag[i])!=fa) //后面的与第一个比较 return 0; return 1; } signed main(){ read(n);read(m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ read(a[i][j]); r=max(r,a[i][j]); } for(int i=1;i&lt;=n;i++) for(int j=1,x;j&lt;=m;j++){ read(x); if(x) tag.push_back(hash(i,j)); //我用vector存路标 } while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; if(check(mid)) r=mid-1,ans=mid; else l=mid+1; } write(ans); } 另外，我这份代码是用c++交的，c++11以上会ce","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://blog.yzcthinktwice.com/tags/二分答案/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.yzcthinktwice.com/tags/洛谷/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF再次被skip","slug":"CF再次被skip","date":"2019-10-26T15:22:01.000Z","updated":"2019-12-15T08:10:18.360Z","comments":true,"path":"2019/10/26/CF再次被skip/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/10/26/CF再次被skip/","excerpt":"","text":"时隔多日，今天又来打打CF，本来可以上蓝的说。。。 结果sb又把自己skip了，一晚上白给 自闭了QAQ","categories":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"}],"keywords":[{"name":"日记","slug":"日记","permalink":"https://blog.yzcthinktwice.com/categories/日记/"}]},{"title":"HDU5521 Meeting","slug":"HDU5521 Meeting","date":"2019-07-17T14:11:01.000Z","updated":"2019-12-15T08:09:45.945Z","comments":true,"path":"2019/07/17/HDU5521 Meeting/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/07/17/HDU5521 Meeting/","excerpt":"","text":"HDU5521 Meeting 题意： 给你n个点，它们组成了m个团，第i个团内有si个点，且每个团内的点互相之间距离为ti，问如果同时从点1和点n出发，最短耗时多少相遇 很明显题目给出的是个无负环的图，且要跑出单源最短路，那不就是个dij吗 大方向定下，但图该怎么建呢？ way1:给每个团内的所有点两两暴力建边 如图所示：黑的为点，红的为团，相同颜色的边长度相等 共$\\sum ^{m}_{i=1}\\dfrac {1}{2}s_{i}\\left( s_{i}-1\\right)$条边 而题面又告诉我们$\\sum ^{m}_{i=1}s_{i}&lt;=10^6$ 边数1e12这谁顶得住啊QuQ way2:我们再看上面这张图，发现同个团内类似三角形的东西其实是不需要的，因为反正有更近的直接连接的边，为啥还要再去绕个圈去松弛操作呢？ 这时候我们就可以在每个团中建个虚点，改无向图为有向图，即实点可以0消耗到虚点，虚点要ti到实点 正如下图所示：蓝色的为虚点，灰色的为从实点到虚点的路径，长度为0；彩色的为从虚点到实点的路径，长度为ti 边数是不是被减少到了$\\sum ^{m}_{i=1}2s_{i}$？是不是很优秀？ 建完图后，分别以1和n为起点，跑一遍最短路 $Ans=min\\{max\\{点1到点i最短路,点n到点i最短路|1&lt;=i&lt;=n\\}\\}$ ps.这道题十分毒瘤，我提交后曾四次PE，输出请注意你的空格以及换行，避免冗余 typedef long long ll; const int N=2e5+5,M=4e6+5; int en,T,n,m,h[N],cnt,ans[N],nm; ll dis[2][N]; struct node{ int x; ll v; inline bool operator &lt; (const node &amp;nt) const {return v&gt;nt.v;} }; struct edge{int n,v;ll w;}e[M]; //前向星存边 inline void add(const int &amp;x,const int &amp;y,const ll &amp;z){e[++en]=(edge){h[x],y,z};h[x]=en;} void dij(int s){ //一个堆优dijkstra模板 int pos; //小技巧，提前判断好当前最短路应存进哪个dis[]数组 if(s==1) pos=0; else pos=1; priority_queue&lt;node&gt; q; memset(dis[pos],66,sizeof dis[pos]); q.push((node){s,0}); dis[pos][s]=0; while(!q.empty()){ node x=q.top(); q.pop(); if(x.v!=dis[pos][x.x]) continue; for(int i=h[x.x];i;i=e[i].n){ int y=e[i].v; if(dis[pos][x.x]+e[i].w&lt;dis[pos][y]){ dis[pos][y]=dis[pos][x.x]+e[i].w; q.push((node){y,dis[pos][y]}); } } } } signed main(){ scanf(&quot;%d&quot;,&amp;T); while(T--){ en=nm=0; memset(h,0,sizeof h); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1,t,s;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;t,&amp;s); int center=n+i; //虚点 for(int i=1,x;i&lt;=s;i++){ scanf(&quot;%d&quot;,&amp;x); add(x,center,0); //实点到虚点无长度 add(center,x,t); //虚点到实点有长度 } } dij(1); //从1跑 dij(n); //从n跑 ll MIN=dis[0][0]; for(int i=1;i&lt;=n;i++){ ll tp=max(dis[0][i],dis[1][i]); if(tp==MIN) ans[++nm]=i; //nm记录当前最优解共有几个，ans[]记录这些满足最优解的下标 if(tp&lt;MIN){ nm=1; //比当前最优解还优，刷新，重新从1开始 ans[1]=i; MIN=tp; } } printf(&quot;Case #%d: &quot;,++cnt); if(MIN==dis[0][0]) printf(&quot;Evil John\\n&quot;); //没有最优解-&gt;即无解 else{ printf(&quot;%lld\\n&quot;,MIN); for(int i=1;i&lt;=nm;i++) if(i&lt;nm) printf(&quot;%d &quot;,ans[i]); else printf(&quot;%d\\n&quot;,ans[i]); //最后一个后无空格 } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://blog.yzcthinktwice.com/tags/最短路/"},{"name":"HDU","slug":"HDU","permalink":"https://blog.yzcthinktwice.com/tags/HDU/"},{"name":"思维","slug":"思维","permalink":"https://blog.yzcthinktwice.com/tags/思维/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]},{"title":"CF1194D 1-2-K Game","slug":"CF1194D 1-2-K Game","date":"2019-07-15T14:11:01.000Z","updated":"2019-12-15T08:11:25.772Z","comments":true,"path":"2019/07/15/CF1194D 1-2-K Game/","link":"","permalink":"https://blog.yzcthinktwice.com/2019/07/15/CF1194D 1-2-K Game/","excerpt":"","text":"CF1194D 1-2-K Game 首先让我们考虑没有k的情况： 1. (n mod 3 =0)因为n可以被分解成若干个3相加 而每个3可以被分解为1+2或2+1 所以无论A出什么B都有方法应对 B胜 2. (n mod 3 =1)A可以先选择余数1 这样问题又回到了第一种情况 AB角色互换 A胜 3. (n mod 3 =2)与2同理，A先选2即胜 而现在多出来的这个k也可以看成是3的某个自然数倍数加上一个小于3的数 即$k\\equiv x\\left( mod3\\right)$ 我们再来对x分类讨论： 1. (x=0)此时的k就好像快速地切除1+2或2+1的回合 但对手总不会站着不动吧？ 我们知道B总是有方法使每一回合内(A+B)%3都等于1的 列举一下(k用3代替)： A:1 B:3 A:2 B:2 A:3 B:1 是不是每回合在mod3意义下都是相同的？ 那么若干个回合后如果无法实现上述方法了 即n%=k+1 如果n=k A获胜 否则情况又变回了无k的情况 %3判断即可 2. (x=1)此时k就好像有着能省略若干个回合功能的1 k就可有可无了 又回到了无k的情况 3. (x=2)与2同理 知道了这些，代码就很好写了： int n,k,t; signed main(){ scanf(&quot;%d&quot;,&amp;t); while(t--){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); if(k%3){ if(n%3) puts(&quot;Alice&quot;); else puts(&quot;Bob&quot;); } else{ n%=k+1; if(n==k||n%3) puts(&quot;Alice&quot;); else puts(&quot;Bob&quot;); } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}],"tags":[{"name":"CF","slug":"CF","permalink":"https://blog.yzcthinktwice.com/tags/CF/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.yzcthinktwice.com/tags/博弈论/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.yzcthinktwice.com/categories/算法/"}]}]}